#BlueJ/Greenfoot dialogues.
#Sat Nov 08 17:57:20 GMT 2008
as of release 1.4, 'assert' is a keyword, and may not be used as an identifier
Ordet 'assert' er nu en del af Java sproget
og har en speciel betydning (det er et n\u00F8gleord).
Du kan ikke bruge det til at navngive variable eller metoder.
V\u00E6lg et andet klasse-navn.

qualified new of static class
Ingen tilg\u00E6ngelig hj\u00E6lp.

* is abstract; cannot be instantiated
Klassen er erkl\u00E6ret som "abstrakt". Det betyder at
den indeholder nogle metoder for hvilke den ikke
lev\u00E9rer en implementation ("abstrakte metoder").
Du kan ikke lave objekter af abstrakte klasser.
Du skal finde eller skrive en subklasse af den
abstrakte klasse der implementerer alle abstrakte 
metoder. Du kan s\u00E5 lave objekter af den  
klasse.

abstract methods cannot have a body
Du har erkl\u00E6ret en metode som "abstrakt" og
du har skrevt en metode-krop. Det er en selvmodsigelse.
Abstrakte metode-erkl\u00E6ringer har kun et metode-hovede, 
efterfulgt af semikolon. Fjern enten "abstract" 
n\u00F8gleordet, eller fjern metode-kroppen.

* is already defined in *
Der er allerede en variabel (eller m\u00E5ske en
parameter) i denne metode der har det 
samme navn. Brug et andet navn for denne. 
(Eller m\u00E5ske ville du bruge den samme
variabel her? Fjern s\u00E5 type-navnet her
s\u00E5 det ikke ser ud som en ny
erkl\u00E6ring.)

anonymous class implements interface; cannot have arguments
Ingen tilg\u00E6ngelig hj\u00E6lp

anonymous class implements interface; cannot have qualifier for new
Ingen tilg\u00E6ngelig hj\u00E6lp

array required, but *
Du bruger en syntaks her, der tyder p\u00E5 at du 
pr\u00F8ver at tilg\u00E5 et liste-element. Variablen, du
refererer til er ikke en liste.

break outside switch or loop
"break" s\u00E6tningen bryder ud af en blok,
s\u00E5som en "switch"-s\u00E6tning eller en l\u00F8kke 
("for", "while" eller "do" l\u00F8kke). Den kan ikke 
bruges udenfor s\u00E5dan en blok.

* must be first statement in constructor
Som det f\u00F8rste i hver klasse, der har en 
superklasse, skal du kalde superklassen's 
konstrukt\u00F8r. Du g\u00F8r dette ved at tilf\u00F8je
    super(...);
som den f\u00F8rste linje i din konstrukt\u00F8r (hvor du
erstatter prikkerne med de korrekte parametre).
Fors\u00F8g p\u00E5 at kalde medlems-metoderne af superklassen f\u00F8r
dens konstrukt\u00F8r, skal g\u00E5 galt!

cannot access *
Ingen tilg\u00E6ngelig hj\u00E6lp

cannot assign a value to final variable *
Variablen du pr\u00F8ver at tildele en v\u00E6rdi her, er
erkl\u00E6ret som "final". Det betyder at du ikke har 
tilladelse til at \u00E6ndre dens v\u00E6rdi senere. Hvis du virkelig
har brug for at \u00E6ndre v\u00E6rdien, s\u00E5 fjern "final" n\u00F8gleordet
fra variabel-erkl\u00E6ringen.

type variables cannot be dereferenced
Du kan ikke bruge punktum-notation til at tilg\u00E5
medlems-felter eller -metoder for type variable.

* cannot be dereferenced
Du bruger punktum-notation til at tilg\u00E5 et felt eller metode
i et andet objekt. Men variablen du bruger,
er ikke af en objekt-type - den har ikke felter eller
metoder.

cannot inherit from final *
Superklassen (klassen der st\u00E5r efter 
"extends" n\u00F8gleordet) er erkl\u00E6ret som final. Det 
betyder at den ikke tillader 
subklasser. Desv\u00E6rre - du kan ikke lave subklasser
hvis den ikke tillader det...

* before supertype constructor has been called
Du skal kalde superklassens konstrukt\u00F8r som det
allerf\u00F8rste i enhver klasse der har en superklasse.
Du g\u00F8r dette ved at tilf\u00F8je:
    super(...);
som den f\u00F8rste linje i din konstrukt\u00F8r (hvor du
erstatter punktummerne med de n\u00F8dvendige parametre).
Fors\u00F8g p\u00E5 at kalde medlemmer af superklassen f\u00F8r
kald af dens konstrukt\u00F8r, skal g\u00E5 galt!

cannot return a value from method whose result type is void
En 'void' retur-type i en metode betyder at denne 
metode ikke returnerer et resultat. Metode-kroppen 
b\u00F8r ikke have en s\u00E6tning der returnerer en v\u00E6rdi.

cannot select a static class from a parameterized type
Ingen tilg\u00E6ngelig hj\u00E6lp.

* cannot be inherited with different arguments:*
Ingen tilg\u00E6ngelig hj\u00E6lp.

'catch' without 'try'
"catch" er et Java n\u00F8gleord der kun kan optr\u00E6de efter en
"try" blok. Det korrekte m\u00F8nster er
   try {
      s\u00E6tninger;
   }
   catch(Exception e) {
     s\u00E6tninger;
   }

* clashes with package of same name
V\u00E6r sikker p\u00E5 at klassen og pakken
har forskellige navne. Som regel skal klasser 
starte med et stort bogstav, mens
pakke-navne starter med et lille bogstav.

code too large for try statement
Du har for meget kode inden i denne try-s\u00E6tning.
Flyt koden til en separat metode og inds\u00E6t et  
metode-kald her.

constant expression required
Du har brugt en variabel eller et udtryk her, men
det er ikke tilladt. Du kan kun bruge konstanter her.
Konstanter er tal (s\u00E5som 42) eller 
identifikatorer erkl\u00E6ret som "final".

continue outside of loop
"continue" s\u00E6tningen bruges til at 
starte n\u00E6ste l\u00F8kke-iteration med det
samme. Den har ingen betydning udenfor
en l\u00F8kke. Den kan kun bruges indenfor
en "for", "while" eller "do" l\u00F8kke.

cyclic inheritance involving *
Du pr\u00F8ver at arve fra en klasse her, men
den klasse har allerede erkl\u00E6ret at den
arver fra din! Tjah, det dur ikke!
Du skal beslutte hvilken der er  
superklassen, og hvilken der er subklassen.

* does not exist
Det navn du brugte her (det kan v\u00E6re et fors\u00F8g p\u00E5 at
angive en variabel, en klasse eller en 
pakke) eksisterer ikke. Der var hverken en 
variabel, en klasse eller en pakke med dette 
navn.

duplicate class:*
Det ser ud til at der allerede er en klasse med dette navn.

duplicate case label
Du har brugt den samme m\u00E6rkat to gange i den samme 
"switch" s\u00E6tning.

duplicate default label
Du har skrevet "default" to gange i den samme "switch" 
s\u00E6tning. Det kan du ikke - en gang er nok.

'else' without 'if'
Et 'else' n\u00F8gleord kan kun v\u00E6re en del af en 'if'
s\u00E6tning, p\u00E5 formen
   if (condition)
     s\u00E6tning;
   else
     s\u00E6tning;
M\u00E5ske glemte du bare kr\u00F8lle-parenteser omkring s\u00E6tningerne?
Hvis du har mere end en s\u00E6tning efter "if", skal du tilf\u00F8je
kr\u00F8lle-parenteser, s\u00E5ledes:
   if (betingelse) 
   {
      s\u00E6tning1;
      s\u00E6tning2;
   }
   else
   {
      s\u00E6tning3;
   }

empty character literal
Du har lavet en char der er tom.
Du kan ikke skrive ''.  En char-konstant er et enkelt 
tegn omsluttet af apostroffer, for eksempel 'a'. 
For det meste kan der kun v\u00E6re et enkelt tegn 
mellem apostrofferne. Den eneste undtagelse er hvis det f\u00F8rste  
tegn er "backslash" (kaldet "escape-tegnet") 
til at angive specielle tegn som f.eks. '\n' eller '\t'.  

* has already been caught
Denne catch-s\u00E6tning er ubrugelig. Den kan
aldrig k\u00F8res, fordi alle undtagelser
som den er erkl\u00E6ret til at fange, allerede 
fanges af en anden catch-s\u00E6tning oven over.

* is never thrown in body of corresponding try statement
Du har erkl\u00E6ret at du vil fange
en undtagelse her. Men jeg kan fort\u00E6lle dig at
denne undtagelse aldrig vil ske her!
Der er ingen s\u00E6tninger i "try" blokken
der laver denne undtagelse.

'finally' without 'try'
"finally" er et n\u00F8gleord der kun kan optr\u00E6de efter en
"try" blok. Det korrekte m\u00F8nster er
   try {
      s\u00E6tninger;
   }
   catch(Exception e) {
     s\u00E6tninger;
   }
   finally {
      s\u00E6tninger;
   }

floating point number too large
Systemet kan ikke h\u00E5ndtere komma-tal der er 
s\u00E5 store.

floating point number too small
Systemet kan ikke h\u00E5ndtere komma-tal der er 
s\u00E5 sm\u00E5.

inner classes cannot have static declarations
Du kan ikke erkl\u00E6re statiske typer i
indre klasser. Hvis du har brug for en statisk
type her, s\u00E5 erkl\u00E6r den i den ydre klasse.

illegal character:*
Der er en ulovlig karakter her i kildekode-
filen. Denne karakter kan v\u00E6re usynlig. Hvis du ikke kan
finde den, s\u00E5 slet hele linjen og indtast
den igen.

illegal combination of modifiers: *
Du har fors\u00F8gt at kombinere to Java ord som
ikke kan bruges sammen.  Sandsynligvis er 
betydningen af de to ord modstridende.
Et eksempel kunne v\u00E6re en metode der er erkl\u00E6ret som "abstract"
og "native", "final", "private" eller "synchronized".

illegal escape character
En escape karakter er skrevet med en "backslash"
og en anden karakter, for eksempel '\n'. Dette bruges
til at specificere karakterer. Der er kun 
nogle bestemte karakterer der kan optr\u00E6de efter 
"backslash"'en. De er \n, \t, \b, \r, \f, \\,
\', \" og tal. Hvis du vil skrive selve 
"backslash"'en, skriv "\\" - dette vil blive erstatte
af en enkelt "backslash" i din streng.

illegal forward reference
Ingen tilg\u00E6ngelig hj\u00E6lp

illegal initializer for *
Ingen tilg\u00E6ngelig hj\u00E6lp

illegal line end in character literal
Du har et linjeskift hvor der burde v\u00E6re specificeret
en karakter. Det kan du ikke g\u00F8re. Hvis du vil specificere
karakteren for et linjeskift ("newline"), s\u00E5 skriv det som '\n'.

illegal qualifier; {0} is not an inner class
Ingen tilg\u00E6ngelig hj\u00E6lp

illegal start of expression
Ingen tilg\u00E6ngelig hj\u00E6lp

illegal start of type
P\u00E5 en position i kildekoden, hvor navnet p\u00E5
en type var ventet, var der noget andet
(h\u00F8jst sandsynligt et Java n\u00F8gleord). Check denne linje
for ukorrekte type definitioner.

illegal unicode escape
Ingen tilg\u00E6ngelig hj\u00E6lp

improperly formed type, some parameters are missing
Ingen tilg\u00E6ngelig hj\u00E6lp

incomparable types: *
Ingen tilg\u00E6ngelig hj\u00E6lp

integer number too large: *
Du har skrevet et tal der er for stort til at passe 
i den data-type der er ventet her. Du skal bruge
en st\u00F8rre data-type
(for eksempel, "long" i stedet for "int").

internal error; cannot instantiate *
Ingen tilg\u00E6ngelig hj\u00E6lp

* but with different return type
Du er sikkert i gang med at kombinere to metoder der er ens
p\u00E5n\u00E6r typen af det, der returneres.  Dette er ikke tilladt.
Sandsynligvis sker dette fordi din klasse implementerer
to interfaces. Hvert interface har en metode med samme navn
og samme parametre, med forskellig retur-type. Du kan ikke 
implementere begge disse interfaces medmindre du \u00E6ndrer det ene 
for at undg\u00E5 dette. Omd\u00F8b enten metoden, eller g\u00F8r retur-typen 
ens.

interface expected here
Et interface kan kun udvide et andet interface. Navnet
du har specificeret efter "extends" n\u00F8gleordet, er ikke et
interface.

interface methods cannot have body
Interface metode kan kun v\u00E6re erkl\u00E6ringer.
Det betyder at de skal indeholde et metode- 
hovede, efterfulgt af semikolon. Der skal  
ikke v\u00E6re en metode krop.

hexadecimal numbers must contain at least one hexadecimal digit
Du specificerer et heksadecimalt tal. (Dette g\u00F8res 
ved at starte et tal med "0X".) I heksadecimale tal skal
du have mindst et tal efter "X".

invalid method declaration; return type required
En metode erkl\u00E6ring skal have erkl\u00E6ret en retur-type.
For eksempel, hvis din metode returnerer en streng, skriv
    public String myMethod();
Hvis du ikke vil returnere en v\u00E6rdi fra denne metode,
s\u00E5 brug det specielle ord "void" for at indikere at der
ingen retur-type er. For eksempel
    public void myMethod();

* already in use
Der er allerede en variabel (eller m\u00E5ske en
parameter) i denne metode der har samme 
navn. Brug et andet navn for denne.
(Eller m\u00E5ske ville du bruge den samme variabel
her? S\u00E5 fjern type-navnet her,
s\u00E5 det ikke ser ud som en ny
erkl\u00E6ring.)

* is accessed from within inner class; needs to be declared final
Lokale variable kan som regel ikke tilg\u00E5s af indre 
klasser. Men det er pr\u00E6cis hvad du pr\u00F8ver at g\u00F8re
her. Du har to muligheder: Du kan fjerne denne
brug af den lokale variabel, eller du kan g\u00F8re
variablen "final" - s\u00E5 kan du tilg\u00E5 den.

malformed floating point literal
Du har lavet en fejl da du skrev et
komma-tal. (Et komma-tal er et tal
med decimal-separator i) Eksempler p\u00E5 korrekt 
skrevne decimal-tal er
18.0      18.     1.8e1     .18E2

missing method body, or declare abstract
Metoder skal enten have en krop, eller v\u00E6re abstrakte. En
metode-krop er blokken i kr\u00F8lle-parenteser { } der 
f\u00F8lger efter metode-hovedet og indeholder s\u00E6tninger.
Hvis en metode ikke har en krop, skal den have
n\u00F8gleordet "abstract" i dens hovede. For eksempel:
    public abstract int getAnswer();

missing return statement
Her har du en metode der er erkl\u00E6ret til at returnere en 
v\u00E6rdi. Der er dog ikke nogen "return" s\u00E6tning i kroppen
af metoden. Det passer ikke sammen. Du skal enten:
   - erkl\u00E6re metodens retur-type til "void"
     hvis du ikke vil returnere en v\u00E6rdi, eller
   - skriv en "return" s\u00E6tning med den korrekte 
     retur-type i slutningen af metoden, for 
     eksempel
         return 42;
Typen p\u00E5 retur-v\u00E6rdien skal passe med den erkl\u00E6rede type
i metodens hovede.

missing return value
Her har du skrevet en "return" s\u00E6tning der ikke
returnerer en v\u00E6rdi. Metode-hovedet erkl\u00E6rer dog
at denne metode returnerer en v\u00E6rdi. Du skal enten erkl\u00E6re
at denne metode ikke returnerer en v\u00E6rdi (ved at bruge "void"
som retur-type i metode-hovedet), eller 
returnere en v\u00E6rdi af den korrekte type, for eksempel 
    return 42;
eller
    return "Marvin";

name clash: *
Du har defineret to metoder med samme navn. Dette 
er kun tilladt hvis den ene overstyrer den anden (hvilket ikke er
tilf\u00E6ldet her). Et af navnene skal \u00E6ndres.

* is reserved for internal use
Udtrykket er reserveret til intern brug. Hvis det er 
navnet p\u00E5 en klasse eller variabel, skal du \u00E6ndre det.

native methods cannot have a body
Du har erkl\u00E6ret en metode som v\u00E6rende "native" og du har skrevet  
en metode-krop. "Native" metode erkl\u00E6ringer har kun et
metode-hovede, fulgt af et semikolon. Fjern enten
"native" n\u00F8gleordet, eller fjern metode-kroppen.

no enclosing instance of type {0} is in scope
Ingen tilg\u00E6ngelig hj\u00E6lp

no interface expected here
Du refererer til et interface her (muligvis i 
en "extends" erkl\u00E6ring af en klasse). En klasse kan kun
udvide andre klasser (ikke interfaces). Hvis du vil 
implementere dette interface, s\u00E5 brug "implements" n\u00F8gleordet
i stedet.

{0} has no match in entry in {1}; required {2}
Ingen tilg\u00E6ngelig hj\u00E6lp

* is not defined in a public class or interface; cannot be accessed from outside package
Ingen tilg\u00E6ngelig hj\u00E6lp

* cannot be accessed from outside package
Klassen du pr\u00F8ver at bruge her, er ikke en "public" klasse.
Dvs.: dens definition starter ikke med
   public class ...
Hvis en klasse ikke er "public", kan den ikke bruges udenfor
dens egen pakke. Hvis du virkelig har brug for at bruge klassen, skal
du \u00E6ndre dens definition, s\u00E5 den bliver "public".

not a loop label: *
De m\u00E6rker du bruger til l\u00F8kke-operationer s\u00E5som
   continue <m\u00E6rke>;
skal defineres til at markere en l\u00F8kke (dvs.: de
skal s\u00E6ttes umiddelbart f\u00F8r starten p\u00E5
l\u00F8kken). Det m\u00E6rke du har n\u00F8vnt her, er ikke p\u00E5 det rigtige
sted - den markerer ikke en l\u00F8kke.

not a statement
Du har skrevet en linje kode her, der ikke er en
hel s\u00E6tning. Overvej igen hvad du ville g\u00F8re,
og hvordan du vil g\u00F8re det.

not an enclosing class:*
Du har pr\u00F8vet at tilg\u00E5  "nuv\u00E6rende-objekt-pegepind" ('this')
fra en anden klasse uden for din egen. Dette er kun tilladt 
hvis den anden klasse er udenom den nuv\u00E6rende
(med andre ord: i en indre klasse, kan du tilg\u00E5 den ydre
klasse, men ikke andre).

* cannot be applied to *
Operatoren du bruger her, kan ikke bruges for den type
v\u00E6rdi du bruger den til. Du bruger enten den
forkerte type her, eller den forkerte operator.

* clashes with class of same name
V\u00E6r sikker p\u00E5 at klassen og pakken
har forskellige navne. Som regel skal klasser 
starte med stort bogstav, mens
pakke-navne starter med lille bogstav.

possible fall-through into case
Ingen tilg\u00E6ngelig hj\u00E6lp

error reading *
Ingen tilg\u00E6ngelig hj\u00E6lp

recursive constructor invocation
Du har skrevet kode der g\u00F8r at denne
konstrukt\u00F8r kalder sig selv. Det er ikke
tilladt (og vil h\u00F8jst sandsynligt f\u00F8re til
en uendelig l\u00F8kke).

* is ambiguous, both *
Den identifikator der er n\u00E6vnt i denne besked kan ikke bestemmes
ordentligt fordi der er mere end en klasse eller interface 
med dette navn defineret i pakkerne du har importeret.
Du kan enten referere til klassen her med dens fulde
navn (f.eks. java.util.List) eller importere klassen med dens fulde
navn (f.eks. import java.util.List).

repeated interface
Du har skrevet det samme interface
to gange i den samme "implements"
erkl\u00E6ring. En gang er nok. S\u00E5
d\u00E5rlig er min hukommelse ikke!

repeated modifier
I denne erkl\u00E6ring har du skrevet den samme
modifikator to gange. En modifikator er et n\u00F8gleord s\u00E5som
final, static, public, private, volatile, ...

{0} has {1} access in {2}
Ingen tilg\u00E6ngelig hj\u00E6lp

return outside method
Du kan kun bruge en 'return' s\u00E6tning i metoder
(ikke i initializer-blokke eller andre ikke-metode
kode-stumper).

signature does not match {0}; incompatible interfaces
Ingen tilg\u00E6ngelig hj\u00E6lp

signature does not match {0}; incompatible supertype
Ingen tilg\u00E6ngelig hj\u00E6lp

* should be declared abstract; it does not define *
Den nuv\u00E6rende klasse arver fra en abstrakt klasse
eller et interface. Abstrakte klasser og interfaces 
definerer metoder uden at angive implementationen.
Denne klasse definerer ikke implementationer for 
alle de metoder der stadig mangler implementationer,
s\u00E5 denne klasse er selv abstrakt endnu (det betyder
at den stadig har metoder uden implementationer).
Du skal enten erkl\u00E6re denne klasse som v\u00E6rende abstrakt  
ved at starte den med
   public abstract class ...
i stedet for bare 
   public class ...
eller ogs\u00E5 skal du lave en implementation for  
metoden der er n\u00E6vnt i fejl-meddelelsen.

* is not abstract and does not override abstract method *
Den nuv\u00E6rende klasse arver fra en abstrakt klasse 
eller et interface. Abstrakte klasser og interfaces 
definerer metoder uden at angive implementationen.
Denne klasse definerer ikke implementationer for 
alle de metoder der stadig mangler implementationer,
s\u00E5 denne klasse er selv abstrakt endnu (det betyder
at den stadig har metoder uden implementationer).
Du skal enten erkl\u00E6re denne klasse som v\u00E6rende abstrakt  
ved at starte den med
   public abstract class ...
i stedet for bare 
   public class ...
eller ogs\u00E5 skal du lave en implementation for  
metoden der er n\u00E6vnt i fejl-meddelelsen.

error writing source; cannot overwrite input file *
Ingen tilg\u00E6ngelig hj\u00E6lp

'try' without 'catch' or 'finally'
Hvis du bruger en "try" blok, skal den efterf\u00F8lges 
af enten en "catch" blok eller en "finally" blok (eller
begge dele).  Det korrekte m\u00F8nster er
   try {
      s\u00E6tninger;
   }
   catch(Exception e) {
     s\u00E6tninger;
   }
   finally {
      s\u00E6tninger;
   }

* does not take parameters
Typen du har brugt skal ikke have parametre.
Du kan ikke give den en parameter her.

wrong number of type arguments; required *
Ingen tilg\u00E6ngelig hj\u00E6lp

type variable {0} occurs more than once in result type of {1}; cannot be left uninstantiated
Ingen tilg\u00E6ngelig hj\u00E6lp

type variable {0} occurs more than once in type of {1}; cannot be left uninstantiated
Ingen tilg\u00E6ngelig hj\u00E6lp

unclosed character literal
Det er sandsynligt at du har erkl\u00E6ret en karakter, og
ikke tilf\u00F8jet den sidste apostrof: '.

unclosed comment
Det er sandsynligt at du har skrevet en kommentar, og ikke
lukket den rigtigt: */

unclosed string literal
Det er sandsynligt at du har erkl\u00E6ret en streng 
(startende med anf\u00F8rselstegn) og glemt at lukke den 
med anf\u00F8rselstegn: ". Strengen skal lukkes p\u00E5 samme linje
som den startede p\u00E5.

undefined label: *
Variablen du pr\u00F8ver at bruge her kan ikke
findes. Enten blev den aldrig erkl\u00E6ret, eller den blev
erkl\u00E6ret et sted hvor du ikke kan se den.
Det f\u00F8rste sker nemt, hvis du har en stavefejl
i en variabel. Check at variablen er
stavet korrekt, inklusive alle store bogstaver
("etTal" er ikke det samme som "ettal"!).
Det andet tilf\u00E6lde sker, hvis en variabel er erkl\u00E6ret 
indeni en blok. (En blok er et par kr\u00F8lle-parenteser, 
som f.eks.: { }.) Hvis du for eksempel har en variabel-erkl\u00E6ring
indeni en l\u00F8kke, s\u00E5 er variablen kun synlig
indeni denne l\u00F8kke. Tommelfinger-reglen er:
en variabel bliver usynlig efter kr\u00F8lle-parentesen (})
der lukker den blok som den er erkl\u00E6ret i.

unreachable statement
Denne s\u00E6tning vil aldrig blive k\u00F8rt. Hvis
du unders\u00F8ger koden n\u00F8je, vil du
bem\u00E6rke at programmet aldrig kan 
n\u00E5 denne s\u00E6tning. Slet den hvis
du virkelig ikke vil have den k\u00F8rt, 
eller ret din kode.

initializer must be able to complete normally
Du kan ikke lave undtagelser eller p\u00E5 anden m\u00E5de
terminere statiske initialiser-blokke. Du
skal lade dem k\u00F8re f\u00E6rdig.

* must be caught or declared to be thrown
Din kode laver et kald til en metode der kan lave 
en undtagelse. Du har to valg: Du kan enten 
fange denne undtagelse, eller du kan erkl\u00E6re at din  
metode sender den videre. Hvis du vil fange
undtagelsen, skal du bruge en 
   try 
   {
      ...
   }
   catch(...)
   {
      ...
   }
blok.
Hvis du vil sende den videre, skal du skrive 
erkl\u00E6ringen
   throws <ExceptionName>
ind i hovedet p\u00E5 din metode.

'void' type not allowed here
Typen 'void' kan ikke bruges i denne kontekst. Det er
en speciel type der bruges til at indikere at der ikke returneres 
noget fra  metoder.  Den kan ikke bruges som en variabel-type.

* not allowed here
Du har anvendt en adgangs-modifikator (s\u00E5som "private", 
"protected", osv.). Dette er ikke tilladt 
her.

* might already have been assigned to
En "final" variabel kan kun tildeles en gang. (Din variabel
her er final.) Du har to tildelinger til denne
variabel i din kode, og overs\u00E6tteren tror at det kan ske, 
at begge tildelinger k\u00F8res.

* might not have been initialized
Du bruger en lokal variabel som m\u00E5ske ikke er
initialiseret f\u00F8r den bruges her. Hvis du er i tvivl,
s\u00E5 initialiser den hvor den erkl\u00E6res.

variable {0} might be assigned in loop
Ingen tilg\u00E6ngelig hj\u00E6lp

error while writing *
Ingen tilg\u00E6ngelig hj\u00E6lp

* is public, should be declared in a file named *
"Public" klasser skal ligge i en fil
med samme navn som klassen, med et ".java" efternavn.  
For eksempel skal en "public" klasse der hedder "Foo",
ligge i en fil ved navn "Foo.java".

cannot read: *
Ingen tilg\u00E6ngelig hj\u00E6lp

* uses or overrides a deprecated API.
Du bruger en metode der ikke l\u00E6ngere kan anbefales.
Det er sandsynligt at der er en anden metode eller klasse 
der leverer samme funktionalitet. Se i API- 
dokumentationen for flere detaljer

* has been deprecated
Du bruger en metode der ikke l\u00E6ngere kan anbefales.
Det er sandsynligt at der er en anden metode eller klasse  
der leverer samme funktionalitet. Se i API- 
dokumentationen for flere detaljer

';' expected
Der mangler et semikolon i slutningen af 
en linje. Det kan v\u00E6re linjen, der er markeret i
editoren, eller linjen ovenover.

'case', 'default' or '}' expected
Ingen tilg\u00E6ngelig hj\u00E6lp

'class' or 'interface' expected
Ordet "class" eller "interface" forventes at
optr\u00E6de n\u00E6r toppen af en kildekode-fil.
Dette mangler her (eller ogs\u00E5 er der noget foran
det, der ikke h\u00F8rer til her).

'.class' expected
Ingen tilg\u00E6ngelig hj\u00E6lp

'(' or '[' expected
Det ser ud til at der er et ulige antal parenteser
i din kode der forvirrer overs\u00E6tteren. Kig n\u00F8je
din kode igennem for matchende \u00E5ben- og 
luk-parenteser.

* expected
Symbolet der er n\u00E6vnt i fejl-meddelelsen 
forventedes at optr\u00E6de p\u00E5 dette sted i koden.
Det var der ikke; i stedet var der et andet
symbol. Pr\u00F8v at overveje hvorfor dette 
symbol kan v\u00E6re forventet her.

orphaned *
Ingen tilg\u00E6ngelig hj\u00E6lp

type parameter {0} is not within its bound *
Ingen tilg\u00E6ngelig hj\u00E6lp

type parameters of {0} cannot be determined
Ingen tilg\u00E6ngelig hj\u00E6lp

incompatible types*
Der var et udtryk af en bestemt type p\u00E5kr\u00E6vet
her. Der var et udtryk af en andet type,
der ikke er kompatibel. (F.eks. skrev du en
streng hvor et tal var ventet.)

inconvertible types*
Typen du har brugt her, kan ikke automatisk
konverteres til den p\u00E5kr\u00E6vede type.

possible loss of precision
Ingen tilg\u00E6ngelig hj\u00E6lp

unexpected type
Der var et udtryk af en bestemt type p\u00E5kr\u00E6vet
her. Der var et udtryk af en andet type,
der ikke er kompatibel. (F.eks. skrev du en
streng hvor et tal var ventet.)

abstract {0} {1} cannot be accessed directly
Ingen tilg\u00E6ngelig hj\u00E6lp

*An explicit 'this' qualifier must be used to select the desired instance.
Ingen tilg\u00E6ngelig hj\u00E6lp

*cannot be referenced from a static context
Du pr\u00F8ver at tilg\u00E5 et instans-felt eller en instans-
metode fra en statisk metode. Dette er ikke tilladt.
Instans felterne og metoderne h\u00F8rer til et objekt, men
du har ingen aktive objekter i statiske metoder.
Statiske metoder kan kun kalde andre statiske metoder i 
deres klasse (eller ogs\u00E5 skal de bruge et eksplicit objekt
til kaldet).

cannot find symbol*
Du bruger et symbol her (et navn p\u00E5 en variabel,
en metode, eller en klasse) der ikke er erkl\u00E6ret et
tilg\u00E6ngeligt sted. Check hvordan du staver navnet -
skrev du forkert? Eller har du glemt at erkl\u00E6re navnet?
Eller m\u00E5ske har du erkl\u00E6ret det, men det er ikke synligt
herfra.

cannot resolve symbol*
Du bruger et symbol her (et navn p\u00E5 en variabel,
en metode, eller en klasse) der ikke er erkl\u00E6ret et
tilg\u00E6ngeligt sted. Check hvordan du staver navnet -
skrev du forkert? Eller har du glemt at erkl\u00E6re navnet?
Eller m\u00E5ske har du erkl\u00E6ret det, men det er ikke synligt
herfra.

{0}; {1} and {2} are static
Ingen tilg\u00E6ngelig hj\u00E6lp

{0}; overridden method is {1}
Ingen tilg\u00E6ngelig hj\u00E6lp

* attempting to assign weaker access privileges; was *
Du overstyrer en metode her, og du \u00E6ndrer adgangs-
rettigheden (private, protected, public). Du kan kun \u00E6ndre adgangs- 
rettigheden for at tillade mindre restriktiv adgang (f.eks. fra private til public)
men du kan ikke g\u00F8re det mere restriktivt (f.eks. fra public til
private). Du kan selvf\u00F8lgelig lade det v\u00E6re som det var.

* overridden method does not throw *
Du overstyrer en metode her, og du laver en
undtagelse. Overstyrende metoder kan ikke lave undtagelser
som den overstyrede (superclass) metode ikke ogs\u00E5
laver. Metoden i subklassen kan lave f\u00E6rre 
undtagelser, men ikke flere.

* attempting to use incompatible return type
Ingen tilg\u00E6ngelig hj\u00E6lp

* is already defined in this compilation unit
Du har brugt dette navn to gange her. V\u00E6lg et andet
navn for denne identifikator.

{0} is already defined in a single-type import
Ingen tilg\u00E6ngelig hj\u00E6lp

* conflicts with a compiler-synthesized symbol in *
Ingen tilg\u00E6ngelig hj\u00E6lp

