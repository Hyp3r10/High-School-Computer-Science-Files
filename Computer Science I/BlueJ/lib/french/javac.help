as of release 1.4, 'assert' is a keyword, and may not be used as an identifier
Le mot-cl\u00e9 'assert' fait maintenant partie du langage Java et a
une signification particuli\u00e8re. Vous ne pouvez pas l'utiliser
comme identificateur de variable ou de m\u00e9thode.
Choisissez un autre nom.

qualified new of static class
Aucune aide disponible.

* is abstract; cannot be instantiated
La classe est abstraite ("abstract").  Ce qui signifie
qu'elle comprend une ou plusieurs m\u00e9thodes dont
l'impl\u00e9mentation n'est pas fournie (des "m\u00e9thodes
abstraites").  Vous ne pouvez pas cr\u00e9er d'objets
abstraits.  Trouvez (ou cr\u00e9ez) une classe descendante
qui impl\u00e9mente les m\u00e9thodes abstraites.
Vous pourrez alors cr\u00e9er des objets de cette
classe.

abstract methods cannot have a body
Vous avez d\u00e9clar\u00e9 une m\u00e9thode abstraite ("abstract") et
vous lui avez donn\u00e9 un corps.  Ceci est une contradiction.
La d\u00e9claration d'une m\u00e9thode abstraite consiste en une
ent\u00eate suivie d'un point-virgule.Supprimez ou bien le mot-cl\u00e9
"abstract" ou bien le corps de la m\u00e9thode.

* is already defined in *
Il existe d\u00e9j\u00e0 une variable (ou un param\u00e8tre)
dans cette m\u00e9thode qui porte le m\u00eame nom.
Choisissez un nom diff\u00e9rent.  Cherchiez-vous
\u00e0 utiliser la m\u00eame variable ?  Dans ce cas,
supprimez le nom de type afin de ne pas
d\u00e9clarer la variable une seconde
fois.

anonymous class implements interface; cannot have arguments
Aucune aide disponible

anonymous class implements interface; cannot have qualifier for new
Aucune aide disponible

array required, but *
La syntaxe utilis\u00e9e laisse croire que vous tentez
d'acc\u00e9der \u00e0 un \u00e9l\u00e9ment d'un tableau.  Or, la variable
sp\u00e9cifi\u00e9e n'en est pas un.

break outside switch or loop
L'instruction "break" sert \u00e0 sortir d'un bloc d'instructions,
comme une instruction "switch" ou une boucle ("for", "while" ou "do").
Vous ne pouvez pas l'utiliser dans un autre cas.
Pour sortir d'une m\u00e9thode, utilisez "return".

* must be first statement in constructor
Lorsqu'une classe a un anc\u00eatre (super-classe),
son constructeur devrait toujours commencer par
appeler le constructeur de l'anc\u00eatre :
    super(...);
devrait \u00eatre la premi\u00e8re instruction de votre
constructeur (en rempla\u00e7ant l'ellipse par les param\u00e8tres
appropri\u00e9s, bien s\u00fbr).  Tenter d'utiliser les membres de
la super-classe sans appeler le constructeur va causer des probl\u00e8mes !

cannot assign a value to final variable *
La variable que vous tentez de modifier a \u00e9t\u00e9 d\u00e9clar\u00e9e
finale ("final").  Ce qui signifie que vous ne pouvez
pas changer sa valeur.  Si vous avez vraiment \u00e0 changer
sa valeur, supprimez le mot-cl\u00e9 "final" de sa
d\u00e9claration.

type variables cannot be dereferenced
Vous ne pouvez pas utiliser le "." pour tenter d'acc\u00e9der
aux champs ou m\u00e9thodes membres d'une variable-type.

* cannot be dereferenced
Vous tentez d'utiliser le "." pour acc\u00e9der \u00e0 un champ
ou une m\u00e9thode d'un objet.  Cependant, la variable utilis\u00e9e
n'est pas de type objet - elle ne poss\u00e8de pas de champs
ni de m\u00e9thodes.

cannot inherit from final *
La super-classe (l'anc\u00eatre mentionn\u00e9 par le mot-cl\u00e9
"extends") a \u00e9t\u00e9 d\u00e9clar\u00e9e finale.  Ceci signifie
qu'elle n'accepte pas de sous-classes.
D\u00e9sol\u00e9 - vous ne pouvez pas la sous-classer sans
son consentement...

* before supertype constructor has been called
Lorsqu'une classe a un anc\u00eatre (super-classe),
son constructeur devrait toujours commencer par
appeler le constructeur de l'anc\u00eatre :
    super(...);
devrait \u00eatre la premi\u00e8re instruction de votre constructeur
(en rempla\u00e7ant l'ellipse par les param\u00e8tres  appropri\u00e9s,
 bien s\u00fbr).  Tenter d'utiliser les membres \ de la super-classe
sans appeler le constructeur va causer des probl\u00e8mes !

cannot return a value from method whose result type is void
Un type de r\u00e9sultat "void" dans la signature d'une m\u00e9thode
signifie qu'elle n'en retourne aucun.  Le corps de la
m\u00e9thode ne doit donc pas avoir d'instruction "return".

cannot select a static class from a parameterized type
Aucune aide disponible

* cannot be inherited with different arguments:*
Aucune aide disponible

'catch' without 'try'
"catch" est un mot-cl\u00e9 Java qui ne peut appara\u00eetre
qu'apr\u00e8s un bloc "try".  La syntaxe est :
   try {
      ...
   }
   catch(Exception e) {
      ...
   }

* clashes with package of same name
Assurez-vous que la classe et le paquetage portent
des noms diff\u00e9rents. Par convention, les noms
de classes d\u00e9butent par une majuscule, les
noms de paquetages par une minuscule.

code too large for try statement
Il y a trop d'instructions \u00e0 l'int\u00e9rieur du bloc
"try". Cr\u00e9ez une m\u00e9thode distincte et appelez-la
depuis le bloc.

constant expression required
Vous avez utilis\u00e9 une variable ou une expression ici,
ce qui est ill\u00e9gal.  Vous ne pouvez utiliser que des
constantes ici.  Une constante est un nombre (e.g. "42")
ou un identificateur d\u00e9clar\u00e9 "final".

continue outside of loop
L'instruction "continue" sert \u00e0 passer
\u00e0 l'it\u00e9ration suivante d'une boucle
("for", "while" ou "do"). On ne peut donc
l'utiliser en dehors d'une boucle.


cyclic inheritance involving *
Vous tentez de sous-classer une classe, mais
cette derni\u00e8re a d\u00e9j\u00e0 d\u00e9clar\u00e9
qu'elle sous-classait votre sous-classe !
Deux classes ne peuvent \u00eatre des sous-classes
l'une de l'autre.

* does not exist
Le nom sp\u00e9cifi\u00e9 ici (d\u00e9signant une variable,
classe ou paquetage) n'existe pas.  Aucune
variable, classe ou paquetage ne porte ce nom.

duplicate class:*
Il semble qu'il existe d\u00e9j\u00e0 une classe de ce nom.

duplicate case label
Vous avez utilis\u00e9 le m\u00eame cas deux fois \u00e0 l'int\u00e9rieur
d'une m\u00eame instruction "switch".  Chaque cas doit \u00eatre
unique.

duplicate default label
Vous avez utilis\u00e9 le mot-cl\u00e9 "default" deux fois \u00e0
l'int\u00e9rieur d'une m\u00eame instruction "switch".
Il ne peut y avoir qu'un cas fourre-tout.

'else' without 'if'
Le mot-cl\u00e9 'else' ne peut appara\u00eetre que dans une
instruction 'if', comme ceci :
   if (condition)
      instruction;
   else
      instruction;
Avez-vous oubli\u00e9 les accolades ?
Si l'une ou l'autre instruction du if-else est
compos\u00e9e, la syntaxe est :
   if (condition)
   {
      ...
      ...
   }
   else
   {
      ...
   }

empty character literal
Vous avez d\u00e9clar\u00e9 une constante caract\u00e8re vide.
Vous ne pouvez pas utiliser ''.  Une constante
caract\u00e8re doit compter un et un seul caract\u00e8re,
comme par exemple 'a'.  Les caract\u00e8res non-imprimables
sont repr\u00e9sent\u00e9s par un contre-oblique suivi d'un
autre caract\u00e8re, comme par exemple '\n' ou '\t'.

* has already been caught
Cette instruction 'catch' est inutile.  Elle ne
pourra jamais s'ex\u00e9cuter, car les exceptions
qu'elle attrape sont d\u00e9j\u00e0 trait\u00e9es par une
instruction 'catch' pr\u00e9c\u00e9dente.

* is never thrown in body of corresponding try statement
Vous avez d\u00e9clar\u00e9 vouloir attraper une exception ici.
Mais il est certain que cette exception ne sera jamais
lev\u00e9e !  Aucune des instructions du bloc "try" ne peut
lever cette exception.

'finally' without 'try'
Le mot-cl\u00e9 "finally" ne peut appara\u00eetre qu'apr\u00e8s
un bloc "try".  La syntaxe est :
   try
   {
      ...
   }
   catch {...}
   finally
   {
      ...
   }
Un bloc "catch" peut optionnellement s'ins\u00e9rer entre
les blocs "try" et "finally".

floating point number too large
Le syst\u00e8me est incapable de traiter un nombre r\u00e9el
aussi grand.

floating point number too small
Le syst\u00e8me est incapable de traiter un nombre r\u00e9el
aussi petit.

inner classes cannot have static declarations
Une classe imbriqu\u00e9e ne peut d\u00e9clarer de
types statiques.  Si vous avez besoin d'un
type statique ici, d\u00e9clarez-le dans la classe englobante.

illegal character:*
Il y a un caract\u00e8re ill\u00e9gal dans le fichier source.
Ce caract\u00e8re pourrait fort bien \u00eatre invisible.
Si vous ne pouvez le trouver et le supprimer,
supprimez la ligne enti\u00e8re et r\u00e9-\u00e9crivez la.

illegal combination of modifiers: *
Vous avez tent\u00e9 de combiner deux qualificatifs Java
de fa\u00e7on ill\u00e9gale.  Ils sont probablement contradictoires.
Par exemple, une m\u00e9thode ne peut \u00eatre \u00e0 la fois
"abstract" et "native", "final", "private"
ou "synchronized".

illegal escape character
Les caract\u00e8res sp\u00e9ciaux s'\u00e9crivent \u00e0 l'aide d'un
contre-oblique et d'un second caract\u00e8re, comme par
exemple '\n'.  Les caract\u00e8res sp\u00e9ciaux reconnus sont :
\b, \f, \n, \r, \t, \\, \', \"
ainsi que les nombres octaux (e.g. \0 \u00e0 \377).
Les caract\u00e8res Unicode (\u0000 \u00e0 \uFFFF) ne peuvent
appara\u00eetre que dans des cha\u00eenes.

illegal forward reference
Aucune aide disponible

illegal initializer for *
Aucune aide disponible

illegal line end in character literal
Vous avez un retour \u00e0 la ligne alors qu'un caract\u00e8re
\u00e9tait attendu.  Pour inclure un retour \u00e0 la ligne
("newline") dans une cha\u00eene, utilisez '\n'.

illegal qualifier; {0} is not an inner class
Le modificateur utilis\u00e9 n'est applicable qu'\u00e0 une
classe imbriqu\u00e9e.

illegal start of expression
Aucune aide disponible

illegal start of type
L\u00e0 o\u00f9 un nom de type \u00e9tait attendu, quelque chose
d'autre (probablement un mot-cl\u00e9) a \u00e9t\u00e9 rencontr\u00e9.
Assurez-vous que la d\u00e9finition de type soit correcte.

illegal unicode escape
Aucune aide disponible

improperly formed type, some parameters are missing
Aucune aide disponible

incomparable types: *
Aucune aide disponible

integer number too large: *
Vous avez sp\u00e9cifi\u00e9 un nombre trop grand pour le type
entier attendu.  Vous devriez utiliser un type plus
grand (par exemple "long" au lieu de "int").

internal error; cannot instantiate *
Une erreur interne est survenue pendant
l'instanciation de la classe indiqu\u00e9e.
(Erreur g\u00e9n\u00e9rique)

* but with different return type
Vous tentez de combiner deux m\u00e9thodes qui ont la m\u00eame
signature \u00e0 l'exception du type retourn\u00e9.  Ceci se
produit probablement parce que votre classe impl\u00e9mente
deux interfaces, chacune contribuant une des deux
m\u00e9thodes sus-mentionn\u00e9es.  La seule solution consiste
\u00e0 changer au moins une des deux interfaces en question.

interface expected here
Le nom apparaissant apr\u00e8s le mot-cl\u00e9 "extends" ne d\u00e9signe
pas une interface.  Une interface ne peut sous-classer
qu'une autre interface.

interface methods cannot have body
Les m\u00e9thodes d'interfaces ne peuvent \u00eatre que
d\u00e9clar\u00e9es - il ne peut y avoir de corps.
Par cons\u00e9quent, la signature de m\u00e9thode ne peut
\u00eatre suivie que d'un point-virgule.

hexadecimal numbers must contain at least one hexadecimal digit
Vous avez sp\u00e9cifi\u00e9 un nombre hexad\u00e9cimal (en le pr\u00e9fa\u00e7ant
de "0X" ou "0x").  Il doit y avoir au moins un chiffre
hexad\u00e9cimal apr\u00e8s le pr\u00e9fixe (e.g. "0X" n'est pas l\u00e9gal).

invalid method declaration; return type required
Une d\u00e9claration de m\u00e9thode doit sp\u00e9cifier le type retourn\u00e9.
Par exemple, si votre m\u00e9thode retourne un String :
   public String maM\u00e9thode();
Si vous ne voulez pas que la m\u00e9thode retourne de valeur,
utilisez le mot-cl\u00e9 "void" :
   public void maM\u00e9thode();

* already in use
Il y a d\u00e9j\u00e0 une variable (ou un param\u00e8tre)
de ce nom dans la m\u00e9thode.  Utilisez un nom
diff\u00e9rent.  Ou supprimez le nom de type qui
la pr\u00e9c\u00e8de si vous voulez r\u00e9-utiliser la
variable.

* is accessed from within inner class; needs to be declared final
Les variables locales ne sont normalement pas
accessibles aux classes imbriqu\u00e9es.  Vous devrez
soit supprimer les r\u00e9f\u00e9rences apparaissant dans la
classe imbriqu\u00e9e, soit d\u00e9clarer la variable "final"
(ce qui la rendra accessible car constante).

malformed floating point literal
Vous avez commis une erreur de syntaxe en tentant
d'\u00e9crire un nombre r\u00e9el.  Quelques exemples corrects :
18.   18.1   18.e12   1.8f   .18   .2E2d   18e81   18d

missing method body, or declare abstract
Les m\u00e9thodes doivent soit comprendre un corps, soit
\u00eatre d\u00e9clar\u00e9es abstraites.  Le corps est un bloc
d'instructions encadr\u00e9 d'accolades {} qui suit
la signature.  Exemples :
   public abstract int getAnswer();
   public int getAnswer() {};

missing return statement
Une valeur est attendue de cette m\u00e9thode.  Or, il n'y a
aucune instruction "return" dans son corps.
Vous devez soit changer le type retourn\u00e9 par la m\u00e9thode
en "void", soit ajouter l'instruction "return" manquante.

missing return value
L'instruction "return" n'a pas d'argument, alors qu'on
en attendait un.  Vous devez soit changer le type retourn\u00e9
par la m\u00e9thode en "void", soit ajouter l'argument manquant
\u00e0 l'instruction "return".

name clash: *
Vous avez d\u00e9fini deux m\u00e9thodes portant le m\u00eame nom.
Ceci n'est possible que si l'une remplace l'autre (ce
qui n'est pas le cas ici).  Changez l'un des noms.

* is reserved for internal use
Le terme indiqu\u00e9 est r\u00e9serv\u00e9 \u00e0 des fins internes.
Vous devrez changer le nom de votre variable ou classe.

native methods cannot have a body
Vous avez d\u00e9clar\u00e9 une m\u00e9thode intrins\u00e8que (mot-cl\u00e9
"native") et lui avez donn\u00e9 un corps.  Or, les m\u00e9thodes
intrins\u00e8ques n'ont qu'une signature suivie d'un
point-virgule.  Supprimez soit la mot-cl\u00e9 "native",
soit le corps de la m\u00e9thode.

no enclosing instance of type {0} is in scope
Aucune aide disponible

no interface expected here
Vous faites une r\u00e9f\u00e9rence inattendue \u00e0 une interface
(possiblement avec la d\u00e9claration "extends" d'une classe).
Une classe ne peut sous-classer qu'une classe, pas une
interface.  Si vous d\u00e9sirez impl\u00e9menter cette interface,
utilisez plut\u00f4t le mot-cl\u00e9 "implements".

{0} has no match in entry in {1}; required {2}
Aucune aide disponible

* is not defined in a public class or interface; cannot be accessed from outside package
Aucune aide disponible

* cannot be accessed from outside package
La classe que vous cherchez \u00e0 utiliser ici n'est pas
publique (le mot-cl\u00e9 "public" ne pr\u00e9c\u00e8de pas le mot-cl\u00e9
"class").
Une classe non-publique ne peut \u00eatre utilis\u00e9e que par
les classes qui partagent son paquetage.  Si n\u00e9cessaire,
changez sa d\u00e9finition afin de la rendre publique.

not a loop label: *
Les \u00e9tiquettes utilis\u00e9es comme argument d'une
instruction "continue" doivent identifier une
instruction de boucle ("while", "do" ou "for").
L'\u00e9tiquette sp\u00e9cifi\u00e9e ici n'identifie pas une boucle.

not a statement
La ligne de code en question n'est pas
une instruction compl\u00e8te.

not an enclosing class:*
Vous avez tent\u00e9 d'acc\u00e9der \u00e0 l'objet courant ('this') d'une
classe ext\u00e9rieure \u00e0 la v\u00f4tre.  Ceci n'est possible que si
la classe ext\u00e9rieure englobe la v\u00f4tre.

* cannot be applied to *
L'op\u00e9rateur que vous utilisez ici n'est pas applicable
\u00e0 ce type de valeur.  Vous utilisez soit le mauvais type
de valeur, soit le mauvais op\u00e9rateur.

* clashes with class of same name
Assurez-vous que la classe et le paquetage
portent des noms diff\u00e9rents.
Par convention, les noms de classes d\u00e9butent
par une majuscule, les noms de paquetages
par une minuscule.

possible fall-through into case
Il se pourrait que l'ex\u00e9cution d'une clause "case"
d'une instruction "switch" se poursuive \u00e0 la clause
suivante.  Si ce n'est pas ce que vous d\u00e9sirez,
concluez la clause fautive par une instruction "break"
ou l'\u00e9quivalent.

error reading *
Une erreur est survenue lors de la lecture du fichier indiqu\u00e9.
Il y a probablement un probl\u00e8me avec le syst\u00e8me de fichiers
(ou avec le r\u00e9seau si le fichier en question est distant).

recursive constructor invocation
Votre code fait en sorte que le constructeur
s'invoque lui-m\u00eame.  Ce n'est pas permis car
car cela entra\u00eenerait presque certainement
une boucle infinie.

* is ambiguous, both *
L'identificateur mentionn\u00e9 est ambigu car il y a plus d'une
classe ou interface de ce nom parmi les paquetages que vous
avez import\u00e9s.
Vous devez fournir le chemin d'acc\u00e8s de la classe lors de
son invocation (e.g. java.util.List) ou de son importation
(e.g. import java.util.List).

repeated interface
Vous avez mentionn\u00e9 une interface plus d'une
fois dans la d\u00e9claration "implements".
Une fois suffit !

repeated modifier
Vous avez mentionn\u00e9 un modificateur (e.g.
final, static, public, private, volatile) plus
d'une fois dans la d\u00e9claration.  Une fois suffit !

{0} has {1} access in {2}
Aucune aide disponible

return outside method
Vous ne pouvez utiliser l'instruction 'return'
que dans une m\u00e9thode - pas dans un bloc
d'initialisation ou tout autre segment de code.

signature does not match {0}; incompatible interfaces
Parce que les signatures sont diff\u00e9rentes, ces
interfaces sont mutuellement incompatibles.

signature does not match {0}; incompatible supertype
Aucune aide disponible

* should be declared abstract; it does not define *
Cette classe descend d'une classe abstraite ou h\u00e9rite
d'une interface abstraite.  Les classes et interfaces
abstraites d\u00e9finissent des m\u00e9thodes sans en fournir
l'impl\u00e9mentation.  Cette classe ne fournit pas les
impl\u00e9mentations manquantes, ce qui fait qu'elle est
encore abstraite.
Vous devez soit d\u00e9clarer la classe abstraite :
   public abstract class ...
soit fournir l'impl\u00e9mentation manquante mentionn\u00e9e
dans le message d'erreur.

* is not abstract and does not override abstract method *
Votre classe, qui n'est pas abstraite,
d\u00e9clare une m\u00e9thode qui l'est.

error writing source; cannot overwrite input file *
Aucune aide disponible

'try' without 'catch' or 'finally'
Si vous utilisez un bloc "try", il doit \u00eatre imm\u00e9diatement
suivi soit par un bloc "catch", soit par un bloc "finally"
(ou les deux).  La syntaxe est :
   try
   {
      ...
   }
   catch(Exception e)
   {
      ...
   }
   finally
   {
      ...
   }

* does not take parameters
Le type utilis\u00e9 n'est pas param\u00e9tris\u00e9.  Par
cons\u00e9quent, vous ne pouvez sp\u00e9cifier de param\u00e8tre.

wrong number of type arguments; required *
Aucune aide disponible

type variable {0} occurs more than once in result type of {1}; cannot be left uninstantiated
Aucune aide disponible

type variable {0} occurs more than once in type of {1}; cannot be left uninstantiated
Aucune aide disponible

unclosed character literal
Il semble que vous ayez \u00e9crit une constante caract\u00e8re sans
inclure l'apostrophe fermante : 'a au lieu de 'a'.

unclosed comment
Un commentaire qui d\u00e9bute par /* ou /** doit
\u00e9ventuellement \u00eatre ferm\u00e9 par */.

unclosed string literal
Il semble que vous ayez \u00e9crit une cha\u00eene de caract\u00e8res
sans inclure le guillemet anglais fermant : \u00ab"une cha\u00eene\u00bb
au lieu de \u00ab"une cha\u00eene"\u00bb.  La cha\u00eene doit \u00eatre \u00e9crite
sur une seule ligne.

undefined label: *
L'\u00e9tiquette que vous tentez d'utiliser ici est
introuvable.  Soit qu'elle n'existe pas, soit
qu'elle ne soit pas dans le contexte.
Assurez-vous qu'il n'y ait pas de coquille
(les \u00e9tiquettes sont sensibles \u00e0 la casse).
Le second cas peut se produire lorsque l'\u00e9tiquette
est dans un bloc (d\u00e9limit\u00e9 par les accolades) -
r\u00e8gle g\u00e9n\u00e9rale, une \u00e9tiquette n'existe que dans le
contexte du bloc qui la d\u00e9finit.

unreachable statement
Cette instruction ne sera jamais ex\u00e9cut\u00e9e.
Si vous examinez le code attentivement, vous
remarquerez que l'instruction ne peut \u00eatre
atteinte en aucun cas.  Supprimez-la ou
corrigez votre logique.

initializer must be able to complete normally
Vous ne pouvez pas lancer d'exceptions ni abr\u00e9ger
de toute autre mani\u00e8re un bloc d'initialisation,
statique ou non.

* must be caught or declared to be thrown
Votre code invoque une m\u00e9thode qui pourrait lancer
une exception.  Vous devez soit attraper l'exception,
soit d\u00e9clarer que votre m\u00e9thode la laisse s'\u00e9chapper.
Pour attraper l'exception, utilisez un bloc "try" :
   try
   {
      ...
   }
   catch(Exception e)
   {
      ...
   }
Pour la laisser s'\u00e9chapper, ajoutez :
   throws <ExceptionName>
\u00e0 la signature de votre m\u00e9thode.

'void' type not allowed here
Le type "void" ne peut \u00eatre utilis\u00e9 dans ce contexte.
Il ne sert qu'\u00e0 d\u00e9clarer qu'une m\u00e9thode ne retourne pas
de r\u00e9sultat; il ne peut y avoir de variables de ce type.

* not allowed here
Vous avez utilis\u00e9 un modificateur d'acc\u00e8s (tel que
"private", "protected", etc.) qui n'est pas permis
en cet endroit.

* might already have been assigned to
Une variable finale ne peut accepter une valeur qu'une seule
fois.  La variable en question est finale et le compilateur
croit qu'il est possible que les deux instructions soient
ex\u00e9cut\u00e9es.

* might not have been initialized
Vous utilisez une variable locale sans avoir la
certitude qu'elle ait \u00e9t\u00e9 initialis\u00e9e.  Dans le
doute, initialisez-la lors de sa d\u00e9claration

variable {0} might be assigned in loop
La variable finale en question \u00e9tait certainement sans
valeur avant la boucle, et pourrait s'en voir assigner
une dans la boucle, peut-\u00eatre plus d'une fois - ce
qui n'est pas acceptable.

error while writing *
Une erreur est survenue lors de l'\u00e9criture du fichier indiqu\u00e9.
Il y a probablement un probl\u00e8me avec le syst\u00e8me de fichiers
(ou avec le r\u00e9seau si le fichier en question est distant).
Le fichier est-il prot\u00e9g\u00e9 contre l'\u00e9criture ?  Le disque
est-il satur\u00e9 ?

* is public, should be declared in a file named *
Chaque classe publique doit avoir son texte source dans un
fichier du m\u00eame nom portant l'extension ".java".
Par exemple, la "public class Foo" doit avoir son
texte source dans le fichier "Foo.java".

cannot read: *
Aucune aide disponible

* uses or overrides a deprecated API.
Vous utilisez ou remplacez une m\u00e9thode qui n'est plus
recommand\u00e9e.  Il existe probablement une autre m\u00e9thode
(ou classe) qui fournisse cette fonctionnalit\u00e9.
Consultez la documentation pour plus de d\u00e9tails.

* has been deprecated
Vous utilisez une m\u00e9thode qui n'est plus recommand\u00e9e.
Il existe probablement une autre m\u00e9thode (ou classe)
qui fournisse cette fonctionnalit\u00e9.  Consultez la
documentation pour plus de d\u00e9tails.

';' expected
Il manque un point-virgule \u00e0 la fin de la ligne de code.
La ligne fautive peut \u00eatre celle indiqu\u00e9e par l'\u00e9diteur
ou la pr\u00e9c\u00e9dente.

'case', 'default' or '}' expected
Le corps de votre expression "switch" semble erron\u00e9.
La syntaxe de l'instruction "switch" est :
   switch ( Expression )
   {
   case ConstantExpression :
      ...
   default :
      ...
   }

'class' or 'interface' expected
Les mots-cl\u00e9s "class" ou "interface" sont attendus
au d\u00e9but du fichier source.  Ni l'un ni l'autre
n'appara\u00eet, ou il y a autre chose qui les pr\u00e9c\u00e8de.

'.class' expected
Aucune aide disponible

'(' or '[' expected
Chaque parenth\u00e8se et crochet ouvrant doit trouver son
correspondant fermant; \u00e7a ne semble pas \u00eatre le cas ici.
Avez-vous des termes crois\u00e9s du genre "w[x(y]z)" ?

* expected
Le symbole sus-mentionn\u00e9 \u00e9tait attendu \u00e0 cet
endroit mais un autre symbole a \u00e9t\u00e9 rencontr\u00e9.
Essayez de comprendre pourquoi Java s'attendait
\u00e0 ce symbole plut\u00f4t qu'\u00e0 celui que vous avez
utilis\u00e9.

orphaned *
Aucune aide disponible

cannot access *
Le fichier classe sp\u00e9cifi\u00e9 ne peut \u00eatre consult\u00e9
pour la raison sp\u00e9cifi\u00e9e.  Probablement \u00e0 la suite
d'un probl\u00e8me avec votre syst\u00e8me de fichiers.

type parameter {0} is not within its bound *
Aucune aide disponible

type parameters of {0} cannot be determined
Aucune aide disponible

incompatible types*
Une expression d'un certain type est requise ici.
Vous avez utilis\u00e9 une expression d'un type diff\u00e9rent
qui n'est pas compatible (e.g. une expression
"String" alors qu'un "int" est requis).

inconvertible types*
Le type que vous avez utilis\u00e9 ici ne peut pas \u00eatre
automatiquement converti au type requis.

possible loss of precision
La conversion indiqu\u00e9e pourrait causer une perte
de pr\u00e9cision num\u00e9rique.

unexpected type
Une expression d'un certain type est requise ici.
Vous avez utilis\u00e9 une expression d'un type diff\u00e9rent
qui n'est pas compatible (e.g. une expression
"String" alors qu'un "int" est requis).

abstract {0} {1} cannot be accessed directly
Une m\u00e9thode abstraite ne peut pas \u00eatre invoqu\u00e9e.
Vous ne pouvez invoquer que ses descendants concrets
(i.e. une sous-classe impl\u00e9mentant la m\u00e9thode).

*An explicit 'this' qualifier must be used to select the desired instance.
L'instance \u00e9tant ambigu\u00eb, le compilateur recommande de
sp\u00e9cifier 'this', c'est-\u00e0-dire l'instance courante.

*cannot be referenced from a static context
Vous tentez d'acc\u00e9der \u00e0 un champ ou m\u00e9thode d'instance
\u00e0 partir d'une m\u00e9thode statique (m\u00e9thode de classe).
Ceci n'est pas permis.  Les m\u00e9thodes statiques ne
peuvent acc\u00e9der qu'aux autres champs et m\u00e9thodes
statiques de leur classe \u00e0 moins d'utiliser une
instance explicite de la classe (cr\u00e9\u00e9e par la m\u00e9thode
statique).

cannot find symbol*
Aucune aide disponible

cannot resolve symbol*
Aucune aide disponible

{0}; {1} and {2} are static
Aucune aide disponible

{0}; overridden method is {1}
Aucune aide disponible

* attempting to assign weaker access privileges; was *
Vous remplacez une m\u00e9thode tout en changeant le modificateur
d'acc\u00e8s (private, protected, public).  Vous ne pouvez
qu'\u00e9largir l'acc\u00e8s (e.g. de priv\u00e9 \u00e0 public); vous ne pouvez
pas le restreindre (e.g. de public \u00e0 priv\u00e9).

* overridden method does not throw *
Vous remplacez une m\u00e9thode et levez une nouvelle
exception.  Une m\u00e9thode rempla\u00e7ante ne peut pas
introduire de nouvelles exceptions; elle peut en
lever moins, mais pas plus.

* attempting to use incompatible return type
Aucune aide disponible

* is already defined in this compilation unit
Vous avez utilis\u00e9 ce nom deux fois ici.
Choisissez un nom diff\u00e9rent pour cet identificateur.

{0} is already defined in a single-type import
Aucune aide disponible

* conflicts with a compiler-synthesized symbol in *
Aucune aide disponible

reached end of file while parsing
Cela signifie que vous avez ouvert un bloc d'instruction avec '{' mais que
vous ne l'avez pas ferm\u00e9 avec '}'. Ou bien vous avez utilis\u00e9 '{' ou '}'
\u00e0 un endroit o\u00f9 vous n'auriez pas eu besoin.
