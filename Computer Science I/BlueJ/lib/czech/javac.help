kotrola-kodovani
P\u0159\u00edli\u0161 \u017elu\u0165ou\u010dk\u00fd k\u016f\u0148 \u00fap\u011bl \u010f\u00e1belsk\u00e9 \u00f3dy.
P\u0158\u00cdLI\u0160 \u017dLU\u0164OU\u010cK\u00dd K\u016e\u0147 \u00daP\u011aL \u010e\u00c1BELSK\u00c9 \u00d3DY.

as of release 1.4, 'assert' is a keyword, and may not be used as an identifier
od verze 1.4 je "assert" kl\u00ed\u010dov\u00e9 slovo a nem\u016f\u017ee b\u00fdt pou\u017eito jako identifik\u00e1tor
|
Slovo "assert" je nyn\u00ed sou\u010d\u00e1st\u00ed jazyka Java nesouc\u00ed speci\u00e1ln\u00ed v\u00fdznam
(je to kl\u00ed\u010dov\u00e9 slovo). Nelze je proto pou\u017e\u00edt jako identifik\u00e1tor
metody \u010di prom\u011bnn\u00e9. Zvolte pros\u00edm jin\u00fd identifik\u00e1tor (n\u00e1zev).

qualified new of static class
kvalifikovan\u00e9 new p\u0159i konstrukci instance statick\u00e9 t\u0159\u00eddy
|
Kvalifikovan\u00e9 oper\u00e1tory new se pou\u017e\u00edvaj\u00ed
pouze p\u0159i vytv\u00e1\u0159en\u00ed instanc\u00ed vnit\u0159n\u00edch t\u0159\u00edd,
tj. t\u0159\u00edd, kter\u00e9 jsou deklarovan\u00e9 uvnit\u0159 jin\u00e9 t\u0159\u00eddy,
av\u0161ak bez modifik\u00e1toru static.

* is abstract; cannot be instantiated
... je abstraktn\u00ed t\u0159\u00edda - nelze vytvo\u0159it jej\u00ed instanci
|
Tato t\u0159\u00edda je deklarov\u00e1na jako abstraktn\u00ed
(pomoc\u00ed kl\u00ed\u010dov\u00e9ho slova "abstract").
Abstraktn\u00ed t\u0159\u00eddy nemohou vytv\u00e1\u0159et instance -
to mohou a\u017e jejich konkr\u00e9tn\u00ed dce\u0159in\u00e9 t\u0159\u00eddy.
Konkr\u00e9tn\u00ed t\u0159\u00eddou je t\u0159\u00edda, kter\u00e1 m\u00e1 implementov\u00e1ny
v\u0161echny metody implementovan\u00fdch rozhran\u00ed
a v\u0161echny abstraktn\u00ed metody rodi\u010dovsk\u00fdch t\u0159\u00edd.
Tuto implementaci v\u0161ak m\u016f\u017ee i zd\u011bdit.

abstract methods cannot have a body
Abstraktn\u00ed metody nesm\u00ed m\u00edt t\u011blo.
|
Pomoc\u00ed kl\u00ed\u010dov\u00e9ho slova "abstract" jste ozna\u010dili
metodu jako abstraktn\u00ed a p\u0159itom jste definovali
jej\u00ed t\u011blo (k\u00f3d ve slo\u017een\u00fdch z\u00e1vork\u00e1ch).
Deklarace abstraktn\u00edch metod sm\u011bj\u00ed obsahovat
pouze hlavi\u010dku ukon\u010denou st\u0159edn\u00edkem.
Bu\u010fto odstra\u0148te kl\u00ed\u010dov\u00e9 slovo "abstract", nebo
sma\u017ete t\u011blo metody v\u010detn\u011b slo\u017een\u00fdch z\u00e1vorek
a ukon\u010dete hlavi\u010dku metody st\u0159edn\u00edkem.

* is already defined in *
... je ji\u017e definov\u00e1na v ...
|
Uvnit\u0159 t\u00e9to metody je ji\u017e definov\u00e1na
prom\u011bnn\u00e1/odkaz nebo parametr se stejn\u00fdm jm\u00e9nem.
P\u0159ejete-li si vytvo\u0159it novou prom\u011bnnou/odkaz pou\u017eijte jin\u00e9 jm\u00e9no.
Chcete-li naopak pou\u017e\u00edt st\u00e1vaj\u00edc\u00ed prom\u011bnnou nebo parametr
odstra\u0148te deklaraci typu.

anonymous class implements interface; cannot have arguments
anonymn\u00ed t\u0159\u00edda inplementuj\u00edc\u00ed rozhran\u00ed nesm\u00ed m\u00edt parametry
|
P\u0159esn\u011bji \u0159e\u010deno v definici anonymn\u00ed t\u0159\u00eddy mus\u00edte v hlavi\u010dce
za deklarac\u00ed implementovan\u00e9ho rozhran\u00ed uv\u00e9st pouze
pr\u00e1zdn\u00e9 kulat\u00e9 z\u00e1vorky ().

anonymous class implements interface; cannot have qualifier for new
anonymn\u00ed t\u0159\u00edda inplementuj\u00edc\u00ed rozhran\u00ed nesm\u00ed m\u00edt kvalifikovan\u00e9 new
|
P\u0159i vytv\u00e1\u0159en\u00ed instance anonymn\u00ed t\u0159\u00eddy nesm\u00ed b\u00fdt pou\u017eito
kvalifikovan\u00e9 new, tj. nesm\u00edte pou\u017e\u00edt tvar prom\u011bnn\u00e1.new.

array required, but *
Je vy\u017eadov\u00e1no pole, ale uveden\u00fd typ je ...
|
Pou\u017e\u00edv\u00e1te syntaxi p\u0159\u00edstupu k element\u016fm pole pomoc\u00ed
hranat\u00fdch z\u00e1vorek. Prom\u011bnn\u00e1 ale nen\u00ed typu pole.

break outside switch or loop
P\u0159\u00edkaz "break" je pou\u017eit mimo "switch" nebo cyklus
|
P\u0159\u00edkaz "break" ukon\u010d\u00ed vykon\u00e1v\u00e1n\u00ed bloku "switch"
nebo cyklu "for", "while" \u010di "do".
P\u0159\u00edkaz "break" bez n\u00e1v\u011b\u0161t\u00ed nesm\u00ed b\u00fdt pou\u017eit mimo tyto bloky.
Chcete-li t\u00edmto p\u0159\u00edkazem opustit jin\u00fd typ bloku,
mus\u00edte vyu\u017e\u00edt verze p\u0159\u00edkazu s n\u00e1v\u011b\u0161t\u00edm.

* must be first statement in constructor
... mus\u00ed b\u00fdt uveden jako prvn\u00ed p\u0159\u00edkaz v konstruktoru
|
Vol\u00e1-li konstruktor jin\u00fd konstruktor prost\u0159ednictv\u00edm
this nebo super, mus\u00ed b\u00fdt toto vol\u00e1n\u00ed \u00fapln\u011b prvn\u00edm
p\u0159\u00edkazem v t\u011ble konstruktoru. P\u0159ed t\u00edmto p\u0159\u00edkazem
nesm\u00ed b\u00fdt nic: \u017e\u00e1dn\u00fd p\u0159\u00edkaz ani za\u010d\u00e1tek bloku
nebo uvozen\u00ed bloku try ... catch.
Jsou povoleny pouze b\u00edl\u00e9 znaky a koment\u00e1\u0159e.

cannot access *
Nelze p\u0159istupovat k ...
|
Pravd\u011bpodobn\u011b se sna\u017e\u00edte p\u0159istupovat k metod\u011b
\u010di objektu, kter\u00fd nen\u00ed z tohoto m\u00edsta dosa\u017eiteln\u00fd.
Nej\u010dast\u011bj\u0161\u00edm d\u016fvodem je pokus a pou\u017eit\u00ed prom\u011bnn\u00e9
vn\u011b bloku, v n\u011bm\u017e byla definov\u00e1na.
Druhou mo\u017enost\u00ed je pokus o p\u0159\u00edstup k neve\u0159ejn\u00e9mu \u010dlenu
(atributu, metod\u011b, intern\u00edmu typu),
kter\u00fd nen\u00ed z tohoto m\u00edsta programu dostupn\u00fd

cannot assign a value to final variable *
Nelze p\u0159i\u0159adit hodnotu konstant\u011b ...
|
Kl\u00ed\u010dov\u00fdm slovem "final" jsou ozna\u010den\u00e9 konstanty.
Jejich hodnota nesm\u00ed b\u00fdt v programu zm\u011bn\u011bna.
Pot\u0159ebujete-li hodnotu prom\u011bnn\u00e9 m\u011bnit,
odstra\u0148te v jej\u00ed deklaraci modifik\u00e1tor final.

type variables cannot be dereferenced
prom\u011bnn\u00e9 primitivn\u00edch typ\u016f nemohou b\u00fdt dereferencov\u00e1ny
|
Prost\u0159ednictv\u00edm te\u010dkov\u00e9 notace se pokou\u0161\u00edte
p\u0159istoupit ke \u010dlen\u016fm typov\u00e9ho parametru generick\u00e9 t\u0159\u00eddy.

* cannot be dereferenced
... nem\u016f\u017ee b\u00fdt dereferencov\u00e1na
|
Pomoc\u00ed oper\u00e1toru "." se sna\u017e\u00edte p\u0159istoupit k metod\u011b
nebo atributu prom\u011bnn\u00e9, kter\u00e1 nen\u00ed objektov\u00e9ho typu.

cannot inherit from final *
Nelze d\u011bdit/odvozovat od "final" t\u0159\u00eddy ...
|
Rodi\u010dovsk\u00e1 t\u0159\u00edda (tj. t\u0159\u00edda, od kter\u00e9 se d\u011bd\u00ed,
a kter\u00e1 je uveden\u00e1 za kl\u00ed\u010dov\u00fdm slovem "extends")
je deklarov\u00e1na jako "final".
Od takov\u00e9to t\u0159\u00eddy nelze vytv\u00e1\u0159et potomky.

* before supertype constructor has been called
... bylo vol\u00e1no p\u0159ed konstruktorem rodi\u010dovsk\u00e9 t\u0159\u00eddy
|
Konstruktor dce\u0159in\u00e9 t\u0159\u00eddy (podt\u0159\u00eddy), kter\u00fd nep\u0159ed\u00e1v\u00e1 inicializaci
vytv\u00e1\u0159en\u00e9ho objektu jin\u00e9mu konstrutkoru t\u00e9\u017ee t\u0159\u00eddy vol\u00e1n\u00edm this(...),
mus\u00ed za\u010d\u00edt t\u011blo zavol\u00e1n\u00edm konstrukotru rodi\u010dovsk\u00e9 t\u0159\u00eddy.
Nem\u00e1-li rodi\u010dovsk\u00e1 t\u0159\u00edda dostupn\u00fd bezparametrick\u00fd konstruktor
(pak v p\u0159\u00edpad\u011b pot\u0159eby toto vol\u00e1n\u00ed automaticky dopln\u00ed p\u0159ieklada\u010d),
mus\u00edte jako prvn\u00ed p\u0159\u00edkaz t\u011bla konstruktoru pou\u017e\u00edt p\u0159\u00edkaz
    super(...);
(Te\u010dky p\u0159edstavuj\u00ed parametry konstruktoru.)
Stejn\u00fd p\u0159\u00edkaz pou\u017eijte i p\u0159i pot\u0159eb\u011b vol\u00e1n\u00ed jin\u00e9ho
ne\u017e bezparametrick\u00e9ho rodi\u010dovsk\u00e9ho konstruktoru.

cannot return a value from method whose result type is void
Nelze vracet hodnoty z metody ozna\u010den\u00e9 "void"
|
Deklarace n\u00e1vratov\u00e9ho typu "void" znamen\u00e1,
\u017ee metoda nevrac\u00ed \u017e\u00e1dnou hodnotu.
V t\u011ble "void" metody lze pou\u017e\u00edt pouze p\u0159\u00edkaz
return;
tj. bez ud\u00e1n\u00ed n\u00e1vratov\u00e9 hodnoty.

cannot select a static class from a parameterized type
Z parametrizovan\u00e9ho typu nen\u00ed mo\u017en\u00e9 vybrat statickou t\u0159\u00eddu
|
Podrobn\u011bj\u0161\u00ed n\u00e1pov\u011bda nen\u00ed k dispozici.

* cannot be inherited with different arguments:*
... nem\u016f\u017ee b\u00fdt zd\u011bd\u011bno s odli\u0161n\u00fdmi parametry: ...
|
Podrobn\u011bj\u0161\u00ed n\u00e1pov\u011bda nen\u00ed k dispozici.

'catch' without 'try'
Je pou\u017eit blok 'catch' bez p\u0159edchoz\u00edho 'try'
|
"catch" je kl\u00ed\u010dov\u00e9 slovo, kter\u00e9 m\u016f\u017ee b\u00fdt pou\u017eito pouze
po bloku "try". Spr\u00e1vn\u00e9 pou\u017eit\u00ed:
   try {
      p\u0159\u00edkazy ...
   }
   catch(Exception e) {
     p\u0159\u00edkazy ...
   }

* clashes with package of same name
... koliduje se stejn\u011b pojmenovan\u00fdm bal\u00ed\u010dkem
|
Ujist\u011bte se, \u017ee se t\u0159\u00edda jmenuje jinak ne\u017e bal\u00ed\u010dek,
ve kter\u00e9m je t\u0159\u00edda um\u00edst\u011bna. Podle konvence by m\u011bla
jm\u00e9na t\u0159\u00edd za\u010d\u00ednat velk\u00fdmi p\u00edsmeny a jm\u00e9na bal\u00ed\u010dk\u016f
by m\u011bla obsahovat pouze mal\u00e1 p\u00edsmena.

code too large for try statement
K\u00f3d uvnit\u0159 bloku 'try' je p\u0159\u00edli\u0161 dlouh\u00fd
|
Uvnit\u0159 tohoto "try" bloku je p\u0159\u00edli\u0161 mnoho \u0159\u00e1dk\u016f.
Pokuste se p\u0159esunout tento k\u00f3d do nov\u00e9 metody
a zavolejte ji z tohoto bloku.

constant expression required
Je vy\u017eadov\u00e1n konstantn\u00ed v\u00fdraz
|
Na tomto m\u00edst\u011b je vy\u017eadov\u00e1no pou\u017eit\u00ed konstantn\u00edho v\u00fdrazu,
kter\u00fd je mo\u017eno vyhodnotit ji\u017e v dob\u011b p\u0159ekladu.
Jako takov\u00fdto v\u00fdraz je mo\u017eno pou\u017e\u00edt pouze v\u00fdraz obsahuj\u00edc\u00ed
liter\u00e1ly a jin\u00e9 konstantn\u00ed v\u00fdrazy vyhodnotiteln\u00e9 v dob\u011b p\u0159iekladu.

continue outside of loop
P\u0159\u00edkaz 'continue' je pou\u017eit mimo cyklus
|
P\u0159\u00edkaz "continue" je pou\u017e\u00edv\u00e1n k okam\u017eit\u00e9mu
p\u0159echodu do dal\u0161\u00edho opakov\u00e1n\u00ed cyklu. Tento
p\u0159\u00edkaz m\u016f\u017ee b\u00fdt pou\u017eit pouze uvnit\u0159 cyklu
"for", "while" a "do".

cyclic inheritance involving *
Cyklick\u00e1 d\u011bdi\u010dnost v ...
|
Sna\u017e\u00edte se tuto t\u0159\u00eddu odvodit od t\u0159\u00eddy,
kter\u00e1 je sama od t\u00e9to t\u0159\u00eddy odvozena.
Jin\u00fdmi slovy: sna\u017e\u00edte se, aby rodi\u010d byl
potomkem sv\u00e9ho potomka. Mus\u00edte se rozhodnout,
kter\u00e1 t\u0159\u00edda bude rodi\u010d a kter\u00e1 potomek.

* does not exist
... neexistuje
|
Pravd\u011bpodobn\u011b jste zde cht\u011bli pou\u017e\u00edt jm\u00e9no
prom\u011bnn\u00e9 nebo t\u0159\u00eddy, av\u0161ak \u017e\u00e1dn\u00e1 prom\u011bnn\u00e1,
t\u0159\u00edda nebo bal\u00ed\u010dek s takov\u00fdm jm\u00e9nem neexistuje.

duplicate class:*
Duplicitn\u00ed t\u0159\u00edda: ...
|
T\u0159\u00edda se stejn\u00fdm jm\u00e9nem ji\u017e existuje.

duplicate case label
Duplicitn\u00ed n\u00e1v\u011b\u0161t\u00ed 'case'
|
Uvnit\u0159 bloku "switch" jste pou\u017eili dvakr\u00e1t "case xx:"
se stejnou hodnotou. To nen\u00ed p\u0159\u00edpustn\u00e9.

duplicate default label
Duplicitn\u00ed n\u00e1v\u011b\u0161t\u00ed 'default'
|
Uvnit\u0159 bloku "switch" m\u016f\u017ee b\u00fdt n\u00e1v\u011b\u0161t\u00ed "default"
pou\u017eito pouze jednou.

'else' without 'if'
'else' je pou\u017eito bez p\u0159edchoz\u00edho 'if'
|
Kl\u00ed\u010dov\u00e9 slovo "else" m\u016f\u017ee b\u00fdt pou\u017eito pouze
jako sou\u010d\u00e1st p\u0159\u00edkazu "if". P\u0159\u00edklad:
   if (podm\u00ednka)
     p\u0159\u00edkaz-vykonan\u00fd-p\u0159\u00ed-spln\u011bn\u00ed-podm\u00ednky
   else
     p\u0159\u00edkaz-vykonan\u00fd-p\u0159\u00ed-NEspln\u011bn\u00ed-podm\u00ednky
Mo\u017en\u00e1, \u017ee jste neuvedli spr\u00e1vn\u00fd po\u010det slo\u017een\u00fdch z\u00e1vorek.
\u010castou p\u0159\u00ed\u010dinou t\u00e9to chyby je, \u017ee chcete ve v\u011btvi if vykonat
n\u011bkolik p\u0159\u00edkaz\u016f a zapomenete je uzav\u0159\u00edt do slo\u017een\u00fdch z\u00e1vorek.
   if (podm\u00ednka)
   {
      p\u0159\u00edkaz1;
      p\u0159\u00edkaz2;
   }
   else
   {
      p\u0159\u00edkaz3;
   }

empty character literal
Pr\u00e1zdn\u00fd znakov\u00fd liter\u00e1l
|
Znakov\u00e9 liter\u00e1ly se p\u00ed\u0161\u00ed ve tvaru 'a'. Mezi apostrofy
je v\u017edy pr\u00e1v\u011b jeden znak. V\u00fdjimkou jsou speci\u00e1ln\u00ed
znaky psan\u00e9 pomoc\u00ed zp\u011btn\u00e9ho lom\u00edtka - nap\u0159.
'\n' nov\u00fd \u0159\u00e1dek, '\t' tabul\u00e1tor atd.
Pr\u00e1zdn\u00fd znakov\u00fd lter\u00e1l je nep\u0159\u00edpustn\u00fd.

* has already been caught
... v\u00fdjimka ji\u017e byla zachycena
|
Tento "catch" je zbyte\u010dn\u00fd,
proto\u017ee se do tohoto m\u00edsta program nikdy nedostane.
V\u00fdjimky uveden\u00e9ho typu budou zachyceny
ji\u017e v p\u0159edchoz\u00edch bloc\u00edch "catch".

* is never thrown in body of corresponding try statement
... v\u00fdjimka nem\u016f\u017ee b\u00fdt vyvol\u00e1na v p\u0159\u00edslu\u0161n\u00e9m "try" bloku
|
Zachyt\u00e1v\u00e1te v\u00fdjimku, kterou v p\u0159\u00edslu\u0161n\u00e9m bloku try
nikdo negeneruje.

'finally' without 'try'
Pou\u017eito 'finally' bez p\u0159edchoz\u00edho 'try'
|
"finally" je kl\u00ed\u010dov\u00e9 slovo, kter\u00e9 m\u016f\u017ee b\u00fdt pou\u017eito pouze
po "try" bloku. Pou\u017eit\u00ed:
   try {
      p\u0159\u00edkazy;
   }
   catch(Exception e) {
     p\u0159\u00edkazy;
   }
   finally {
      p\u0159\u00edkazy;
   }

floating point number too large
zadan\u00e9 desetinn\u00e9 \u010d\u00edslo je p\u0159\u00edli\u0161 velik\u00e9
|
Syst\u00e9m neum\u00ed pracovat s tak velk\u00fdmi \u010d\u00edsly
dan\u00e9ho typu.

floating point number too small
zadan\u00e9 desetinn\u00e9 \u010d\u00edslo je p\u0159\u00edli\u0161 mal\u00e9
|
Syst\u00e9m neum\u00ed pracovat s tak mal\u00fdmi \u010d\u00edsly
dan\u00e9ho typu.

inner classes cannot have static declarations
Vnit\u0159n\u00ed t\u0159\u00edda nem\u016f\u017ee m\u00edt statick\u00e9 deklarace
|
Ve vnit\u0159n\u00ed t\u0159\u00edd\u011b nelze deklarovat statick\u00e9 \u010dleny.
Pot\u0159ebujete-li statick\u00fd atribut nebo metodu,
rozmyslete si, zda dan\u00e1 t\u0159\u00edda nem\u016f\u017ee b\u00fdt
deklarov\u00e1na pouze jako vno\u0159en\u00e1 (tj. s modifik\u00e1torem
static), anebo vytvo\u0159te po\u017eadovan\u00fd atribut
\u010di metodu ve vn\u011bj\u0161\u00ed t\u0159\u00edd\u011b.

illegal character:*
Zak\u00e1zan\u00fd znak: ...
|
Na tomto \u0159\u00e1dku je ve zdrojov\u00e9m k\u00f3du zak\u00e1zan\u00fd znak.
Tento znak nemus\u00ed b\u00fdt viditeln\u00fd.
Nem\u016f\u017eete-li jej nal\u00e9zt, sma\u017ete cel\u00fd \u0159\u00e1dek a napi\u0161te jej znovu.

illegal combination of modifiers: *
Zak\u00e1zan\u00e1 kombinace modifik\u00e1tor\u016f: ...
|
Pou\u017eili jste kombinaci modifik\u00e1tor\u016f, kter\u00e9 se navz\u00e1jem vylu\u010duj\u00ed.
P\u0159\u00edkladem je kombinace modifik\u00e1toru "abstract" s n\u011bkter\u00fdm
z modifik\u00e1tor\u016f "native", "final", "private" nebo "synchronized".

illegal escape character
Neplatn\u00e1 escape sekvence
|
Escape sekvence za\u010d\u00edn\u00e1 zp\u011btn\u00fdm lom\u00edtkem "\"
n\u00e1sledovan\u00fdm p\u00edsmenem. Povolen\u00e9 znaky jsou:
\n, \t, \b, \r, \f, \\, \', \" anebo
\uHHHH kde H je hexadecim\u00e1ln\u00ed \u010d\u00edslice.
Pravd\u011bpodobn\u011b jste cht\u011bli zadat znak \
a nezapsali jste jej jako dvojici \\

illegal forward reference
Nepovolen\u00fd dop\u0159edn\u00fd odkaz
|
Pou\u017e\u00edv\u00e1te ozna\u010denou entitu d\u0159\u00edve,
ne\u017e jste ji deklarovali.

illegal initializer for *
Nepovolen\u00fd incializ\u00e1tor pro ...
|
Podrobn\u011bj\u0161\u00ed n\u00e1pov\u011bda nen\u00ed k dispozici.

illegal line end in character literal
Neplatn\u00fd konec \u0159\u00e1dku uvnit\u0159 znakov\u00e9ho liter\u00e1lu
|
\u0158\u00e1dek v\u00e1m kon\u010d\u00ed uprost\u0159ed znakov\u00e9ho liter\u00e1lu.
Znak pro nov\u00fd \u0159\u00e1dek je '\n'.

illegal qualifier; {0} is not an inner class
nepovolen\u00fd modifik\u00e1tor; ... nen\u00ed vnit\u0159n\u00ed t\u0159\u00edda
|
Podrobn\u011bj\u0161\u00ed n\u00e1pov\u011bda nen\u00ed k dispozici.

illegal start of expression
\u0160patn\u00fd za\u010d\u00e1tek v\u00fdrazu
|
Na t\u00e9to pozici, je o\u010dek\u00e1v\u00e1n po\u010d\u00e1tek v\u00fdrazu,
ale je zde n\u011bco jin\u00e9ho. Pravd\u011bpodobn\u011b v\u00e1m
v p\u0159edchoz\u00edm k\u00f3du n\u011bco p\u0159eb\u00fdv\u00e1 nebo chyb\u00ed,
nej\u010dast\u011bji jsou to z\u00e1vorky.
Zkontrolujte tak\u00e9 spr\u00e1vnost definice typu.

illegal start of type
Zak\u00e1zan\u00fd za\u010d\u00e1tek typu
|
Na t\u00e9to pozici, je o\u010dek\u00e1v\u00e1no jm\u00e9no typu,
ale je zde n\u011bco jin\u00e9ho Pravd\u011bpodobn\u011b v\u00e1m
v p\u0159edchoz\u00edm k\u00f3du n\u011bco p\u0159eb\u00fdv\u00e1 nebo chyb\u00ed.
Zkontrolujte spr\u00e1vnost definice typu.

illegal unicode escape
Zak\u00e1zan\u00fd z\u00e1pis znaku sady unicode
|
Znaky definovan\u00e9 k\u00f3dem je mo\u017eno zad\u00e1vat sekvenc\u00ed
\uXXXX
kde X zastupuje hexadecim\u00e1ln\u00ed \u010d\u00edslici. Tyto \u010d\u00edslice
mus\u00ed b\u00fdt v\u017edy pr\u00e1v\u011b 4.

improperly formed type, some parameters are missing
Nespr\u00e1vn\u011b utvo\u0159en\u00fd typ, n\u011bkter\u00e9 parametry chyb\u011bj\u00ed
|
Podrobn\u011bj\u0161\u00ed n\u00e1pov\u011bda nen\u00ed k dispozici.

incomparable types: *
Tyto typy nelze navz\u00e1jem porovn\u00e1vat: ...
|
Podrobn\u011bj\u0161\u00ed n\u00e1pov\u011bda nen\u00ed k dispozici.

integer number too large: *
Cel\u00e9 \u010d\u00edslo je p\u0159\u00edli\u0161 velk\u00e9: ...
|
Napsali jste \u010d\u00edslo, kter\u00e9 je pro tento typ p\u0159\u00edli\u0161
dlouh\u00e9. Zkuste pou\u017e\u00edt del\u0161\u00ed typ ("int" nebo "long").

internal error; cannot instantiate *
Vnit\u0159n\u00ed chyba; nen\u00ed mo\u017eno vytvo\u0159it instanci ...
|
Podrobn\u011bj\u0161\u00ed n\u00e1pov\u011bda nen\u00ed k dispozici.

* but with different return type
... existuje s jin\u00fdm typem n\u00e1vratov\u00e9 hodnoty
|
Pravd\u011bpodobn\u011b se sna\u017e\u00edte definovat dv\u011b metody, kter\u00e9 se
li\u0161\u00ed pouze v typu n\u00e1vratov\u00e9 hodnoty. To nen\u00ed dovoleno.
Metody, kter\u00e9 maj\u00ed stejn\u00fd n\u00e1zev, se mus\u00ed li\u0161it
v po\u010dtu a/nebo typu parametr\u016f.

interface expected here
Zde je o\u010dek\u00e1v\u00e1no rozhran\u00ed
|
Rodi\u010dem rozhran\u00ed m\u016f\u017ee b\u00fdt pouze rozhran\u00ed.
Jm\u00e9no, kter\u00e9 jste uvedli po "extends" nen\u00ed rozhran\u00ed.

interface methods cannot have body
Metoda deklrovan\u00e1 v rozhran\u00ed nem\u016f\u017ee m\u00edt t\u011blo
|
Rozhran\u00ed m\u016f\u017ee obsahovat pouze hlavi\u010dky metod
ukon\u010den\u00e9 st\u0159edn\u00edkem. Metody deklarovan\u00e9 v rozhran\u00ed
nesm\u00ed m\u00edt definov\u00e1no t\u011blo ve slo\u017een\u00fdch z\u00e1vork\u00e1ch.

hexadecimal numbers must contain at least one hexadecimal digit
Hexadecim\u00e1ln\u00ed \u010d\u00edsla mus\u00ed b\u00fdt tvo\u0159ena alespo\u0148 jednou \u010d\u00edslic\u00ed
|
Zadali jste hexadecim\u00e1ln\u00ed \u010d\u00edslo pomoc\u00ed z\u00e1pisu "0x".
P\u0159i z\u00e1pisu hexa \u010d\u00edsla mus\u00ed b\u00fdt po "x" uvedena alespo\u0148 jedna
hexadecim\u00e1ln\u00ed \u010d\u00edslice 0...9 nebo a...f nebo A...F.

invalid method declaration; return type required
Neplatn\u00e1 deklarace metody; chyb\u00ed typ n\u00e1vratov\u00e9 hodnoty
|
V\u0161echny metody mus\u00ed m\u00edt v hlavi\u010dce uveden typ n\u00e1vratov\u00e9 hodnoty.
Vrac\u00ed-li nap\u0159. mojeMetoda() textov\u00fd \u0159et\u011bzec, mus\u00ed m\u00edt hlavi\u010dku:
    public String mojeMetoda();
Metody, kter\u00e9 nic nevrac\u00ed maj\u00ed uveden\u00fd typ "void" - nap\u0159.:
    public void jinaMetoda();
N\u011bco v\u0161ak v\u017edy m\u00edt uvedeno mus\u00ed.
.
\u010castou p\u0159\u00ed\u010dinou t\u00e9to chyby b\u00fdv\u00e1 \u0161patn\u00e9 pojmenov\u00e1n\u00ed konstruktoru,
kter\u00e9 neodpov\u00edd\u00e1 n\u00e1zvu t\u0159\u00eddy, tak\u017ee jej pak p\u0159eklada\u010d omylem
pova\u017euje za standardn\u00ed metodu.

* already in use
... u\u017e je pou\u017eito
|
V programu je ji\u017e definov\u00e1na prom\u011bnn\u00e1 nebo
parametr t\u00edmto jm\u00e9nem. P\u0159ejete-li si vytvo\u0159it
novou prom\u011bnnou, pou\u017eijte jin\u00e9 jm\u00e9no. Chcete-li
pou\u017e\u00edt st\u00e1vaj\u00edc\u00ed prom\u011bnnou nebo parametr
odstra\u0148te z p\u0159\u00edkazu deklaraci typu.

* is accessed from within inner class; needs to be declared final
... je pou\u017eito v lok\u00e1ln\u00ed t\u0159\u00edd\u011b => mus\u00ed b\u00fdt 'final'
|
V t\u011ble lok\u00e1ln\u00ed t\u0159\u00eddy (anonymn\u00ed \u010di ojmenovan\u00e9) se pokou\u0161\u00edte
pracoval s lok\u00e1ln\u00ed prom\u011bnnou metody, v n\u00ed\u017e je t\u0159\u00edda definov\u00e1na.
Z lok\u00e1ln\u00edch t\u0159\u00edd v\u0161ak m\u016f\u017eete p\u0159istupovat pouze ke konstant\u00e1m
metod, v nich\u017e jsou definov\u00e1ny. M\u00e1te dv\u011b mo\u017enosti:
bu\u010fto p\u0159id\u00e1n\u00edm modifik\u00e1toru 'final' ud\u011blejte z pou\u017eit\u00e9 prom\u011bnn\u00e9 konstatnu
(modifik\u00e1torem "final" m\u016f\u017eete ozna\u010dit i parametr),
nebo tuto prom\u011bnnou definujte jako atribut vn\u011bj\u0161\u00ed t\u0159\u00eddy.

malformed floating point literal
Chyba p\u0159i z\u00e1pisu \u010d\u00edsla s plovouc\u00ed desetinnou te\u010dkou
|
P\u0159i z\u00e1pisu \u010d\u00edsla s plovouc\u00ed desetinou te\u010dko jste
ud\u011blali n\u011bjakou chybu.
POZOR: v \u010de\u0161tin\u011b - desetinn\u00e1 \u010d\u00e1rka; v Jav\u011b - te\u010dka !!
P\u0159\u00edklady korektn\u00edho z\u00e1pisu:
18.0      18.     1.8e1     .18E2

missing method body, or declare abstract
Chyb\u00ed t\u011blo metody, nebo kl\u00ed\u010dov\u00e9 slovo 'abstract'
|
Metoda mus\u00ed m\u00edt t\u011blo, nebo mus\u00ed b\u00fdt definov\u00e1na jako abstraktn\u00ed.
T\u011blo metody je uv\u00e1d\u011bno ve slo\u017een\u00fdch z\u00e1vork\u00e1ch.
Abstraktn\u00ed metody nemaj\u00ed t\u011blo, jsou ozna\u010deny modifik\u00e1torem
'abstract' a hlavi\u010dka metody je ukon\u010dena st\u0159edn\u00edkem - nap\u0159.
    public abstract int getOdpoved();

missing return statement
Chyb\u00ed p\u0159\u00edkaz 'return'
|
Tato metoda m\u00e1 definov\u00e1n n\u00e1vratov\u00fd typ.
Mus\u00ed proto vracet n\u00e1vratovou hodnotu pomoc\u00ed p\u0159\u00edkazu
     return <v\u00fdraz>;
nap\u0159.
     return 42;
Typ vracen\u00e9 hodnoty mus\u00ed odpov\u00eddat typu uveden\u00e9mu v hlavi\u010dce metody.
Metody, kter\u00e9 nemaj\u00ed vracet \u017e\u00e1dnou hodnotu
mus\u00ed m\u00edt deklarov\u00e1n typ n\u00e1vratov\u00e9 hodnoty "void".

missing return value
U p\u0159\u00edkazu return chyb\u00ed hodnota
|
P\u0159\u00edkaz "return;" bez ud\u00e1n\u00ed n\u00e1vratov\u00e9 hodnoty m\u016f\u017ee b\u00fdt
pou\u017eit pouze u "void" metod. Metody, u kter\u00fdch je uveden
typ n\u00e1vratov\u00e9 hodnoty, mus\u00ed vracet hodnotu dan\u00e9ho typu.
P\u0159\u00edklad:
    return 42*x;
nebo
    return "Marvin";

name clash: *
Kolize jmen: ...
|
Definovali jste dv\u011b metody se stejn\u00fdm n\u00e1zvem.
To lze pouze v p\u0159\u00edpad\u011b, kdy jedna z nich p\u0159ekr\u00fdv\u00e1 \u010di p\u0159et\u011b\u017euje druhou.
To ale nen\u00ed tento p\u0159\u00edpad. Jedna z deklarac\u00ed mus\u00ed b\u00fdt zm\u011bn\u011bna.

* is reserved for internal use
... je rezervov\u00e1no pro intern\u00ed pou\u017eit\u00ed
|
Uveden\u00e9 slovo je rezervov\u00e1no, proto nem\u016f\u017ee b\u00fdt
pou\u017eito jako jm\u00e9no prom\u011bnn\u00e9/reference nebo t\u0159\u00eddy.

native methods cannot have a body
Metoda s modifik\u00e1torem 'native' nesm\u00ed m\u00edt t\u011blo
|
Tato metoda je ozna\u010den\u00e1 jako "native" a z\u00e1rove\u0148 m\u00e1 t\u011blo.
Nativn\u00ed metody maj\u00ed pouze hlavi\u010dku ukon\u010denou st\u0159edn\u00edkem.

no enclosing instance of type {0} is in scope
"V dohledu" nen\u00ed obklopuj\u00edc\u00ed instance typu ...
|
Podrobn\u011bj\u0161\u00ed n\u00e1pov\u011bda nen\u00ed k dispozici.

no interface expected here
Na tomto m\u00edst\u011b nem\u016f\u017ee b\u00fdt pou\u017eito rozhran\u00ed
|
Pravd\u011bpodobn\u011b se pokou\u0161\u00edte odvodit t\u0159\u00eddu od rozhran\u00ed pomoc\u00ed slova "extends".
T\u0159\u00eddu lze odvodit pouze od jin\u00e9 t\u0159\u00eddy, nikoliv od rozhran\u00ed. Chcete-li, aby
tato t\u0159\u00edda implementovala dan\u00e9 rozhran\u00ed, pou\u017eijte kl\u00ed\u010dov\u00e9 slovo "implements".

{0} has no match in entry in {1}; required {2}
... nesouhlas\u00ed se vstupem v ...; je po\u017eadov\u00e1no ...
|
Podrobn\u011bj\u0161\u00ed n\u00e1pov\u011bda nen\u00ed k dispozici.

* is not defined in a public class or interface; cannot be accessed from outside package
... nen\u00ed deklarov\u00e1na jako ve\u0159ejn\u00e1 t\u0159\u00edda nebo rozhran\u00ed => nem\u016f\u017ee b\u00fdt pou\u017eite vn\u011b bal\u00ed\u010dku
|
Z jin\u00fdch bal\u00ed\u010dk\u016f m\u016f\u017eete oslovovat pouze t\u0159\u00eddy, ozna\u010den\u00e9 modifik\u00e1torem public.
Pot\u0159ebujete-li pracovat s danou t\u0159\u00eddou, m\u00e1te t\u0159i mo\u017enosti:
1. Ozna\u010d\u00edte oslovanou t\u0159\u00eddu modifik\u00e1torem public
2. P\u0159est\u011bhujete t\u0159\u00eddu do bal\u00ed\u010dku s t\u0159\u00eddou, kter\u00e1 ji oslovuje
3. P\u0159est\u011bhujete oslovuj\u00edc\u00ed kt\u0159\u00eddu do bal\u00ed\u010dku t\u0159\u00eddy oslovovan\u00e9

* cannot be accessed from outside package
... nem\u016f\u017ee b\u00fdt pou\u017eito mimo bal\u00ed\u010dek
|
Spolupracujete s t\u0159\u00eddou v jin\u00e9m bal\u00ed\u010dku,
mus\u00ed b\u00fdt tato t\u0159\u00edda ozna\u010dena jako ve\u0159ejn\u00e1 (public)
a ve\u0159ejn\u00e9 mus\u00ed b\u00fdt i oslovan\u00e9 \u010dleny (atributy, metody, intern\u00ed typy).

not a loop label: *
Nen\u00ed n\u00e1v\u011b\u0161t\u00edm cyklu: ...
|
Identifik\u00e1tor pou\u017eit\u00fd jako n\u00e1v\u011b\u0161t\u00ed v p\u0159\u00edkazu
    break <n\u00e1v\u011b\u0161t\u00ed>
nen\u00ed deklarov\u00e1n jako n\u00e1v\u011b\u0161t\u00ed nebo je deklarov\u00e1n na \u0161patn\u00e9m m\u00edst\u011b.
N\u00e1v\u011b\u0161t\u00ed mus\u00ed b\u00fdt um\u00edst\u011bno t\u011bsn\u011b p\u0159ed blokem,
kter\u00fd budeme p\u0159\u00edslu\u0161n\u00fdm p\u0159\u00edkazem "break" opou\u0161t\u011bt.

not a statement
To nen\u00ed p\u0159\u00edkaz
|
Napsali jste k\u00f3d, kter\u00fd nen\u00ed p\u0159\u00edkazem.
Pravd\u011bpodobn\u011b m\u00e1te v p\u0159\u00edkazu p\u0159eklep.
Zkontrolujte znovu tento \u0159\u00e1dek.

not an enclosing class:*
T\u0159\u00edda nen\u00ed vn\u011bj\u0161\u00ed t\u0159\u00eddou: ...
|
Pokusli jste se pou\u017e\u00edt kvalifikovan\u00e9 this, tj. p\u0159\u00edkaz ve tvaru
    T\u0159\u00edda.this.n\u011bco...
Kvalifikovan\u00e9 this je mo\u017eno pou\u017e\u00edt pouze tehdy,
je-li pou\u017eit ve vnit\u0159n\u00ed t\u0159\u00edd\u011b t\u0159\u00eddy T\u0159\u00edda.

* cannot be applied to *
 ... oper\u00e1tor \u010di metoda nem\u016f\u017ee b\u00fdt pou\u017eit(a) pro ...
|
1.
Oper\u00e1tor kter\u00fd se zde pokou\u0161\u00edte pou\u017e\u00edt,
nem\u016f\u017ee b\u00fdt pou\u017eit pro tento datov\u00fd typ.
Pou\u017e\u00edv\u00e1te bu\u010fto \u0161patn\u00fd datov\u00fd typ nebo nevhodn\u00fd oper\u00e1tor
(nap\u0159. se pokou\u0161\u00edte n\u00e1sobit stringy).
2.
Metoda, kterou se zde pokou\u0161\u00edte pou\u017e\u00edt,
je pravd\u011bpodobn\u011b deklarov\u00e1na s jinou sadnou parametr\u016f.
Sna\u017e\u00edte se ji volat s p\u0159\u00edli\u0161 m\u00e1lo parametry,
s p\u0159\u00edli\u0161 mnoha parametry, s parametry jin\u00fdch typ\u016f,
anebo se spr\u00e1vn\u00fdmi parametry ve \u0161patn\u00e9m po\u0159ad\u00ed.

* clashes with class of same name
 ... koliduje se stejn\u011b pojmenovanou t\u0159\u00eddou
|
Ujist\u011bte se, \u017ee t\u0159\u00edda a bal\u00ed\u010dek maj\u00ed odli\u0161n\u00e1 jm\u00e9na.
Jm\u00e9na t\u0159\u00edd za\u010d\u00ednaj\u00ed velk\u00fdmi p\u00edsmeny, jm\u00e9na
bal\u00ed\u010dk\u016f za\u010d\u00ednaj\u00ed mal\u00fdmi p\u00edsmeny.

possible fall-through into case
Pravd\u011bpodobn\u00fd propad do v\u011btve case"
|
Podrobn\u011bj\u0161\u00ed n\u00e1pov\u011bda nen\u00ed k dispozici.

error reading *
Chyba p\u0159i \u010dten\u00ed ...
|
Podrobn\u011bj\u0161\u00ed n\u00e1pov\u011bda nen\u00ed k dispozici.

recursive constructor invocation
Rekurzivn\u00ed vol\u00e1n\u00ed konstruktoru
|
Vytvo\u0159ili jste konstruktor, kter\u00fd vol\u00e1 s\u00e1m sebe.
To nen\u00ed p\u0159\u00edpustn\u00e9, proto\u017ee by pravd\u011bpodobn\u011b
vznikl nekone\u010dn\u00fd cyklus.

* is ambiguous, both *
... je zam\u011bniteln\u00e9 s ...
|
Ur\u010den\u00ed jm\u00e9na t\u0159\u00eddy nebo rozhran\u00ed nen\u00ed jednozna\u010dn\u00e9.
Pravd\u011bpodobn\u011b importujete z r\u016fzn\u00fdch bal\u00ed\u010dk\u016f t\u0159\u00eddy
nebo rozhran\u00ed se stejn\u00fdm jm\u00e9nem. Tento probl\u00e9m
vy\u0159e\u0161\u00edte pou\u017eit\u00edm pln\u00e9ho jm\u00e9na t\u0159\u00eddy, nap\u0159\u00edklad:
    import java.util.List;
nebo
    java.util.List lst;

repeated interface
Opakovan\u00e9 uveden\u00ed rozhran\u00ed
|
Po "implements" bylo jedno rozhran\u00ed uvedeno opakovan\u011b.
Pou\u017eit\u00e9 rozhran\u00ed m\u016f\u017ee b\u00fdt uvedeno pouze jednou.

repeated modifier
Opakovan\u00e9 uveden\u00ed modifik\u00e1toru
|
Modifik\u00e1tor byl uveden opakovan\u011b. Modifik\u00e1tory
"final, static, public, private, volatile, ..."
se sm\u011bj\u00ed uv\u00e9st pouze jednou.

{0} has {1} access in {2}
... m\u00e1 ... p\u0159\u00edstup\u016f v ...
|
Podrobn\u011bj\u0161\u00ed n\u00e1pov\u011bda nen\u00ed k dispozici.

return outside method
P\u0159\u00edkaz return je pou\u017eit vn\u011b metod
|
P\u0159\u00edkaz "return" je mo\u017en\u00e9 pou\u017e\u00edt pouze v metod\u011b.
Nen\u00ed jej mo\u017eno pou\u017e\u00edt v inicializa\u010dn\u00edm bloku a podobn\u00fdch \u010d\u00e1stech k\u00f3du.

signature does not match {0}; incompatible interfaces
Hlavi\u010dka neodpov\u00edd\u00e1 ...; nekopmatibiln\u00ed rozhran\u00ed
|
Podrobn\u011bj\u0161\u00ed n\u00e1pov\u011bda nen\u00ed k dispozici.

signature does not match {0}; incompatible supertype
Hlavi\u010dka neodpov\u00edd\u00e1 ...; nekopmatibiln\u00ed rodi\u010dovsk\u00fd typ
|
Podrobn\u011bj\u0161\u00ed n\u00e1pov\u011bda nen\u00ed k dispozici.

* should be declared abstract; it does not define *
 ... by m\u011bla b\u00fdt deklarov\u00e1na jako 'abstract'; nen\u00ed definov\u00e1no ...
|
Tato t\u0159\u00edda nedefinuje v\u0161echny metody uveden\u00e9 v implementovan\u00fdch rozhran\u00edch
nebo neimplementuje n\u011bjakou abstraktn\u00ed metodu rodi\u010dovsk\u00e9 t\u0159\u00eddy.
Neimplementovan\u00e1 metoda je br\u00e1na jako abstraktn\u00ed
a abstraktn\u00ed metody se sm\u00ed vyskytovat pouze v abstraktn\u00ed t\u0159\u00edd\u011b.
Bu\u010f mus\u00edte implementovat v\u0161echny zd\u011bd\u011bn\u00e9 abstraktn\u00ed metody
(implementovnan\u00e9 rozhran\u00ed je tak\u00e9 pova\u017eov\u00e1no za p\u0159edka)
nebo deklarovat t\u0159\u00eddu jako abstraktn\u00ed.

* is not abstract and does not override abstract method *
... nen\u00ed abstraktn\u00ed a p\u0159itom neimplementuje abstratn\u00ed metodu ...
|
Nej\u010dast\u011bj\u0161\u00ed p\u0159\u00ed\u010dinou chyby je nedefinovan\u00e1 metoda
vy\u017eadovan\u00e1 implementovan\u00fdm rozhran\u00edm.
.
Tato t\u0159\u00edda nedefinuje v\u0161echny metody uveden\u00e9 v implementovan\u00fdch rozhran\u00edch
nebo neimplementuje n\u011bjakou abstraktn\u00ed metodu rodi\u010dovsk\u00e9 t\u0159\u00eddy.
Neimplementovan\u00e1 metoda je br\u00e1na jako abstraktn\u00ed
a abstraktn\u00ed metody se sm\u00ed vyskytovat pouze v abstraktn\u00ed t\u0159\u00edd\u011b.
Bu\u010f mus\u00edte implementovat v\u0161echny zd\u011bd\u011bn\u00e9 abstraktn\u00ed metody
(implementovnan\u00e9 rozhran\u00ed je tak\u00e9 pova\u017eov\u00e1no za p\u0159edka)
nebo deklarovat t\u0159\u00eddu jako abstraktn\u00ed.
.
V chybov\u00e9m hl\u00e1\u0161en\u00ed je uvedena konkr\u00e9tn\u00ed neimplementovan\u00e1 metoda.
Po jej\u00ed implementaci se ale m\u016f\u017ee chyba zopakovat s dal\u0161\u00ed metodou
dokud nebudou implementov\u00e1ny v\u0161echny.

error writing source; cannot overwrite input file *
Chyba p\u0159i zapisov\u00e1n\u00ed zdroje; nelze p\u0159epsat vstupn\u00ed soubor ...
|
Podrobn\u011bj\u0161\u00ed n\u00e1pov\u011bda nen\u00ed k dispozici.

'try' without 'catch' or 'finally'
Pou\u017eit\u00ed 'try' bez 'catch' nebo 'finally'
|
Pou\u017eijete-li blok "try", mus\u00edte jej ukon\u010dit
pomoc\u00ed "catch" nebo "finally". Spr\u00e1vn\u00e9 pou\u017eit\u00ed:
   try {
      p\u0159\u00edkazy;
   }
   catch(Exception e) {
      p\u0159\u00edkazy;
   }
   finally {
      p\u0159\u00edkazy;
   }

* does not take parameters
... nem\u00e1 parametry
|
Pou\u017eit\u00fd datov\u00fd typ nen\u00ed generick\u00fd.
Nem\u016f\u017eete proto pou\u017e\u00edvat typov\u00e9 parametry.

wrong number of type arguments; required *
Nespr\u00e1vn\u00fd po\u010det parametr\u016f; po\u017eadov\u00e1no ...
|
V deklaraci prom\u011bnn\u00e9 generick\u00e9ho typu jste pou\u017eili
nespr\u00e1vn\u00fd po\u010det typov\u00fdch parametr\u016f. Nap\u0159.
rozhran\u00ed List<E> m\u00e1 jenom jeden typov\u00fd parametr,
kde\u017eto rozhran\u00ed Map<K, V> m\u00e1 dva typov\u00e9 parametry.

type variable {0} occurs more than once in result type of {1}; cannot be left uninstantiated
Typov\u00e1 prom\u011bnn\u00e1 ... se vyskytuje ve v\u00fdsledku typu ... v\u00edce ne\u017e jednou; je t\u0159eba vytvo\u0159it instanci
|
Podrobn\u011bj\u0161\u00ed n\u00e1pov\u011bda nen\u00ed k dispozici.

type variable {0} occurs more than once in type of {1}; cannot be left uninstantiated
Typov\u00e1 prom\u011bnn\u00e1 ... se vyskytuje ve typu ... v\u00edce ne\u017e jednou; je t\u0159eba vytvo\u0159it instanci
|
Podrobn\u011bj\u0161\u00ed n\u00e1pov\u011bda nen\u00ed k dispozici.

unclosed character literal
Neukon\u010den\u00fd znakov\u00fd liter\u00e1l
|
Pravd\u011bpodobn\u011b jste zapomn\u011bli ukon\u010dit liter\u00e1l pomoc\u00ed apostrofu - nap\u0159. 'a'.

unclosed comment
Neukon\u010den\u00fd koment\u00e1\u0159
|
Blokov\u00fd komet\u00e1\u0159 mus\u00ed za\u010d\u00ednat dvojic\u00ed znak\u016f "/*"
a b\u00fdt ukon\u010den dvojic\u00ed znak\u016f "*/".

unclosed string literal
Neukon\u010den\u00fd znakov\u00fd \u0159et\u011bzec
|
Textov\u00fd \u0159et\u011bzec mus\u00ed b\u00fdt uzav\u0159en v uvozovk\u00e1ch (").
Pot\u0159ebujete-li vlo\u017eit do \u0159et\u011bzce uvozovky, pou\u017eijte
'\"', pot\u0159ebujete-li vlo\u017eit nov\u00fd \u0159\u00e1dek, pou\u017eijte '\n'.

undefined label: *
Nedefinovan\u00e9 n\u00e1v\u011b\u0161t\u00ed: ...
|
Zadan\u00e9 n\u00e1v\u011b\u0161t\u00ed neexistuje. N\u00e1v\u011b\u0161t\u00ed pou\u017eit\u00e9 v p\u0159\u00edkazu
    break <n\u00e1v\u011b\u0161t\u00ed>
a
    continue <n\u00e1v\u011b\u0161t\u00ed>
mus\u00ed b\u00fdt um\u00edst\u011bna t\u011bsn\u011b p\u0159ed blokem, z n\u011bj\u017e vyskakujete,
resp. p\u0159ed cyklem, jeho\u017e t\u011blo chcete zopakovat.
Pokud jste je \u0161pat\u011bn zapsali anobo jste je um\u00edstili jinde,
p\u0159eklada\u010d je nem\u016f\u017ee naj\u00edt.

unreachable statement
P\u0159\u00edkaz nebude nikdy vykon\u00e1n
|
Tento p\u0159\u00edkaz nebude nikdy vykon\u00e1n.
Metody nesm\u00ed obsahovat k\u00f3d, kter\u00fd nem\u016f\u017ee b\u00fdt nikdy vykon\u00e1n.
Nej\u010dast\u011bji se jedn\u00e1 o p\u0159\u00edkaz stoj\u00edc\u00ed bezprost\u0159edn\u011b za p\u0159\u00edkazem return
nebo za vychozen\u00edm v\u00fdjimky.
Ov\u011b\u0159te p\u0159\u00edkazy, kter\u00e9 ovliv\u0148uj\u00ed vykon\u00e1v\u00e1n\u00ed k\u00f3du,
nebo nevykonateln\u00fd p\u0159\u00edkaz vyma\u017ete.

initializer must be able to complete normally
Statick\u00fd blok mus\u00ed b\u00fdt ukon\u010den norm\u00e1ln\u011b
|
Statick\u00fd inicializa\u010dn\u00ed blok zastupuj\u00edc\u00ed konstruktor t\u0159\u00eddy nesm\u00ed
vyvolat kontrolovanou v\u00fdjimku, tj. v\u00fdjimku, kter\u00e1 je potomkem
t\u0159\u00eddy Exception a nen\u00ed potomkem t\u0159\u00eddy RuntimeException.

* must be caught or declared to be thrown
v\u00fdjimka ... mus\u00ed b\u00fdt zachycena nebo deklarov\u00e1na jako vyvol\u00e1van\u00e1
|
V hlavi\u010dce metody mus\u00ed b\u00fdt uvedeny v\u0161echny v\u00fdjimky,
kter\u00e9 mohou v t\u011ble metody nastat a nejsou uvnit\u0159 metody zachyceny.
To znamen\u00e1: metoda zachyt\u00ed v\u00fdjimku pomoc\u00ed bloku "try",
nebo je v z\u00e1hlav\u00ed metody uvedeno "throws" n\u00e1sledovan\u00e9 t\u0159\u00eddou v\u00fdjimky.
P\u0159\u00edklad zachycen\u00ed:
   try
   {
      ...
   }
   catch(...)
   {
      ...
   }
P\u0159\u00edklad p\u0159ed\u00e1n\u00ed v\u00fdjimky d\u00e1le:
   public void mojeMetoda() throws NejakaVyjimka

'void' type not allowed here
Typ 'void' zde nelze pou\u017e\u00edt
|
Typ "void" je mo\u017eno pou\u017e\u00edt pouze pro metody.
Nelze ho pou\u017e\u00edt pro prom\u011bnn\u00e9.

* not allowed here
... nen\u00ed zde povolen
|
Pou\u017eili jste modifik\u00e1tor ("private", "protected", ...)
na m\u00edst\u011b, kde to nen\u00ed p\u0159\u00edpustn\u00e9.

* might already have been assigned to
... p\u0159i\u0159azen\u00ed u\u017e mohlo b\u00fdt provedeno
|
Konstant\u011b sm\u00ed b\u00fdt p\u0159i\u0159azena hodnota pouze jednou.
Statick\u00e9 konstanty mus\u00ed b\u00fdt inicializov\u00e1ny v deklaraci
nebo statick\u00e9m inicializa\u010dn\u00edm bloku, instan\u010dn\u00ed konstanty
mus\u00ed b\u00fdt inicializov\u00e1ny v deklaraci nebo konstruktoru.

* might not have been initialized
... nemus\u00ed b\u00fdt inicializov\u00e1no
|
Lok\u00e1ln\u00ed prom\u011bnn\u00e1 mus\u00ed b\u00fdt p\u0159ed prvn\u00edm pou\u017eit\u00edm inicializovan\u00e1.

variable {0} might be assigned in loop
prom\u011bnn\u00e9 ... m\u016f\u017ee b\u00fdt p\u0159i\u0159azena hodnota v cyklu
|
Podrobn\u011bj\u0161\u00ed n\u00e1pov\u011bda nen\u00ed k dispozici.

error while writing *
Chyba p\u0159i z\u00e1pisu ...
|
Podrobn\u011bj\u0161\u00ed n\u00e1pov\u011bda nen\u00ed k dispozici.

* is public, should be declared in a file named *
 .. je deklarov\u00e1no jako 'public' a proto mus\u00ed b\u00fdt v souboru pojmenovan\u00e9m ...
|
Zdrojov\u00fd k\u00f3d ve\u0159ejn\u00fdch t\u0159\u00edd mus\u00ed b\u00fdt v souboru s p\u0159\u00edponou .java
a se jm\u00e9nem shodn\u00fdm se jm\u00e9nem t\u0159\u00eddy.
P\u0159\u00edklad: t\u0159\u00edda "T\u0159\u00edda" mus\u00ed b\u00fdt v souboru "T\u0159\u00edda.java".

cannot read: *
Nelze \u010d\u00edst: ...
|
Podrobn\u011bj\u0161\u00ed n\u00e1pov\u011bda nen\u00ed k dispozici.

* uses or overrides a deprecated API.
... pou\u017e\u00edv\u00e1 nebo p\u0159ekr\u00fdv\u00e1 metodu, kter\u00e1 je 'deprecated'
|
Pou\u017e\u00edv\u00e1n\u00ed "deprectated" (zavr\u017een\u00fdch) metod se nedoporu\u010duje.
P\u0159e\u010dt\u011bte si pros\u00edm dokumentaci a pou\u017eijte jej\u00ed nov\u011bj\u0161\u00ed n\u00e1hra\u017eku.

* has been deprecated
... je 'deprecated'
|
Pou\u017e\u00edv\u00e1n\u00ed t\u00e9to metody nen\u00ed doporu\u010deno, tato metoda byla ozna\u010dena jako zavr\u017een\u00e1.
P\u0159e\u010dt\u011bte si pros\u00edm dokumentaci a najd\u011bte si jej\u00ed nov\u011bj\u0161\u00ed n\u00e1hra\u017eku.

';' expected
Je o\u010dek\u00e1v\u00e1n st\u0159edn\u00edk
|
Ka\u017ed\u00fd p\u0159\u00edkaz mus\u00ed b\u00fdt ukon\u010den st\u0159edn\u00edkem.
Chyba je pravd\u011bpodobn\u011b na tomto nebo na p\u0159edchoz\u00edm \u0159\u00e1dku.
Chyba b\u00fdv\u00e1 ob\u010das zavle\u010dena d\u00edky \u0161patn\u011b uzav\u0159en\u00fdm z\u00e1vork\u00e1m
nebo uvozovk\u00e1m.

'case', 'default' or '}' expected
Je o\u010dek\u00e1v\u00e1no 'case', 'defaul', nebo '}'
|
Podrobn\u011bj\u0161\u00ed n\u00e1pov\u011bda nen\u00ed k dispozici.

'class' or 'interface' expected
Je o\u010dek\u00e1v\u00e1no 'class', nebo 'interface'
|
V dan\u00e9m m\u00edst\u011b je o\u010dek\u00e1v\u00e1no kl\u00ed\u010dov\u00e9 slovo "class" nebo "interface".
Nebylo zde nalezeno nebo je p\u0159ed n\u00edm n\u011bco, co tam nepat\u0159\u00ed.

class, interface, or enum expected
Je o\u010dek\u00e1v\u00e1na deklarace t\u0159\u00eddy, rozhran\u00ed nebo v\u00fd\u010dtov\u00e9ho typu
|
Na ozna\u010den\u00e9 pozici byl uzav\u0159en datov\u00fd typ (t\u0159\u00edda, rozhran\u00ed, v\u00fd\u010dtov\u00fd typ)
a dal\u0161\u00ed k\u00f3d je \u0161patn\u011b rozpozn\u00e1n.
Pravd\u011bpodobn\u011b v\u00e1m p\u0159eb\u00fdv\u00e1 jedna slo\u017een\u00e1 z\u00e1vorka.

'.class' expected
Je o\u010dek\u00e1v\u00e1no .class
|
Podrobn\u011bj\u0161\u00ed n\u00e1pov\u011bda nen\u00ed k dispozici.

'(' or '[' expected
Je o\u010dek\u00e1v\u00e1no '(', nebo '['
|
Zd\u00e1 se, \u017ee po\u010det lev\u00fdch a prav\u00fdch z\u00e1vorek neodpov\u00edd\u00e1.
Vyu\u017eijte toho, \u017ee editor p\u0159i um\u00edst\u011bn\u00ed kurzoru za z\u00e1vorku
zv\u00fdrazn\u00ed jej\u00ed p\u00e1rovou z\u00e1vorku a zkontrolujte,
\u017ee si tyto z\u00e1vorky odpov\u00eddaj\u00ed.

* expected
... o\u010dek\u00e1v\u00e1no
|
Na ozna\u010den\u00e9 pozici je ve zdrojov\u00e9m k\u00f3du o\u010dek\u00e1v\u00e1n
uveden\u00fd symbol. M\u00edsto n\u011bj tu v\u0161ak byl nalezen jin\u00fd
symbol. Pokuste se odhalit, p\u0159o\u010d p\u0159eklada\u010d o\u010dek\u00e1v\u00e1
na ozna\u010den\u00e9m m\u00edst\u011b uveden\u00fd symbol.

orphaned *
Opu\u0161t\u011bn\u00e9 ...
|
Podrobn\u011bj\u0161\u00ed n\u00e1pov\u011bda nen\u00ed k dispozici.

cannot access *
Nelze p\u0159istupovat k ...
|
Podrobn\u011bj\u0161\u00ed n\u00e1pov\u011bda nen\u00ed k dispozici.

type parameter {0} is not within its bound *
Parametr ... nen\u00ed uvnit\u0159 sv\u00fdch mez\u00ed ...
|
Podrobn\u011bj\u0161\u00ed n\u00e1pov\u011bda nen\u00ed k dispozici.

type parameters of {0} cannot be determined
Typ parametru nen\u00ed mo\u017eno ur\u010dit
|
Podrobn\u011bj\u0161\u00ed n\u00e1pov\u011bda nen\u00ed k dispozici.

incompatible types*
Nekompatibiln\u00ed typy ...
|
Na tomto m\u00edst\u011b je o\u010dek\u00e1v\u00e1n jin\u00fd datov\u00fd typ.
P\u0159iklad: uvedli jste typ "String" na m\u00edst\u011b,
kde je o\u010dek\u00e1v\u00e1n typ "int".
\u010cast\u00fdm d\u016fvodem b\u00fdv\u00e1, \u017ee v metod\u011b vrac\u00edte hodnotu jin\u00e9ho typu,
ne\u017e jak\u00fd je deklarov\u00e1n v hlavi\u010dce metody.

inconvertible types*
Konverze typ\u016f nen\u00ed mo\u017en\u00e1
|
Typ uveden\u00fd na tomto m\u00edst\u011b nem\u016f\u017ee b\u00fdt automaticky konvertov\u00e1n
na po\u017eadovan\u00fd typ.

possible loss of precision
Pravd\u011bpodobn\u00e1 ztr\u00e1ta p\u0159esnosti
|
P\u0159ev\u00e1d\u00edte "v\u011bt\u0161\u00ed" datov\u00fd typ na "men\u0161\u00ed",
nap\u0159. p\u0159i\u0159azujete do prom\u011bnn\u00e9 typu int hodnotu typu long.
Takov\u00fdto p\u0159evod je t\u0159eba prov\u00e9st explicitn\u011b pomoc\u00ed p\u0159etypov\u00e1n\u00ed:
    long a = 123456789;
    int  b = (int) a;

unexpected type
Neo\u010dek\u00e1van\u00fd typ
|
Na tomto m\u00edst\u011b je vy\u017eadov\u00e1n v\u00fdraz n\u011bjak\u00e9ho typu.
V programu je v\u0161ak v\u00fdraz jin\u00e9ho typu, kter\u00fd nen\u00ed
s po\u017eadovan\u00fdm typem kompatibiln\u00ed (nap\u0159. pou\u017e\u00edv\u00e1te
String v m\u00edst\u011b, kde je vy\u017eadov\u00e1n int).

abstract {0} {1} cannot be accessed directly
Abstraktn\u00ed ...  ... nem\u016f\u017ee b\u00fdt p\u0159\u00edmo pou\u017eito
|
Podrobn\u011bj\u0161\u00ed n\u00e1pov\u011bda nen\u00ed k dispozici.

*An explicit 'this' qualifier must be used to select the desired instance.
... k v\u00fdb\u011bru po\u017eadovan\u00e9 instance mus\u00ed b\u00fdt pou\u017eit explicitn\u00ed kvalifik\u00e1tor "this"
|
Podrobn\u011bj\u0161\u00ed n\u00e1pov\u011bda nen\u00ed k dispozici.

*cannot be referenced from a static context
... nemohou b\u00fdt pou\u017eity ve statick\u00e9m kontextu
|
Pokou\u0161\u00edte se pou\u017e\u00edt ve statick\u00e9 metod\u011b atribut nebo metodu instance.
To nelze, proto\u017ee p\u0159eklada\u010d nepozn\u00e1, kter\u00e9 instanci dan\u00e1 entita pat\u0159\u00ed.
Bu\u010fto mus\u00edte metodu deklarovat jako instan\u010dn\u00ed,
anebo mus\u00edte pou\u017e\u00edvanou entitu (atribut \u010di metodu)
kvalifikovat objektem, jemu\u017e pat\u0159\u00ed.

cannot find symbol*
nelze naj\u00edt symbol...
|
Na tomto m\u00edst\u011b pou\u017e\u00edv\u00e1te symbol (n\u00e1zev prom\u011bnn\u00e9, metody \u010di t\u0159\u00eddy),
kter\u00fd nebyl deklarov\u00e1n nikde, kam je odsud "ved\u011bt".
Ov\u011b\u0159te, zda se jedn\u00e1 o p\u0159eklep nebo zda jste pouze zapomn\u011bli
dan\u00fd symbol deklarovat.
Dal\u0161\u00ed mo\u017enost\u00ed je, \u017ee jste onen symbol deklarovali n\u011bkde,
kam odsud "nen\u00ed vid\u011bt" - nap\u0159. uvnit\u0159 n\u011bkter\u00e9ho z p\u0159edchoz\u00edch blok\u016f.

cannot resolve symbol*
Nelze rozpoznat symbol ...
|
Na ozna\u010den\u00e9m m\u00edst\u011b pou\u017e\u00edv\u00e1te symbol (jm\u00e9no prom\u011bn\u00e9, t\u0159\u00eddy nebo
metody), kter\u00e1 nen\u00ed deklarov\u00e1n\u00e1 v \u017e\u00e1dn\u00e9 viditeln\u00e9 oblasti.
Zkontrolujte, zda jste neud\u011blali p\u0159eklep nebo zda jste
danou prom\u011bnnou nezapomn\u011bli deklarovat. Objev\u00edte-li chybu,
napravte ji.

{0}; {1} and {2} are static
...; ... a ... jsou statick\u00e9
|
Podrobn\u011bj\u0161\u00ed n\u00e1pov\u011bda nen\u00ed k dispozici.

{0}; overridden method is {1}
...; p\u0159ekryvn\u00e1 metoda je ...
|
Podrobn\u011bj\u0161\u00ed n\u00e1pov\u011bda nen\u00ed k dispozici.

* attempting to assign weaker access privileges; was *
Pokus o p\u0159i\u0159azen\u00ed slab\u0161\u00edch p\u0159\u00edstupov\u00fdch pr\u00e1v
|
P\u0159\u00edstupov\u00e1 pr\u00e1va ke atribut\u016fm a metod\u00e1m dce\u0159in\u00fdch t\u0159\u00edd
nesm\u00ed b\u00fdt p\u0159\u00edsn\u011bj\u0161\u00ed ne\u017e p\u0159\u00edstupov\u00e1 pr\u00e1va k t\u011bm\u017ee \u010dlen\u016fm
rodi\u010dovsk\u00fdch t\u0159\u00edd.

* overridden method does not throw *
P\u0159ekryt\u00e1 metoda ... nevyvol\u00e1v\u00e1 v\u00fdjimku ...
|
P\u0159ekryli jste metodu a vyvol\u00e1v\u00e1te zde v\u00fdjimku.
P\u0159ekr\u00fdvaj\u00edc\u00ed metody nemohou vyhazovat jin\u00e9 v\u00fdjimky
ne\u017e jejich p\u0159ekryt\u00e9 prot\u011bj\u0161ky.

* attempting to use incompatible return type
... sna\u017e\u00edte se pou\u017e\u00edt nekompatibiln\u00ed v\u00fdstupn\u00ed typ hodnoty
|
Podrobn\u011bj\u0161\u00ed n\u00e1pov\u011bda nen\u00ed k dispozici.

* is already defined in this compilation unit
... je ji\u017e v t\u00e9to p\u0159ekladov\u00e9 jednotce definov\u00e1no
|
Pou\u017eili jste stejn\u00e9 jm\u00e9no dvakr\u00e1t.
Pou\u017eijte jin\u00fd identifik\u00e1tor.

{0} is already defined in a single-type import
|
Podrobn\u011bj\u0161\u00ed n\u00e1pov\u011bda nen\u00ed k dispozici.

* conflicts with a compiler-synthesized symbol in *
... koliduje se symbolem vytvo\u0159en\u00fdm p\u0159eklada\u010dem v ...
|
Podrobn\u011bj\u0161\u00ed n\u00e1pov\u011bda nen\u00ed k dispozici.

reached end of file while parsing
p\u0159i anal\u00fdze bylo dosa\u017eeno konce souboru
|
Nejsp\u00ed\u0161e jste pomoc\u00ed '{' otev\u0159eli n\u011bjak\u00fd blok,
kter\u00fd jste pak zapomn\u011bli zav\u0159\u00edt odpov\u00eddaj\u00edc\u00ed '}'.
Bu\u010fto v\u00e1m n\u011bkde p\u0159eb\u00fdv\u00e1 otev\u00edrac\u00ed z\u00e1vorka,
nebo jste zapomn\u011bli napsat z\u00e1vorku zav\u00edrac\u00ed.
P\u0159i hled\u00e1n\u00ed chyby m\u016f\u017eete v editoru vyu\u017e\u00edt funkce
zv\u00e1razn\u011bn\u00ed p\u00e1rov\u00fdch z\u00e1vorek.
