as of release 1.4, 'assert' is a keyword, and may not be used as an identifier
Od verzie 1.4 je \u201eassert\u201c k\u013e\u00fa\u010dov\u00fdm slovom a\u00a0nem\u00f4\u017ee by\u0165 pou\u017eit\u00e9 ako identifik\u00e1tor.
 
Slovo \u201eassert\u201c je teraz s\u00fa\u010das\u0165ou jazyka Java, tak\u017ee je
rezervovan\u00e9 (je to k\u013e\u00fa\u010dov\u00e9 slovo). Preto ho nie je
mo\u017en\u00e9 pou\u017ei\u0165 ako identifik\u00e1tor met\u00f3dy \u010di premennej.
Zvo\u013ete, pros\u00edm, in\u00fd identifik\u00e1tor (n\u00e1zov) objektu.

qualified new of static class
Kvalifikovan\u00fd oper\u00e1tor new pri kon\u0161trukcii in\u0161tancie statickej triedy.
 
Kvalifikovan\u00e9 oper\u00e1tory new sa pou\u017e\u00edvaj\u00fa len pri tvorbe
in\u0161tanci\u00ed vn\u00fatorn\u00fdch tried, t.\u00a0j. tried, ktor\u00e9 s\u00fa definovan\u00e9
vo vn\u00fatri in\u00fdch tried. Av\u0161ak na to, aby boli tak\u00fdmto sp\u00f4sobom
pou\u017eite\u013en\u00e9, nesm\u00fa by\u0165 definovan\u00e9 ako statick\u00e9.

* is abstract; cannot be instantiated
\u00ab\u2026\u00bb je abstraktn\u00e1 trieda \u2013 nie je mo\u017en\u00e9 vytvori\u0165 jej in\u0161tanciu.
 
T\u00e1to trieda bola deklarovan\u00e1 ako abstraktn\u00e1 (pomocou
k\u013e\u00fa\u010dov\u00e9ho slova \u201eabstract\u201c). Z\u00a0abstraktn\u00fdch tried nem\u00f4\u017eu
by\u0165 vytv\u00e1ran\u00e9 in\u0161tancie. In\u0161tancie m\u00f4\u017eu by\u0165 vytvoren\u00e9 a\u017e
z\u00a0ich dc\u00e9rskych (odvoden\u00fdch) tried. Dc\u00e9rska trieda mus\u00ed
ma\u0165 implementovan\u00e9 v\u0161etky met\u00f3dy, ktor\u00e9 neboli
implementovan\u00e9 v\u00a0jej rodi\u010dovi (v\u0161etky abstraktn\u00e9 met\u00f3dy).

abstract methods cannot have a body
Abstraktn\u00e9 met\u00f3dy nesm\u00fa ma\u0165 telo.
 
Pomocou k\u013e\u00fa\u010dov\u00e9ho slova \u201eabstract\u201c ste ozna\u010dili met\u00f3du
ako abstraktn\u00fa a\u00a0pritom ste definovali jej telo (k\u00f3d v\u00a0zlo\u017een\u00fdch
z\u00e1tvork\u00e1ch). Deklar\u00e1cie abstraktn\u00fdch met\u00f3d sm\u00fa obsahova\u0165
len hlavi\u010dku ukon\u010den\u00fa bodko\u010diarkou. Bu\u010f odstr\u00e1\u0148te k\u013e\u00fa\u010dov\u00e9
slovo \u201eabstract\u201c, alebo odstr\u00e1\u0148te telo met\u00f3dy (vr\u00e1tane
zlo\u017een\u00fdch z\u00e1tvoriek) a\u00a0ukon\u010dite hlavi\u010dku met\u00f3dy bodko\u010diarkou.

* is already defined in *
\u00ab\u2026\u00bb je u\u017e definovan\u00e1 v\u00a0\u00ab\u2026\u00bb.
 
Vo vn\u00fatri tejto met\u00f3dy je u\u017e definovan\u00e1 premenn\u00e1
(pr\u00edpadne parameter) s\u00a0rovnak\u00fdm n\u00e1zvom. Ak si \u017eel\u00e1te
vytvori\u0165 nov\u00fa premenn\u00fa (alebo referenciu), pou\u017eite in\u00fd
n\u00e1zov. Ak ste na tomto mieste chceli t\u00fato premenn\u00fa
(pr\u00edpadne parameter) iba pou\u017ei\u0165, tak odstr\u00e1\u0148te ur\u010denie
typu uveden\u00e9 pred jej menom (aby to nevyzeralo ako
nov\u00e1 deklar\u00e1cia).

anonymous class implements interface; cannot have arguments
Anonymn\u00e1 trieda implementuj\u00faca rozhranie nesmie ma\u0165 parametre.
 
Presnej\u0161ie povedan\u00e9, v\u00a0defin\u00edcii anonymnej triedy mus\u00edte
v\u00a0hlavi\u010dke za deklar\u00e1ciou implementovan\u00e9ho rozhrania
uvies\u0165 len pr\u00e1zdne okr\u00fahle z\u00e1tvorky \u2013 ().

anonymous class implements interface; cannot have qualifier for new
Anonymn\u00e1 trieda implementuj\u00faca rozhranie nesmie obsahova\u0165 kvalifik\u00e1tor new.
 
Podrobnej\u0161\u00ed pomocn\u00edk nie je k\u00a0dispoz\u00edcii.

array required, but *
Je vy\u017eadovan\u00e9 pole, ale uveden\u00fd typ je \u00ab\u2026\u00bb.
 
Pou\u017eili ste syntax, ktor\u00e1 je pou\u017e\u00edvan\u00e1 pri pr\u00edstupe
k\u00a0elementom po\u013ea, av\u0161ak premenn\u00e1, ku ktorej ste to
vztiahli, nie je pole.

break outside switch or loop
Pr\u00edkaz \u201ebreak\u201c je pou\u017eit\u00fd mimo \u201eswitch\u201c alebo cyklus.
 
Pr\u00edkaz \u201ebreak\u201c ukon\u010d\u00ed vykon\u00e1vanie bloku \u201eswitch\u201c
alebo cyklu \u201efor\u201c, \u201ewhile\u201c \u010di \u201edo\u201c.
Pr\u00edkaz \u201ebreak\u201c nesmie by\u0165 pou\u017eit\u00fd mimo t\u00fdchto blokov.

* must be first statement in constructor
\u00ab\u2026\u00bb mus\u00ed by\u0165 prv\u00fdm pr\u00edkazom v\u00a0kon\u0161truktore.
 
Ak chcete pou\u017ei\u0165 volanie kon\u0161truktora nadradenej triedy:
    super(\u2026);
tak toto volanie mus\u00ed by\u0165 prv\u00fdm pr\u00edkazom v\u00a0kon\u0161truktore
odvodenej triedy (pri\u010dom namiesto \u2026 mus\u00edte doplni\u0165 spr\u00e1vne
parametre). Preto pred t\u00fdmto pr\u00edkazom nesmie by\u0165 ni\u010d: \u017eiadny
in\u00fd pr\u00edkaz ani za\u010diatok bloku alebo blok try \u2026 catch, ni\u010d. S\u00fa
povolen\u00e9 len biele znaky (medzery, tabul\u00e1tory\u2026) a\u00a0koment\u00e1re.
Toto obmedzenie bolo do jazyka Java vlo\u017een\u00e9 preto, lebo
pou\u017eitie ak\u00e9hoko\u013evek \u010dlena triedy pred t\u00fdmto volan\u00edm, by
zaru\u010dene prinieslo probl\u00e9my!

cannot assign a value to final variable *
Nie je mo\u017en\u00e9 priradi\u0165 hodnotu fin\u00e1lnej premennej \u00ab\u2026\u00bb.
 
K\u013e\u00fa\u010dov\u00fdm slovom \u201efinal\u201c s\u00fa ozna\u010den\u00e9 premenn\u00e9, ktor\u00fdch
hodnota nesmie by\u0165 v\u00a0programe \u010falej menen\u00e1. Ak
skuto\u010dne potrebujete hodnotu premennej zmeni\u0165,
odstr\u00e1\u0148te v\u00a0jej deklar\u00e1cii modifik\u00e1tor \u201efinal\u201c.

type variables cannot be dereferenced
Premenn\u00e9 primit\u00edvnych typov nem\u00f4\u017eu by\u0165 dereferencovan\u00e9.
 
Pri premenn\u00fdch a\u00a0atrib\u00fatoch primit\u00edvnych typov, nem\u00f4\u017eete
pou\u017ei\u0165 bodkov\u00fa konvenciu a\u00a0pok\u00fa\u0161a\u0165 sa odvol\u00e1va\u0165 na ich
atrib\u00faty alebo met\u00f3dy.

* cannot be dereferenced
\u00ab\u2026\u00bb nem\u00f4\u017ee by\u0165 dereferencovan\u00e1.
 
Pomocou bodkovej not\u00e1cie (oper\u00e1tora \u201e.\u201c) sa usilujete
prist\u00fapi\u0165 k\u00a0met\u00f3de alebo atrib\u00fatu objektu, ktor\u00fd nie
je in\u0161tanciou a\u00a0teda nem\u00e1 met\u00f3dy ani atrib\u00faty.

cannot inherit from final *
Odvodzovanie od fin\u00e1lnej triedy \u00ab\u2026\u00bb nie je mo\u017en\u00e9.
 
Rodi\u010dovsk\u00e1 trieda (t.\u00a0j. trieda, od ktorej bola t\u00e1to trieda
odvoden\u00e1 a\u00a0ktor\u00e1 je uveden\u00e1 za k\u013e\u00fa\u010dov\u00fdm slovom \u201eextends\u201c)
je deklarovan\u00e1 ako fin\u00e1lna (rezervovan\u00fdm slovom \u201efinal\u201c),
\u010d\u00edm je zak\u00e1zan\u00e1 tvorba jej potomkov (dc\u00e9rskych tried).

* before supertype constructor has been called
\u00ab\u2026\u00bb bolo volan\u00e9 pred kon\u0161truktorom rodi\u010dovskej triedy.
 
Ak chcete pou\u017ei\u0165 volanie kon\u0161truktora nadradenej triedy:
    super(\u2026);
tak toto volanie mus\u00ed by\u0165 prv\u00fdm pr\u00edkazom v\u00a0kon\u0161truktore
odvodenej triedy (pri\u010dom namiesto \u2026 mus\u00edte doplni\u0165 spr\u00e1vne
parametre). Toto obmedzenie bolo do jazyka Java vlo\u017een\u00e9
preto, lebo pou\u017eitie ak\u00e9hoko\u013evek \u010dlena triedy pred t\u00fdmto volan\u00edm,
by zaru\u010dene prinieslo probl\u00e9my!

cannot return a value from method whose result type is void
Nie je mo\u017en\u00e9 vr\u00e1ti\u0165 hodnotu z\u00a0met\u00f3dy, ktor\u00e1 nem\u00e1 n\u00e1vratov\u00fd typ (je \u201evoid\u201c).
 
Deklar\u00e1cia met\u00f3dy bez n\u00e1vratov\u00e9ho typu (\u201evoid\u201c) znamen\u00e1, \u017ee t\u00e1to
met\u00f3da nevracia \u017eiadnu hodnotu. V\u00a0tele met\u00f3dy bez n\u00e1vratov\u00e9ho
typu (\u201evoid\u201c) je mo\u017en\u00e9 pou\u017ei\u0165 len \u201ehol\u00fd\u201c pr\u00edkaz \u201ereturn;\u201c, t.\u00a0j. bez
udania n\u00e1vratovej hodnoty.

cannot select a static class from a parameterized type
Z\u00a0parametrizovan\u00e9ho typu nie je mo\u017en\u00e9 vybra\u0165 statick\u00fa triedu.
 
Podrobnej\u0161\u00ed pomocn\u00edk nie je k\u00a0dispoz\u00edcii.

* cannot be inherited with different arguments:*
\u00ab\u2026\u00bb nem\u00f4\u017ee by\u0165 odvoden\u00e9 s\u00a0odli\u0161n\u00fdmi parametrami: \u00ab\u2026\u00bb
 
Podrobnej\u0161\u00ed pomocn\u00edk nie je k\u00a0dispoz\u00edcii.

'catch' without 'try'
Bol pou\u017eit\u00fd pr\u00edkaz \u201ecatch\u201c bez predch\u00e1dzaj\u00faceho \u201etry\u201c.
 
\u201ecatch\u201c je k\u013e\u00fa\u010dov\u00e9 slovo, ktor\u00e9 m\u00f4\u017ee by\u0165 pou\u017eit\u00e9 len
po bloku \u201etry\u201c. Spr\u00e1vne pou\u017eitie:
  try {
    pr\u00edkazy \u2026
  }
  catch (Exception e) {
    pr\u00edkazy \u2026
  }

* clashes with package of same name
\u00ab\u2026\u00bb koliduje s\u00a0rovnako nazvan\u00fdm bal\u00ed\u010dkom.
 
Uistite sa, \u017ee trieda a\u00a0bal\u00ed\u010dek, v\u00a0ktorom je trieda umiesten\u00e1,
maj\u00fa rozdielne n\u00e1zvy. Pod\u013ea konvencie by mali n\u00e1zvy tried
za\u010d\u00edna\u0165 ve\u013ek\u00fdmi p\u00edsmenami a\u00a0n\u00e1zvy bal\u00ed\u010dkov by mali
obsahova\u0165 len mal\u00e9 p\u00edsmen\u00e1.

code too large for try statement
K\u00f3d vo vn\u00fatri bloku \u201etry\u201c je pr\u00edli\u0161 dlh\u00fd.
 
Vo vn\u00fatri tohto bloku \u201etry\u201c je pr\u00edli\u0161 ve\u013ek\u00fd objem zdrojov\u00e9ho k\u00f3du.
Presu\u0148te obsah bloku (alebo jeho \u010das\u0165) do samostatnej met\u00f3dy
a\u00a0t\u00fa n\u00e1sledne zavolajte v\u00a0r\u00e1mci tohto bloku.

constant expression required
Je vy\u017eadovan\u00fd kon\u0161tantn\u00fd v\u00fdraz.
 
Pou\u017eili ste premenn\u00fa alebo v\u00fdraz, av\u0161ak ani jedno nie je
na tomto mieste povolen\u00e9. Tu je vy\u017eadovan\u00e9 pou\u017eitie
kon\u0161tantn\u00e9ho v\u00fdrazu (ktor\u00fd je mo\u017en\u00e9 vyhodnoti\u0165 u\u017e po\u010das
prekladu). Kon\u0161tantn\u00e9 v\u00fdrazy s\u00fa bu\u010f liter\u00e1ly (napr\u00edklad
\u010d\u00edseln\u00e9: 42) alebo identifik\u00e1tory deklarovan\u00e9 ako \u201efinal\u201c.

continue outside of loop
Pr\u00edkaz \u201econtinue\u201c bol pou\u017eit\u00fd mimo cyklu.
 
Pr\u00edkaz \u201econtinue\u201c je pou\u017e\u00edvan\u00fd na okam\u017eit\u00e9 spustenie
\u010fal\u0161ej iter\u00e1cie (opakovania) cyklu. Mimo cyklu nem\u00e1
tento pr\u00edkaz v\u00fdznam. M\u00f4\u017ee by\u0165 pou\u017eit\u00fd len vo vn\u00fatri
cyklu \u201efor\u201c, \u201ewhile\u201c a\u00a0\u201edo\u201c.

cyclic inheritance involving *
Cyklick\u00e1 dedi\u010dnos\u0165 v\u00a0\u00ab\u2026\u00bb.
 
Pok\u00fasili ste sa odvodi\u0165 triedu od triedy, ktor\u00e1 je sama
od tejto triedy odvoden\u00e1! In\u00fdmi slovami: usilujete sa,
aby rodi\u010d bol potomkom svojho potomka. Mus\u00edte sa rozhodn\u00fa\u0165,
ktor\u00e1 trieda bude rodi\u010d a\u00a0ktor\u00e1 potomok.

* does not exist
\u00ab\u2026\u00bb nejestvuje.
 
Pravdepodobne ste na tomto mieste chceli pou\u017ei\u0165 n\u00e1zov
premennej alebo triedy, av\u0161ak \u017eiadna premenn\u00e1,
trieda ani bal\u00ed\u010dek s\u00a0tak\u00fdmto n\u00e1zvom nejestvuje.

duplicate class:*
Duplicit\u00e1 trieda: \u00ab\u2026\u00bb
 
Trieda sa rovnak\u00fdm n\u00e1zvom u\u017e jestvuje.

duplicate case label
Duplicitn\u00e1 menovka \u201ecase\u201c.
 
Vo vn\u00fatri bloku \u201eswitch\u201c ste pou\u017eili dvakr\u00e1t rovnak\u00fa
menovku \u201ecase\u201c. To nie je pr\u00edpustn\u00e9.

duplicate default label
Duplicitn\u00e1 predvolen\u00e1 menovka (\u201edefault\u201c).
 
Vo vn\u00fatri bloku \u201eswitch\u201c m\u00f4\u017ee by\u0165 len jedna
predvolen\u00e1 menovka (\u201edefault\u201c).

'else' without 'if'
Bolo pou\u017eit\u00e9 \u201eelse\u201c bez predch\u00e1dzaj\u00faceho \u201eif\u201c.
 
K\u013e\u00fa\u010dov\u00e9 slovo \u201eelse\u201c m\u00f4\u017ee by\u0165 pou\u017eit\u00e9 len ako s\u00fa\u010das\u0165 pr\u00edkazu \u201eif\u201c.
Pr\u00edklad:
  if (podmienka)
    pr\u00edkaz;
  else
    pr\u00edkaz;
Mo\u017eno\u017ee ste neuviedli spr\u00e1vny po\u010det zlo\u017een\u00fdch z\u00e1tvoriek.
\u010castou pr\u00ed\u010dinou tejto chyby je situ\u00e1cia, kedy chcete vo vetve if
vykona\u0165 nieko\u013eko pr\u00edkazov, ale zabudnete ste ich zatvori\u0165 do
zlo\u017een\u00fdch z\u00e1tvoriek. Takto:
  if (podmienka)
  {
    pr\u00edkaz1;
    pr\u00edkaz2;
  }
  else
    pr\u00edkaz3;
(Podobn\u00fa chybu m\u00f4\u017eete urobi\u0165 aj pri vetve else, ale vtedy
nemus\u00ed vznikn\u00fa\u0165 chyba pri preklade.)

empty character literal
Pr\u00e1zdny znakov\u00fd liter\u00e1l.
 
Zap\u00edsali ste znakov\u00fd liter\u00e1l, ktor\u00fd je pr\u00e1zdny. Pou\u017eitie '' nie je
povolen\u00e9. Znakov\u00e9 liter\u00e1ly s\u00fa uv\u00e1dzan\u00e9 v\u00a0tvare 'a'. Medzi
apostrofmi sa nach\u00e1dza v\u017edy pr\u00e1ve jeden znak. Jedinou
v\u00fdnimkou s\u00fa \u0161peci\u00e1lne znaky p\u00edsan\u00e9 pomocou sp\u00e4tnej lomky
(takzvan\u00e9 \u201eescape characters\u201c \u2013 escape sekvencie). Napr\u00edklad
nov\u00fd riadok '\n', tabul\u00e1tor '\t' at\u010f.

* has already been caught
\u00ab\u2026\u00bb v\u00fdnimka u\u017e bola zachyten\u00e1.
 
Tento blok \u201ecatch\u201c je zbyto\u010dn\u00fd, preto\u017ee v\u0161etky v\u00fdnimky boli
na tomto mieste u\u017e zachyten\u00e9 pr\u00edslu\u0161n\u00fdmi in\u00fdmi blokmi \u201ecatch\u201c.
To znamen\u00e1, \u017ee na toto miesto sa vykon\u00e1vanie programu pri
obsluhe v\u00fdnimiek nikdy nedostane.

* is never thrown in body of corresponding try statement
T\u00e1to v\u00fdnimka: \u00ab\u2026\u00bb, nikdy nevznikne vo vn\u00fatri tohto bloku \u201etry\u201c.
 
Pok\u00fasili ste sa zachyti\u0165 v\u00fdnimku vo vn\u00fatri bloku \u201etry\u201c, av\u0161ak
\u017eiadny pr\u00edkaz vo vn\u00fatri tohto bloku tak\u00fato v\u00fdnimku negeneruje.
Je zaru\u010den\u00e9, \u017ee t\u00e1to v\u00fdnimka na tomto mieste nikdy nevznikne.

'finally' without 'try'
Bolo pou\u017eit\u00e9 \u201efinally\u201c bez predch\u00e1dzaj\u00faceho \u201etry\u201c.
 
\u201efinally\u201c je k\u013e\u00fa\u010dov\u00e9 slovo, ktor\u00e9 m\u00f4\u017ee by\u0165 pou\u017eit\u00e9 len
po bloku \u201etry\u201c. Spr\u00e1vne pou\u017eitie vyzer\u00e1 napr\u00edklad takto:
  try {
    pr\u00edkazy;
  }
  catch (Exception e) {
    pr\u00edkazy;
  }
  finally {
    pr\u00edkazy;
  }

floating point number too large
Zadan\u00e9 desatinn\u00e9 \u010d\u00edslo je pr\u00edli\u0161 ve\u013ek\u00e9.
 
Syst\u00e9m nedok\u00e1\u017ee pracova\u0165 s\u00a0tak\u00fdmito
ve\u013ek\u00fdmi desatinn\u00fdmi \u010d\u00edslami.

floating point number too small
Zadan\u00e9 desatinn\u00e9 \u010d\u00edslo je pr\u00edli\u0161 mal\u00e9.
 
Syst\u00e9m nedok\u00e1\u017ee pracova\u0165 s\u00a0tak\u00fdmito
mal\u00fdmi desatinn\u00fdmi \u010d\u00edslami.

inner classes cannot have static declarations
Vn\u00fatorn\u00e1 trieda nem\u00f4\u017ee obsahova\u0165 statick\u00e9 deklar\u00e1cie.
 
Vn\u00fatorn\u00e1 trieda nem\u00f4\u017ee obsahova\u0165 deklar\u00e1cie statick\u00fdch
\u010dlenov ak nie je sama statick\u00e1. Ak potrebujete pou\u017ei\u0165 statick\u00fd
atrib\u00fat alebo met\u00f3du vo vn\u00fatornej triede, rozmyslite si, \u010di
je nevyhnutn\u00e9, aby bola t\u00e1to trieda implementovan\u00e1 vn\u00fatorne,
alebo (ak je to mo\u017en\u00e9) sk\u00faste definova\u0165 po\u017eadovan\u00fd atrib\u00fat \u010di
met\u00f3du vo vonkaj\u0161ej triede, pr\u00edpadne definujte vn\u00fatorn\u00fa triedu
ako statick\u00fa.

illegal character:*
Neplatn\u00fd znak: \u00ab\u2026\u00bb
 
Na tomto riadku sa v\u00a0zdrojovom k\u00f3de nach\u00e1dza neplatn\u00fd
(nepovolen\u00fd) znak. Tento znak nemus\u00ed by\u0165 vidite\u013en\u00fd. Ak ho
nem\u00f4\u017eete n\u00e1js\u0165, odstr\u00e1\u0148te cel\u00fd riadok a\u00a0nap\u00ed\u0161te ho odznova.

illegal combination of modifiers: *
Zak\u00e1zan\u00e1 kombin\u00e1cia modifik\u00e1torov: \u00ab\u2026\u00bb
 
Pou\u017eili ste zak\u00e1zan\u00fa kombin\u00e1ciu modifik\u00e1torov. To znamen\u00e1,
\u017ee modifik\u00e1tory sa navz\u00e1jom vylu\u010duj\u00fa. Pr\u00edkladom s\u00fa kombin\u00e1cie
modifik\u00e1torov \u201eabstract\u201c s\u00a0niektor\u00fdm z\u00a0modifik\u00e1torov:
\u201enative\u201c, \u201efinal\u201c, \u201eprivate\u201c alebo \u201esynchronized\u201c.

illegal escape character
Neplatn\u00e1 escape sekvencia.
 
Escape sekvencie s\u00fa tvoren\u00e9 sp\u00e4tnou lomkou \u201e\\u201c
a\u00a0jedn\u00fdm p\u00edsmenom. S\u00fa pou\u017e\u00edvan\u00e9 na zadanie
\u0161peci\u00e1lnych znakov. Je definovan\u00e1 striktn\u00e1 mno\u017eina
znakov, ktor\u00fdch pou\u017eitie je povolen\u00e9 za znakom
sp\u00e4tnej lomky. S\u00fa to: \n, \t, \b, \r, \f, \\, \', \"
a\u00a0\u010d\u00edsla. Ak potrebujete pou\u017ei\u0165 samostatn\u00fd znak sp\u00e4tnej
lomky, zadajte re\u0165azec \u201e\\\u201c, ktor\u00fd bude vo v\u00fdslednom
re\u0165azci nahraden\u00fd jedinou sp\u00e4tnou lomkou.

illegal forward reference
Nie je povolen\u00e1 referencia v\u00a0predstihu.
 
Podrobnej\u0161\u00ed pomocn\u00edk nie je k\u00a0dispoz\u00edcii.

illegal initializer for *
Nepovolen\u00fd incializ\u00e1tor pre \u00ab\u2026\u00bb.
 
Podrobnej\u0161\u00ed pomocn\u00edk nie je k\u00a0dispoz\u00edcii.

illegal line end in character literal
Neplatn\u00fd koniec riadka vo vn\u00fatri znakov\u00e9ho liter\u00e1lu.
 
Zadali ste koniec riadka na miesto, kde by mala by\u0165
uveden\u00e1 defin\u00edcia znakov\u00e9ho liter\u00e1lu. Toto nie je
povolen\u00e9. Ak chcete zada\u0165 znak nov\u00e9ho riadka, pou\u017eite
sekvenciu \u201e\n\u201c.

illegal qualifier; {0} is not an inner class
Nepovolen\u00fd kvalifik\u00e1tor; \u00ab\u2026\u00bb nie je vn\u00fatorn\u00e1 trieda.
 
Podrobnej\u0161\u00ed pomocn\u00edk nie je k\u00a0dispoz\u00edcii.

illegal start of expression
Zak\u00e1zan\u00fd za\u010diatok v\u00fdrazu.
 
Na tejto poz\u00edcii, je o\u010dak\u00e1van\u00fd za\u010diatok v\u00fdrazu, ale nach\u00e1dza
sa tu nie\u010do in\u00e9. Pravdepodobne je v\u00a0predch\u00e1dzaj\u00facom
k\u00f3de nie\u010do navy\u0161e alebo nie\u010do ch\u00fdba.

illegal start of type
Zak\u00e1zan\u00fd za\u010diatok typu.
 
Na tejto poz\u00edcii, je o\u010dak\u00e1van\u00fd n\u00e1zov \u00fadajov\u00e9ho typu,
ale nach\u00e1dza sa tu nie\u010do in\u00e9 (pravdepodobne k\u013e\u00fa\u010dov\u00e9
slovo jazyka Java). Je mo\u017en\u00e9, \u017ee v\u00a0predch\u00e1dzaj\u00facom
k\u00f3de nie\u010do ch\u00fdba alebo je tam uveden\u00e9 nie\u010do navy\u0161e.
Skontrolujte spr\u00e1vnos\u0165 defin\u00edcie typu.

illegal unicode escape
Zak\u00e1zan\u00fd z\u00e1pis znaku tabu\u013eky unicode.
 
Podrobnej\u0161\u00ed pomocn\u00edk nie je k\u00a0dispoz\u00edcii.

improperly formed type, some parameters are missing
Nekorektne utvoren\u00fd typ, niektor\u00e9 parametre ch\u00fdbaj\u00fa.
 
Podrobnej\u0161\u00ed pomocn\u00edk nie je k\u00a0dispoz\u00edcii.

incomparable types: *
Nasleduj\u00face typy nie je mo\u017en\u00e9 porovn\u00e1va\u0165: \u00ab\u2026\u00bb
 
Podrobnej\u0161\u00ed pomocn\u00edk nie je k\u00a0dispoz\u00edcii.

integer number too large: *
Cel\u00e9 \u010d\u00edslo je pr\u00edli\u0161 ve\u013ek\u00e9: \u00ab\u2026\u00bb
 
Zadali ste cel\u00e9 \u010d\u00edslo, ktor\u00e9 je pr\u00edli\u0161 ve\u013ek\u00e9 na to, aby bolo
ulo\u017een\u00e9 do \u00fadajov\u00e9ho typu, ktor\u00fd je o\u010dak\u00e1van\u00fd na tomto
mieste. Na ulo\u017eenie v\u00e4\u010d\u0161ieho \u010d\u00edsla mus\u00edte pou\u017ei\u0165 \u00fadajov\u00fd
typ s\u00a0v\u00e4\u010d\u0161\u00edm rozsahom. (Napr\u00edklad \u201elong\u201c namiesto \u201eint\u201c.)

internal error; cannot instantiate *
Vn\u00fatorn\u00e1 chyba; nie je mo\u017en\u00e9 vytvori\u0165 in\u0161tanciu \u00ab\u2026\u00bb.
 
Podrobnej\u0161\u00ed pomocn\u00edk nie je k\u00a0dispoz\u00edcii.

* but with different return type
\u00ab\u2026\u00bb sa vyskytlo s\u00a0in\u00fdm n\u00e1vratov\u00fdm typom.
 
Pok\u00fa\u0161ate sa kombinova\u0165 met\u00f3dy, ktor\u00e9 vyzeraj\u00fa takmer rovnako. Odli\u0161uj\u00fa sa len
n\u00e1vratov\u00fdm typom. Toto v\u0161ak nie je povolen\u00e9. T\u00e1to chyba sa pravdepodobne
vyskytla preto, lebo sa pok\u00fa\u0161ate implementova\u0165 dve r\u00f4zne rozhrania v\u00a0jednej
triede, pri\u010dom ka\u017ed\u00e9 z\u00a0rozhran\u00ed rozhranie deklaruje met\u00f3du s\u00a0rovnak\u00fdm n\u00e1zvom
a\u00a0parametrami, ale s\u00a0rozdielnym n\u00e1vratov\u00fdm typom. V\u00a0takomto pr\u00edpade je
implement\u00e1cia oboch rozhran\u00ed s\u00fa\u010dasne nemo\u017en\u00e1. Rie\u0161en\u00edm je \u00faprava niektor\u00e9ho
z\u00a0rozhran\u00ed bu\u010f zmenou n\u00e1vratov\u00e9ho typu jednej z\u00a0konfliktn\u00fdch met\u00f3d, alebo
premenovan\u00edm jednej z\u00a0nich (ak je to mo\u017en\u00e9 \u2013 t.\u00a0j. ak aspo\u0148 jedno rozhranie
nie je vstavan\u00fdm rozhran\u00edm Javy a\u00a0ak m\u00e1te k\u00a0dispoz\u00edcii jeho zdrojov\u00fd k\u00f3d).

interface expected here
Na tomto mieste je o\u010dak\u00e1van\u00e9 rozhranie.
 
Rozhranie (interface) m\u00f4\u017ee by\u0165 odvoden\u00e9 len z\u00a0in\u00e9ho
rozhrania. N\u00e1zov, ktor\u00fd ste uviedli za k\u013e\u00fa\u010dov\u00fdm slovom
\u201eextends\u201c neozna\u010duje rozhranie.

interface methods cannot have body
Met\u00f3dy rozhrania nem\u00f4\u017eu obsahova\u0165 telo.
 
Rozhrania sm\u00fa obsahova\u0165 len deklar\u00e1cie met\u00f3d a\u00a0s\u00fa\u010das\u0165ou
deklar\u00e1cie nie je telo met\u00f3dy. Deklar\u00e1cia met\u00f3dy pozost\u00e1va
len z\u00a0hlavi\u010dky ukon\u010denej bodko\u010diarkou.

hexadecimal numbers must contain at least one hexadecimal digit
Hexadecim\u00e1lne \u010d\u00edsla musia obsahova\u0165 aspo\u0148 jednu hexadecim\u00e1lnu \u010d\u00edslicu.
 
Na tomto mieste bol n\u00e1jden\u00fd za\u010diatok z\u00e1pisu \u010d\u00edsla v\u00a0hexadecim\u00e1lnej
(\u0161estn\u00e1stkovej) \u010d\u00edselnej s\u00fastave (za\u010d\u00edna re\u0165azcom \u201e0X\u201c). Za \u201eX\u201c mus\u00ed
nasledova\u0165 aspo\u0148 jedna platn\u00e1 \u010d\u00edslica hexadecim\u00e1lnej \u010d\u00edselnej s\u00fastavy
(0 \u2013 9, A\u00a0\u2013 F).

invalid method declaration; return type required
Neplatn\u00e1 deklar\u00e1cia met\u00f3dy; je vy\u017eadovan\u00fd n\u00e1vratov\u00fd \u00fadajov\u00fd typ.
 
Pri deklar\u00e1cii met\u00f3dy mus\u00ed by\u0165 uveden\u00fd n\u00e1vratov\u00fd \u00fadajov\u00fd typ.
Napr\u00edklad, ak si \u017eel\u00e1te, aby met\u00f3da poskytovala hodnotu v\u00a0tvare
re\u0165azca (String), nap\u00ed\u0161te:
    public String mojaMet\u00f3da();
Ak si \u017eel\u00e1te, aby met\u00f3da neposkytovala \u017eiadnu n\u00e1vratov\u00fa hodnotu,
\u0161pecifikujte to k\u013e\u00fa\u010dov\u00fdm slovom \u201evoid\u201c. Pr\u00edklad:
    public void mojaMet\u00f3da();

* already in use
\u00ab\u2026\u00bb u\u017e bolo pou\u017eit\u00e9.
 
V\u00a0tejto met\u00f3de u\u017e jestvuje premenn\u00e1 (pr\u00edpadne parameter)
s\u00a0rovnak\u00fdm n\u00e1zvom. Pou\u017eite pre \u0148u in\u00fd n\u00e1zov. (Mo\u017eno ste
chceli na tomto mieste t\u00fato premenn\u00fa pou\u017ei\u0165. V\u00a0tom pr\u00edpade
odstr\u00e1\u0148te ur\u010denie typu pred n\u00e1zvom premennej, aby to
nevyzeralo ako deklar\u00e1cia novej premennej.)

* is accessed from within inner class; needs to be declared final
Bol zaznamenan\u00fd pokus o\u00a0pr\u00edstup k\u00a0\u00ab\u2026\u00bb z\u00a0vn\u00fatornej triedy; preto by mala by\u0165 deklarovan\u00e1 ako fin\u00e1lna (\u201efinal\u201c).
 
Pok\u00fasili ste sa prist\u00fapi\u0165 k\u00a0premennej z\u00a0vn\u00fatornej triedy, len\u017ee lok\u00e1lne
premenn\u00e9 nem\u00f4\u017eu by\u0165 \u010d\u00edtan\u00e9 alebo zapisovan\u00e9 t\u00fdmto sp\u00f4sobom. M\u00e1te
nieko\u013eko mo\u017enost\u00ed na vyrie\u0161enie tohto probl\u00e9mu: bu\u010f deklarujete premenn\u00fa
ako fin\u00e1lnu (\u201efinal\u201c), alebo ju deklarujte na inom mieste (nie ako lok\u00e1lnu),
alebo sa k\u00a0premennej nepok\u00fa\u0161ajte pristupova\u0165 z\u00a0vn\u00fatornej triedy.

malformed floating point literal
Liter\u00e1l \u010d\u00edsla s\u00a0pohyblivou r\u00e1dovou \u010diarkou je v\u00a0nespr\u00e1vnom tvare.
 
V\u00a0z\u00e1pise \u010d\u00edsla s\u00a0pohyblivou r\u00e1dovou \u010diarkou sa nach\u00e1dza chyba. (\u010c\u00edslo
s\u00a0pohyblivou r\u00e1dovou \u010diarkou je \u010d\u00edslo spravidla zap\u00edsan\u00e9 v\u00a0desiatkovej
s\u00fastave, ktor\u00e9 m\u00f4\u017ee na spr\u00e1vnom mieste obsahova\u0165 znak ozna\u010duj\u00faci
desatinn\u00fa \u010diarku. T\u00e1 je v\u00a0angli\u010dtine reprezentovan\u00e1 znakom bodky.)
Tu s\u00fa pr\u00edklady spr\u00e1vneho z\u00e1pisu \u010d\u00edsla s\u00a0pohyblivou r\u00e1dovou \u010diarkou:
18.0      18.     1.8e1     .18E2

missing method body, or declare abstract
Ch\u00fdba telo met\u00f3dy, dopl\u0148te ho alebo deklarujte met\u00f3du ako abstraktn\u00fa.
 
Met\u00f3dy musia ma\u0165 definovan\u00e9 telo s\u00a0k\u00f3dom na vykonanie alebo by\u0165
deklarovan\u00e9 ako abstraktn\u00e9. Telo met\u00f3dy b\u00fdva uveden\u00e9 v\u00a0zlo\u017een\u00fdch
z\u00e1tvork\u00e1ch { } a\u00a0b\u00fdva uveden\u00e9 za hlavi\u010dkou deklar\u00e1cie met\u00f3dy. Telo
obsahuje pr\u00edkazy a\u00a0ak met\u00f3da nem\u00e1 obsahova\u0165 \u017eiadne telo, mus\u00ed by\u0165
deklarovan\u00e1 ako abstraktn\u00e1 (\u201eabstract\u201c). Napr\u00edklad:
    public abstract int poskytniOdpove\u010f();

missing return statement
Nebol n\u00e1jden\u00fd pr\u00edkaz \u201ereturn\u201c.
 
T\u00e1to met\u00f3da m\u00e1 v\u00a0deklar\u00e1cii uveden\u00e9, \u017ee m\u00e1 poskytova\u0165
n\u00e1vratov\u00fa hodnotu. Na tento \u00fa\u010del sl\u00fa\u017ei pr\u00edkaz \u201ereturn\u201c,
ktor\u00fd nebol v\u00a0tele met\u00f3dy n\u00e1jden\u00fd. To nie je spr\u00e1vne.
Bu\u010f mus\u00edte deklarova\u0165 met\u00f3du tak, aby nemusela poskytova\u0165
\u017eiadnu n\u00e1vratov\u00fa hodnotu (k\u013e\u00fa\u010dov\u00fdm slovom \u201evoid\u201c):
    public void bezHodnoty() \u2026
alebo na konci tela met\u00f3dy uve\u010fte pr\u00edkaz \u201ereturn\u201c vr\u00e1tane
korektnej n\u00e1vratovej hodnoty \u2013 t\u00e1 mus\u00ed kore\u0161pondova\u0165
s\u00a0n\u00e1vratov\u00fdm typom uveden\u00fdm v\u00a0deklar\u00e1cii hlavi\u010dky met\u00f3dy.
Ak m\u00e1 napr\u00edklad met\u00f3da ako n\u00e1vratov\u00fd typ cel\u00e9 \u010d\u00edslo (\u201eint\u201c), tak
pr\u00edkaz \u201ereturn\u201c s\u00a0n\u00e1vratovou hodnotou m\u00f4\u017ee vyzera\u0165 takto:
    return 42;

missing return value
Ch\u00fdbaj\u00faca n\u00e1vratov\u00e1 hodnota.
 
Zap\u00edsali ste pr\u00edkaz \u201ereturn\u201c bez n\u00e1vratovej hodnoty.
Toto je povolen\u00e9 len pri met\u00f3dach, ktor\u00e9 neposkytuj\u00fa
\u017eiadnu n\u00e1vratov\u00fa hodnotu (s\u00fa deklarovan\u00e9 ako \u201evoid\u201c).
To v\u0161ak nie je pr\u00edpad tejto met\u00f3dy, preto\u017ee v\u00a0hlavi\u010dke
je deklarovan\u00e9, \u017ee m\u00e1 poskytova\u0165 n\u00e1vratov\u00fa hodnotu
ur\u010dit\u00e9ho \u00fadajov\u00e9ho typu. Bu\u010f deklarujte t\u00fato met\u00f3du
ako \u201evoid\u201c, alebo uve\u010fte prisl\u00fachaj\u00facu n\u00e1vratov\u00fa hodnotu
za pr\u00edkazom \u201ereturn\u201c. Pr\u00edklady:
    return 42;    // met\u00f3da s\u00a0celo\u010d\u00edseln\u00fdm n\u00e1vratov\u00fdm typom
alebo
    return "Marvin";    // n\u00e1vratov\u00fd typ re\u0165azec (\u201eString\u201c)

name clash: *
Rozpor v\u00a0n\u00e1zvoch: \u00ab\u2026\u00bb
 
Definovali ste dve met\u00f3dy s\u00a0rovnak\u00fdm n\u00e1zvom. Toto je dovolen\u00e9
len v\u00a0pr\u00edpade vyu\u017eitia druhu polymorfizmu nazvan\u00e9ho pre\u0165a\u017eovanie
(overloading \u2013 \u010do nie je tento pr\u00edpad). N\u00e1zov jednej z\u00a0met\u00f3d mus\u00edte
zmeni\u0165.

* is reserved for internal use
\u00ab\u2026\u00bb je rezervovan\u00e9 na vn\u00fatorn\u00e9 pou\u017eitie.
 
Uveden\u00fd v\u00fdraz je rezervovan\u00fd na vn\u00fatorn\u00e9 pou\u017eitie, ak je
to n\u00e1zov premennej alebo triedy, tak ho mus\u00edte zmeni\u0165.

native methods cannot have a body
Nat\u00edvne met\u00f3dy nem\u00f4\u017eu obsahova\u0165 telo.
 
Deklarovali ste nat\u00edvnu met\u00f3du a\u00a0z\u00e1rove\u0148 ste nap\u00edsali k\u00f3d jej tela.
Deklar\u00e1cie nat\u00edvnych met\u00f3d sm\u00fa obsahova\u0165 len hlavi\u010dku deklar\u00e1cie
met\u00f3dy, ktor\u00e1 m\u00e1 by\u0165 ukon\u010den\u00e1 bodko\u010diarkou. Bu\u010f odstr\u00e1\u0148te
modifik\u00e1tor \u201enative\u201c, alebo odstr\u00e1\u0148te telo met\u00f3dy.

no enclosing instance of type {0} is in scope
In\u0161tancia typu \u00ab\u2026\u00bb nie je dostupn\u00e1 v\u00a0tomto zornom poli.
 
Podrobnej\u0161\u00ed pomocn\u00edk nie je k\u00a0dispoz\u00edcii.

no interface expected here
Na tomto mieste nie je o\u010dak\u00e1van\u00e9 rozhranie.
 
Pok\u00fa\u0161ate sa pou\u017ei\u0165 rozhranie (napr\u00edklad za k\u013e\u00fa\u010dov\u00fdm slovom \u201eextends\u201c
pri deklar\u00e1cii triedy). Trieda m\u00f4\u017ee by\u0165 odvoden\u00e1 len od inej triedy, nie
od rozhrania. Ak chcete implementova\u0165 (o\u017eivi\u0165) toto rozhranie mus\u00edte
namiesto slova \u201eextends\u201c (\u201eroz\u0161iruje\u201c, t.\u00a0j. \u201eded\u00ed\u201c, resp. \u201eje odvoden\u00e1
od\u201c) pou\u017ei\u0165 slovo \u201eimplements\u201c (\u201eimplementuje\u201c, t.\u00a0j. \u201eo\u017eivuje\u201c).

{0} has no match in entry in {1}; required {2}
\u00ab\u2026\u00bb nie je zhodn\u00e9 so \u017eiadnou polo\u017ekou v\u00a0\u00ab\u2026\u00bb; je po\u017eadovan\u00e9 \u00ab\u2026\u00bb
 
Podrobnej\u0161\u00ed pomocn\u00edk nie je k\u00a0dispoz\u00edcii.

* is not defined in a public class or interface; cannot be accessed from outside package
\u00ab\u2026\u00bb nie je definovan\u00e9 vo verejnej triede alebo rozhran\u00ed; pr\u00edstup k\u00a0nemu je zvonka bal\u00ed\u010dka je zamietnut\u00fd.
 
Podrobnej\u0161\u00ed pomocn\u00edk nie je k\u00a0dispoz\u00edcii.

* cannot be accessed from outside package
\u00ab\u2026\u00bb nie je dostupn\u00e9 zvonka bal\u00ed\u010dka.
 
Trieda, ktor\u00fa ste sa pok\u00fasili pou\u017ei\u0165, nie je verejn\u00e1.
To znamen\u00e1, \u017ee jej defin\u00edcia sa neza\u010d\u00edna takto:
    public class \u2026
Triedy, ktor\u00e9 nie s\u00fa verejn\u00e9, nie s\u00fa zvonka bal\u00ed\u010dka
dostupn\u00e9. Ak chcete skuto\u010dne pou\u017ei\u0165 triedu zvonka
bal\u00ed\u010dka, mus\u00edte zmeni\u0165 jej defin\u00edciu (ak na to m\u00e1te
pr\u00e1vo) a\u00a0deklarova\u0165 ju ako verejn\u00fa.

not a loop label: *
Toto nie je menovka cyklu: \u00ab\u2026\u00bb
 
Menovka, na ktor\u00fa ste sa odvolali v\u00a0tele cyklu napr\u00edklad
nasleduj\u00facim sp\u00f4sobom:
    continue \u00abmenovka\u00bb;
nebola definovan\u00e1 tak, aby mohla by\u0165 pou\u017eit\u00e1 v\u00a0tele cyklu.
Na to, aby mohla by\u0165 menovka pou\u017eit\u00e1 v\u00a0tele cyklu, mus\u00ed by\u0165
umiestnen\u00e1 tesne pred za\u010diatkom cyklu. Menovka, ktor\u00fa ste
pou\u017eili, nie je spr\u00e1vne umiestnen\u00e1 \u2013 neozna\u010duje cyklus.

not a statement
Toto nie je pr\u00edkaz.
 
Nap\u00edsali ste riadok k\u00f3du, ktor\u00fd nie je \u00fapln\u00fdm pr\u00edkazom. Overte
tento riadok k\u00f3du a\u00a0zv\u00e1\u017ete, \u010do ste mali v\u00a0\u00famysle nap\u00edsa\u0165.

not an enclosing class:*
Toto nie je nadraden\u00e1 trieda: \u00ab\u2026\u00bb
 
Pok\u00fasili ste sa (cez k\u013e\u00fa\u010dov\u00e9 slovo \u201ethis\u201c) prist\u00fapi\u0165 k\u00a0in\u0161tancii takej triedy,
ktor\u00e1 je definovan\u00e1 zvonka tejto triedy (mimo nej). Tak\u00fdto sp\u00f4sob pou\u017eitia
je dovolen\u00fd len pre triedy, ktor\u00e9 s\u00fa priamo nadraden\u00e9 tejto triede. To
znamen\u00e1 len triedam, vo vn\u00fatri ktor\u00fdch je definovan\u00e1 t\u00e1to trieda. (In\u00fdmi
slovami, pomocou \u201ethis\u201c m\u00f4\u017eete pristupova\u0165 nanajv\u00fd\u0161 k\u00a0triedam, ktor\u00e9
t\u00fato triedu \u201eoba\u013euj\u00fa\u201c. K\u00a0\u017eiadnym in\u00fdm.)

* cannot be applied to *
\u00ab\u2026\u00bb nem\u00f4\u017ee by\u0165 pou\u017eit\u00e9 na \u00ab\u2026\u00bb.
 
Oper\u00e1tor, ktor\u00fd ste na tomto mieste pou\u017eili, nem\u00f4\u017ee by\u0165 pou\u017eit\u00fd na
hodnoty tohto \u00fadajov\u00e9ho typu (na ktor\u00fd sa ho pok\u00fa\u0161ate aplikova\u0165).
Bu\u010f ste pou\u017eili nespr\u00e1vny \u00fadajov\u00fd typ, alebo nespr\u00e1vny oper\u00e1tor.

* clashes with class of same name
\u00ab\u2026\u00bb je v\u00a0rozpore s\u00a0triedou s\u00a0rovnak\u00fdm n\u00e1zvom.
 
Uistite sa, \u017ee n\u00e1zvy tejto triedy a\u00a0aktu\u00e1lneho bal\u00ed\u010dka s\u00fa rozdielne.
Obvykle je zau\u017e\u00edvan\u00e9, \u017ee n\u00e1zvy tried za\u010d\u00ednaj\u00fa ve\u013ek\u00fdmi p\u00edsmenami
a\u00a0n\u00e1zvy bal\u00ed\u010dkov za\u010d\u00ednaj\u00fa mal\u00fdmi p\u00edsmenami.

possible fall-through into case
Hroz\u00ed vykonanie viacer\u00fdch vetiev naraz!
 
Ak neuzatvor\u00edte ka\u017ed\u00fa vetvu (\u201ecase\u201c) \u0161trukt\u00fary \u201eswitch\u201c pr\u00edkazom
\u201ebreak\u201c, je mo\u017en\u00e9, \u017ee bude vo va\u0161om programe vykonan\u00fdch nieko\u013eko
vetiev naraz, \u010do je vo v\u00e4\u010d\u0161ine pr\u00edpadov ne\u017eiaduce. Overte, \u010di ste
nezabudli na konci niektorej vetvy uvies\u0165 k\u013e\u00fa\u010dov\u00e9 slovo \u201ebreak\u201c!

error reading *
Nastala chyba pri \u010d\u00edtan\u00ed \u00ab\u2026\u00bb
 
Podrobnej\u0161\u00ed pomocn\u00edk nie je k\u00a0dispoz\u00edcii.

recursive constructor invocation
Vzniklo rekurz\u00edvne volanie kon\u0161truktora.
 
Telo kon\u0161truktora obsahuje rekurz\u00edvne
volanie seba sam\u00e9ho. To nie je povolen\u00e9.

* is ambiguous, both *
\u00ab\u2026\u00bb je nejednozna\u010dn\u00e9, obe s\u00fa \u00ab\u2026\u00bb
 
Identifik\u00e1tor uveden\u00fd v\u00a0tejto spr\u00e1ve nem\u00f4\u017ee by\u0165 spr\u00e1vne
rozpoznan\u00fd, preto\u017ee v\u00a0bal\u00ed\u010dkoch, ktor\u00e9 ste importovali,
je definovan\u00fdch viacero tried alebo rozhran\u00ed s\u00a0rovnak\u00fdmi
n\u00e1zvami. Odvol\u00e1vajte sa na uveden\u00fa triedu \u00fapln\u00fdm n\u00e1zvom
(napr. v\u00a0tvare: \u201ejava.util.List\u201c), alebo importujte triedu
pod jej \u00fapln\u00fdm n\u00e1zvom (napr\u00edklad \u201eimport java.util.List\u201c).

repeated interface
Duplik\u00e1t rozhrania.
 
Uviedli ste dvakr\u00e1t to ist\u00e9 rozhranie v\u00a0tej istej deklar\u00e1cii \u201eimplements\u201c.
Raz \u00faplne sta\u010d\u00ed. Moja pam\u00e4\u0165 nie je a\u017e tak\u00e1 zl\u00e1! :-)

repeated modifier
Opakovan\u00fd v\u00fdskyt modifik\u00e1tora.
 
V\u00a0tejto deklar\u00e1cii je opakovane uveden\u00fd ten ist\u00fd
modifik\u00e1tor. Modifik\u00e1tory s\u00fa k\u013e\u00fa\u010dov\u00e9 slov\u00e1 ako
\u201efinal\u201c, \u201estatic\u201c, \u201epublic\u201c, \u201eprivate\u201c, \u201evolatile\u201c\u2026

{0} has {1} access in {2}
\u00ab\u2026\u00bb m\u00e1 \u00ab\u2026\u00bb pr\u00edstup v\u00a0\u00ab\u2026\u00bb
 
Podrobnej\u0161\u00ed pomocn\u00edk nie je k\u00a0dispoz\u00edcii.

return outside method
Bol n\u00e1jden\u00fd \u201ereturn\u201c mimo met\u00f3dy.
 
Pr\u00edkaz \u201ereturn\u201c smie by\u0165 pou\u017eit\u00fd len vo vn\u00fatri met\u00f3d.
Nesmie sa vyskytn\u00fa\u0165 v\u00a0inicializa\u010dnom bloku ani \u017eiadnej
inej \u010dasti zdrojov\u00e9ho k\u00f3du.

signature does not match {0}; incompatible interfaces
Ozna\u010denie nezodpoved\u00e1 \u00ab\u2026\u00bb; nekompatibiln\u00e9 rozhranie.
 
Podrobnej\u0161\u00ed pomocn\u00edk nie je k\u00a0dispoz\u00edcii.

signature does not match {0}; incompatible supertype
Ozna\u010denie nezodpoved\u00e1 \u00ab\u2026\u00bb; nekompatibiln\u00e1 rodi\u010dovsk\u00e1 trieda.
 
Podrobnej\u0161\u00ed pomocn\u00edk nie je k\u00a0dispoz\u00edcii.

* should be declared abstract; it does not define *
\u00ab\u2026\u00bb by malo by\u0165 deklarovan\u00e9 ako abstraktn\u00e9; preto\u017ee nedefinuje \u00ab\u2026\u00bb.
 
Aktu\u00e1lna trieda je odvoden\u00e1 z\u00a0abstraktnej triedy alebo rozhrania.
Abstraktn\u00e9 triedy a\u00a0rozhrania definuj\u00fa met\u00f3dy bez ich implement\u00e1cie.
Implement\u00e1cia je ponechan\u00e1 na odvoden\u00e9 triedy. Ke\u010f\u017ee t\u00e1to trieda
neimplementovala v\u0161etky abstraktn\u00e9 met\u00f3dy, ktor\u00e9 boli doteraz deklarovan\u00e9,
mala by na\u010falej zosta\u0165 abstraktnou. Mus\u00edte bu\u010f implementova\u0165 v\u0161etky doteraz
neimplementovan\u00e9 met\u00f3dy, alebo deklarova\u0165 t\u00fato triedu ako abstraktn\u00fa
(k\u013e\u00fa\u010dov\u00fdm slovom \u201eabstract\u201c), \u010di\u017ee:
    public abstract class \u2026
namiesto:
    public class \u2026

* is not abstract and does not override abstract method *
\u00ab\u2026\u00bb nie je abstraktn\u00e1 a\u00a0neprekr\u00fdva abstraktn\u00fa met\u00f3du \u00ab\u2026\u00bb.
 
Aktu\u00e1lna trieda je odvoden\u00e1 z\u00a0abstraktnej triedy alebo z\u00a0rozhrania.
Abstraktn\u00e9 triedy a\u00a0rozhrania definuj\u00fa met\u00f3dy bez ich implement\u00e1cie.
Implement\u00e1cia je ponechan\u00e1 na odvoden\u00e9 triedy. Ke\u010f\u017ee t\u00e1to trieda
neimplementovala v\u0161etky abstraktn\u00e9 met\u00f3dy, mala by zosta\u0165 na\u010falej
abstraktnou! Mus\u00edte bu\u010f implementova\u0165 v\u0161etky doteraz neimplementovan\u00e9
(abstraktn\u00e9 alebo deklarovan\u00e9 v\u00a0rozhraniach) met\u00f3dy, alebo deklarova\u0165
t\u00fato triedu ako abstraktn\u00fa (k\u013e\u00fa\u010dov\u00fdm slovom \u201eabstract\u201c), \u010di\u017ee:
    public abstract class \u2026
namiesto:
    public class \u2026

error writing source; cannot overwrite input file *
Chyba pri z\u00e1pise zdrojov\u00e9ho k\u00f3du; nie je mo\u017en\u00e9 prep\u00edsa\u0165 vstupn\u00fd s\u00fabor \u00ab\u2026\u00bb
 
Podrobnej\u0161\u00ed pomocn\u00edk nie je k\u00a0dispoz\u00edcii.

'try' without 'catch' or 'finally'
Bola n\u00e1jden\u00e1 kon\u0161trukcia \u201etry\u201c bez prisl\u00fachaj\u00faceho \u201ecatch\u201c alebo \u201efinally\u201c.
 
Ako pou\u017eijete \u0161trukt\u00faru \u201etry\u201c, mus\u00edte zabezpe\u010di\u0165, aby bol za \u0148ou uveden\u00fd
jeden alebo viac blokov \u201ecatch\u201c alebo jeden blok \u201efinally\u201c (pr\u00edpadne kombin\u00e1cia
uveden\u00e9ho). Spr\u00e1vny z\u00e1pis kompletnej \u0161trukt\u00fary vyzer\u00e1 napr\u00edklad takto:
  try {
    pr\u00edkazy \u2026
  }
  catch(Exception e) {
    pr\u00edkazy \u2026
  }
  finally {
    pr\u00edkazy \u2026
  }

* does not take parameters
\u00ab\u2026\u00bb neprij\u00edma parametre.
 
Pou\u017eit\u00fd \u00fadajov\u00fd typ nie je parametrizovan\u00fd,
nedok\u00e1\u017ee prij\u00edma\u0165 parametre.

wrong number of type arguments; required *
Nespr\u00e1vny po\u010det primit\u00edvnych argumentov; po\u017eadovan\u00fdch: \u00ab\u2026\u00bb
 
Podrobnej\u0161\u00ed pomocn\u00edk nie je k\u00a0dispoz\u00edcii.

type variable {0} occurs more than once in result type of {1}; cannot be left uninstantiated
Premenn\u00e1 primit\u00edvneho typu \u00ab\u2026\u00bb sa vyskytla viac ne\u017e raz pri v\u00fdsledku typu \u00ab\u2026\u00bb; toto nesmie zosta\u0165 bez vytvorenia novej in\u0161tancie.
 
Podrobnej\u0161\u00ed pomocn\u00edk nie je k\u00a0dispoz\u00edcii.

type variable {0} occurs more than once in type of {1}; cannot be left uninstantiated
Premenn\u00e1 primit\u00edvneho typu \u00ab\u2026\u00bb sa vyskytla viac ne\u017e raz pri type \u00ab\u2026\u00bb; toto nesmie zosta\u0165 bez vytvorenia novej in\u0161tancie.
 
Podrobnej\u0161\u00ed pomocn\u00edk nie je k\u00a0dispoz\u00edcii.

unclosed character literal
Neuzatvoren\u00fd znakov\u00fd liter\u00e1l.
 
Pravdepodobne ste za\u010dali p\u00edsa\u0165 znakov\u00fd liter\u00e1l, ktor\u00fd
sa za\u010d\u00edna strojopisn\u00fdm apostrofom ' a\u00a0zabudli ste ho
ukon\u010di\u0165 rovnak\u00fdm apostrofom '. Znakov\u00fd liter\u00e1l mus\u00ed
by\u0165 ukon\u010den\u00fd na rovnakom riadku ako sa za\u010d\u00edna.

unclosed comment
Neuzatvoren\u00fd koment\u00e1r.
 
Pravdepodobne ste za\u010dali p\u00edsa\u0165 viacriadkov\u00fd koment\u00e1r
(ktor\u00fd sa za\u010d\u00edna znakmi lomky a\u00a0hviezdi\u010dky uveden\u00fdmi
tesne za sebou: /*) a\u00a0neuviedli ste znaky ukon\u010duj\u00face
viacriadkov\u00e9 koment\u00e1re (hviezdi\u010dka a\u00a0lomka: */).

unclosed string literal
Neuzatvoren\u00fd re\u0165azcov\u00fd liter\u00e1l.
 
Pravdepodobne ste za\u010dali p\u00edsa\u0165 re\u0165azcov\u00fd liter\u00e1l, ktor\u00fd
sa za\u010d\u00edna strojopisn\u00fdmi \u00favodzovkami " a\u00a0zabudli ste ho
ukon\u010di\u0165 rovnak\u00fdmi \u00favodzovkami ". Re\u0165azec mus\u00ed by\u0165
ukon\u010den\u00fd na rovnakom riadku ako sa za\u010d\u00edna.

undefined label: *
Nedefinovan\u00e1 menovka: \u00ab\u2026\u00bb
 
Menovka, na ktor\u00fa sa odvol\u00e1vate nebola n\u00e1jden\u00e1.
Pravdepodobne ste pou\u017eili n\u00e1zov menovky, ktor\u00e1
nebola definovan\u00e1 alebo nie je v\u00a0zornom poli
aktu\u00e1lneho cyklu. Skontrolujte preklepy v\u00a0n\u00e1zve
menovky a\u00a0to, \u010di sa nach\u00e1dza pred za\u010diatkom
aktu\u00e1lneho cyklu.

unreachable statement
Pr\u00edkaz nie je dostupn\u00fd.
 
Tento pr\u00edkaz nebude nikdy vykonan\u00fd. Ak si pozorne
prezriete zdrojov\u00fd k\u00f3d, zist\u00edte, \u017ee tento pr\u00edkaz je
uveden\u00fd na mieste, kde nebude nikdy vykonan\u00fd
(napr\u00edklad preto, \u017ee t\u00e1to vetva k\u00f3du nikdy nedosiahne
tento bod). Vyma\u017ete zbyto\u010dn\u00fd pr\u00edkaz (ak ho nepotrebujete)
alebo opravte zdrojov\u00fd k\u00f3d.

initializer must be able to complete normally
Inicializ\u00e1tor mus\u00ed ma\u0165 mo\u017enos\u0165 korektn\u00e9ho skon\u010denia.
 
Nem\u00f4\u017eete generova\u0165 v\u00fdnimky alebo inak ukon\u010dova\u0165
statick\u00e9 inicializ\u00e1tory. Mus\u00edte im umo\u017eni\u0165 aspo\u0148
jedn\u00fdm sp\u00f4sobom korektne dokon\u010di\u0165 svoju \u010dinnos\u0165.

* must be caught or declared to be thrown
\u00ab\u2026\u00bb mus\u00ed by\u0165 zachyten\u00e1 v\u00a0tejto met\u00f3de, alebo mus\u00ed by\u0165 t\u00e1to met\u00f3da deklarovan\u00e1 tak, aby mohla v\u00fdnimku generova\u0165.
 
Telo tejto met\u00f3dy obsahuje volanie inej met\u00f3dy, ktor\u00e1 m\u00f4\u017ee vygenerova\u0165
v\u00fdnimku. V\u00fdnimky musia by\u0165 o\u0161etren\u00e9. M\u00e1te dve mo\u017enosti ako napravi\u0165
tento nedostatok: bu\u010f v\u00fdnimku na tomto mieste zachyt\u00edte, alebo deklarujete
t\u00fato met\u00f3du tak, aby mohla v\u00fdnimku generova\u0165 a\u00a0posla\u0165 ju volaj\u00facej met\u00f3de.
Ak chcete v\u00fdnimku zachyti\u0165, pou\u017eite \u0161trukt\u00faru:
  try 
  {
    \u2026
  }
  catch (\u2026)
  {
    \u2026
  }
Ak chcete deklarova\u0165 t\u00fato met\u00f3du tak, aby mohla v\u00fdnimku generova\u0165, pridajte
do deklar\u00e1cie hlavi\u010dky:
    throws \u00abN\u00e1zovV\u00fdnimky\u00bb
pri\u010dom namiesto \u00abN\u00e1zovV\u00fdnimky\u00bb dosa\u010fte skuto\u010dn\u00fd n\u00e1zov v\u00fdnimky.

'void' type not allowed here
Na tomto mieste nie je povolen\u00e9 pou\u017eitie \u201evoid\u201c.
 
V\u00a0tomto kontexte nie je povolen\u00e9 pou\u017eitie k\u013e\u00fa\u010dov\u00e9ho slova \u201evoid\u201c.
Pou\u017eitie tohto k\u013e\u00fa\u010dov\u00e9ho slova je povolen\u00e9 len pri deklar\u00e1ci\u00e1ch met\u00f3d,
ktor\u00e9 neposkytuj\u00fa n\u00e1vratov\u00fa hodnotu. Nem\u00f4\u017ee by\u0165 pou\u017eit\u00e9 na ur\u010denie
\u00fadajov\u00e9ho typu premennej.

* not allowed here
\u00ab\u2026\u00bb nie je na tomto mieste povolen\u00e9.
 
Pou\u017eili ste modifik\u00e1tor na stanovenie pr\u00edstupov\u00fdch pr\u00e1v (napr\u00edklad
\u201eprivate\u201c, \u201eprotected\u201c at\u010f.). Tento modifik\u00e1tor nie je mo\u017en\u00e9 pou\u017ei\u0165
na tomto mieste zdrojov\u00e9ho k\u00f3du.

* might already have been assigned to
Do \u00ab\u2026\u00bb bola u\u017e pravdepodobne priraden\u00e1 hodnota.
 
Do fin\u00e1lnych premenn\u00fdch m\u00f4\u017ee by\u0165 priraden\u00e1 hodnota len raz.
(A\u00a0premenn\u00e1, s\u00a0ktorou t\u00e1to chyba s\u00favis\u00ed je fin\u00e1lna \u2013 deklarovan\u00e1
ako \u201efinal\u201c.) V\u00a0zdrojovom k\u00f3de sa vyskytli dve priradenia hodn\u00f4t
do tejto premennej, kompil\u00e1tor ich na\u0161iel a\u00a0mysl\u00ed si, \u017ee by v\u00a0r\u00f4znom
\u010dase mohlo d\u00f4js\u0165 ku spusteniu obidvoch, \u010do by sp\u00f4sobilo probl\u00e9m.

* might not have been initialized
\u00ab\u2026\u00bb pravdepodobne nebolo inicializovan\u00e9.
 
Pou\u017e\u00edvate lok\u00e1lnu premenn\u00fa, ktorej hodnota nebola inicializovan\u00e1,
alebo nie je zaru\u010den\u00e9, \u017ee bude v\u00a0tomto bode inicializovan\u00e1. Aby bolo
pred\u00edden\u00e9 pochybnostiam, inicializujte premenn\u00fa pri jej deklar\u00e1cii.

variable {0} might be assigned in loop
Premenn\u00e1 \u00ab\u2026\u00bb pravdepodobne men\u00ed hodnotu v\u00a0cykle.
 
Je mo\u017en\u00e9, \u017ee ste v\u00a0cykle priradili hodnotu premennej, ktor\u00e1
je fin\u00e1lna. Takejto premennej m\u00f4\u017ee by\u0165 priraden\u00e1 hodnota
len raz. Len\u017ee ak sk\u00fasite aplikova\u0165 pr\u00edkaz priradenia hodnoty
do fin\u00e1lnej premennej v\u00a0cykle, toto pravidlo poru\u0161\u00edte\u2026

error while writing *
Chyba pri z\u00e1pise \u00ab\u2026\u00bb.
 
Podrobnej\u0161\u00ed pomocn\u00edk nie je k\u00a0dispoz\u00edcii.

* is public, should be declared in a file named *
\u00ab\u2026\u00bb je verejn\u00e9, malo by by\u0165 deklarovan\u00e9 v\u00a0s\u00fabore s\u00a0n\u00e1zvom \u00ab\u2026\u00bb.
 
Je po\u017eadovan\u00e9, aby verejn\u00e9 triedy boli ulo\u017een\u00e9 v\u00a0s\u00faboroch
nazvan\u00fdch rovnak\u00fdm n\u00e1zvom ako sa sami volaj\u00fa, samozrejme
s\u00a0pr\u00edponou s\u00faboru \u201e.java\u201c. Napr\u00edklad verejn\u00e1 trieda \u201eNie\u010do\u201c
mus\u00ed by\u0165 ulo\u017een\u00e1 v\u00a0s\u00fabore \u201eNie\u010do.java\u201c.

cannot read: *
Nie je mo\u017en\u00e9 \u010d\u00edta\u0165: \u00ab\u2026\u00bb
 
Podrobnej\u0161\u00ed pomocn\u00edk nie je k\u00a0dispoz\u00edcii.

* uses or overrides a deprecated API.
\u00ab\u2026\u00bb pou\u017e\u00edva alebo prekr\u00fdva zastaran\u00fa met\u00f3du API.
 
Pou\u017eili ste met\u00f3du, ktorej pou\u017e\u00edvanie nie je \u010falej odpor\u00fa\u010dan\u00e9
(met\u00f3da poch\u00e1dza zo star\u0161\u00edch verzi\u00ed Javy). S\u00a0najv\u00e4\u010d\u0161ou
pravdepodobnos\u0165ou jestvuje in\u00e1 met\u00f3da, ktor\u00e1 poskytuje
rovnak\u00fa alebo podobn\u00fa funkcionalitu. Pre\u0161tudujte si aktu\u00e1lnu
verziu dokument\u00e1cie API, kde m\u00f4\u017ee by\u0165 uveden\u00e9 akou met\u00f3dou
je mo\u017en\u00e9 (alebo vhodn\u00e9) nahradi\u0165 t\u00fato zastaran\u00fa met\u00f3du.

* has been deprecated
\u00ab\u2026\u00bb je zastaran\u00e1.
 
Pou\u017eili ste met\u00f3du, ktorej pou\u017e\u00edvanie nie je \u010falej odpor\u00fa\u010dan\u00e9.
S\u00a0najv\u00e4\u010d\u0161ou pravdepodobnos\u0165ou jestvuje in\u00e1 met\u00f3da, ktor\u00e1
poskytuje rovnak\u00fa alebo podobn\u00fa funkcionalitu. Pre\u0161tudujte
si aktu\u00e1lnu verziu dokument\u00e1cie API, kde m\u00f4\u017ee by\u0165 uveden\u00e9
akou met\u00f3dou je mo\u017en\u00e9 nahradi\u0165 t\u00fato zastaran\u00fa met\u00f3du.

';' expected
O\u010dak\u00e1van\u00e1 bodko\u010diarka.
 
Na konci riadka ch\u00fdba bodko\u010diarka. M\u00f4\u017ee to by\u0165 riadok,
ktor\u00fd bol ozna\u010den\u00fd editorom, alebo riadok pred n\u00edm.

'case', 'default' or '}' expected
Na tomto mieste s\u00fa o\u010dak\u00e1van\u00e9 len \u201ecase\u201c, \u201edefault\u201c, alebo \u201e}\u201c.
 
\u0160trukt\u00fara \u201eswitch\u201c je zlo\u017een\u00e1 z\u00a0nieko\u013ek\u00fdch vetiev \u201ecase\u201c,
jednej nepovinnej vetvy \u201edefault\u201c a\u00a0mus\u00ed by\u0165 uzavret\u00e1
z\u00e1tvorkou \u201e}\u201c. Bu\u010f ste nespr\u00e1vne zap\u00edsali niektor\u00fa vetvu,
alebo ste \u0161trukt\u00faru \u201eswitch\u201c neuzavreli z\u00e1tvorkou \u201e}\u201c.

'class' or 'interface' expected
O\u010dak\u00e1van\u00e9 \u201eclass\u201c alebo \u201einterface\u201c.
 
Na za\u010diatku zdrojov\u00e9ho k\u00f3du s\u00fa o\u010dak\u00e1van\u00e9 slov\u00e1 \u201eclass\u201c
alebo \u201einterface\u201c. Bu\u010f tam nie s\u00fa, alebo je pred nimi
uveden\u00e1 tak\u00e1 \u010das\u0165 k\u00f3du, ktor\u00e1 tam nepatr\u00ed.

'.class' expected
Je o\u010dak\u00e1van\u00e9 \u201e.class\u201c.
 
Podrobnej\u0161\u00ed pomocn\u00edk nie je k\u00a0dispoz\u00edcii.

'(' or '[' expected
Je o\u010dak\u00e1van\u00e1 \u201e(\u201c alebo \u201e[\u201c.
 
Zd\u00e1 sa, \u017ee na tomto mieste k\u00f3du je nep\u00e1rny po\u010det z\u00e1tvoriek,
\u010do zmiatlo kompil\u00e1tor. Starostlivo skontrolujte p\u00e1rovanie
z\u00e1tvoriek. Ka\u017ed\u00e9 otvorenie novej z\u00e1tvorky by malo ma\u0165 svoje
prisl\u00fachaj\u00face zatvorenie.

* expected
Je o\u010dak\u00e1van\u00e9 \u00ab\u2026\u00bb.
 
Na tomto mieste zdrojov\u00e9ho k\u00f3du je o\u010dak\u00e1van\u00fd symbol, ktor\u00fd
je uveden\u00fd v\u00a0chybovom hl\u00e1sen\u00ed. Namiesto toho sa tu nach\u00e1dza
nie\u010do in\u00e9. Pouva\u017eujte nad t\u00fdm, \u010di to sem patr\u00ed a\u00a0pre\u010do by tu mal
by\u0165 o\u010dak\u00e1van\u00fd uveden\u00fd symbol.

orphaned *
Osamoten\u00e9 \u00ab\u2026\u00bb.
 
Podrobnej\u0161\u00ed pomocn\u00edk nie je k\u00a0dispoz\u00edcii.

cannot access *
Nie je mo\u017en\u00e9 pristupova\u0165 k\u00a0\u00ab\u2026\u00bb.
 
Pravdepodobne ste sa pok\u00fasili pristupova\u0165 k\u00a0met\u00f3de \u010di objektu,
ktor\u00fd nie je z\u00a0tohto miesta vidite\u013en\u00fd. Naj\u010dastej\u0161\u00edm d\u00f4vodom je
pokus a\u00a0pou\u017eitie premennej zvonka bloku, v\u00a0ktorom bola definovan\u00e1.

type parameter {0} is not within its bound *
Parameter primit\u00edvneho typu \u00ab\u2026\u00bb nie je v\u00a0r\u00e1mci hran\u00edc \u00ab\u2026\u00bb.
 
Podrobnej\u0161\u00ed pomocn\u00edk nie je k\u00a0dispoz\u00edcii.

type parameters of {0} cannot be determined
Parameter primit\u00edvneho typu \u00ab\u2026\u00bb nem\u00f4\u017ee by\u0165 determinovan\u00fd.
 
Podrobnej\u0161\u00ed pomocn\u00edk nie je k\u00a0dispoz\u00edcii.

incompatible types*
Tieto typy nie s\u00fa vz\u00e1jomne zlu\u010dite\u013en\u00e9: \u00ab\u2026\u00bb
 
Na tomto mieste zdrojov\u00e9ho k\u00f3du je o\u010dak\u00e1van\u00e1 hodnota ist\u00e9ho \u00fadajov\u00e9ho
typu, ale je tu uveden\u00fd v\u00fdraz, ktor\u00fd poskytuje hodnotu in\u00e9ho \u00fadajov\u00e9ho typu.
(Napr\u00edklad ste mohli sk\u00fasi\u0165 priradi\u0165 re\u0165azec do celo\u010d\u00edselnej premennej.)

inconvertible types*
Tieto typy nie je mo\u017en\u00e9 vz\u00e1jomne konvertova\u0165: \u00ab\u2026\u00bb
 
\u00dadajov\u00fd typ, ktor\u00fd ste pou\u017eili na tomto mieste nem\u00f4\u017ee by\u0165
automaticky konvertovan\u00fd na \u010fal\u0161\u00ed uveden\u00fd \u00fadajov\u00fd typ.

possible loss of precision
Hroz\u00ed strata presnosti hodnoty.
 
Jednotliv\u00e9 \u010d\u00edseln\u00e9 \u00fadajov\u00e9 typy maj\u00fa r\u00f4zne povolen\u00e9 \u010d\u00edseln\u00e9 rozsahy.
Ak sa pok\u00fasite priradi\u0165 hodnotu objektu \u00fadajov\u00e9ho typu s\u00a0vy\u0161\u0161\u00edm rozsahom
do objektu \u00fadajov\u00e9ho typu s\u00a0ni\u017e\u0161\u00edm rozsahom, tak m\u00f4\u017ee d\u00f4js\u0165 ku strate
skuto\u010dnej hodnoty. Ak ste si v\u0161ak ist\u00ed, \u017ee strata \u00fadajov nehroz\u00ed (napr\u00edklad
ak viete, \u017ee nepracujete s\u00a0hodnotami mimo rozsahu ni\u017e\u0161ieho \u00fadajov\u00e9ho typu),
tak pou\u017eite na zdrojov\u00fd objekt oper\u00e1tor pretypovania.

unexpected type
Neo\u010dak\u00e1van\u00fd \u00fadajov\u00fd typ.
 
Na tomto mieste zdrojov\u00e9ho k\u00f3du je o\u010dak\u00e1van\u00e1 hodnota ist\u00e9ho \u00fadajov\u00e9ho
typu, ale je tu uveden\u00fd v\u00fdraz, ktor\u00fd poskytuje hodnotu in\u00e9ho \u00fadajov\u00e9ho typu.
(Napr\u00edklad ste mohli sk\u00fasi\u0165 priradi\u0165 re\u0165azec do celo\u010d\u00edselnej premennej.)

abstract {0} {1} cannot be accessed directly
Nem\u00f4\u017eete z\u00edska\u0165 priamy pr\u00edstup k\u00a0abstraktnej/\u00e9mu \u00ab\u2026\u00bb \u00ab\u2026\u00bb
 
Podrobnej\u0161\u00ed pomocn\u00edk nie je k\u00a0dispoz\u00edcii.

*An explicit 'this' qualifier must be used to select the desired instance.
Ak chcete pou\u017ei\u0165 vybran\u00fa in\u0161tanciu, mus\u00edte pou\u017ei\u0165 k\u013e\u00fa\u010dov\u00e9 slovo \u201ethis\u201c.
 
Podrobnej\u0161\u00ed pomocn\u00edk nie je k\u00a0dispoz\u00edcii.

*cannot be referenced from a static context
\u00ab\u2026\u00bb nem\u00f4\u017ee by\u0165 odkazovan\u00e9 v\u00a0statickom kontexte
 
Pok\u00fa\u0161ate sa pristupova\u0165 k\u00a0atrib\u00fatu alebo met\u00f3de zo statickej met\u00f3dy.
To nie je povolen\u00e9. Atrib\u00faty a\u00a0met\u00f3dy s\u00fa v\u017edy vz\u0165ahovan\u00e9 na ur\u010dit\u00fd
akt\u00edvny objekt. V\u00a0statickej met\u00f3de nie je predvolene akt\u00edvny \u017eiadny
objekt, preto nie je mo\u017en\u00e9 rozhodn\u00fa\u0165 s\u00a0ak\u00fdmi \u00fadajmi alebo met\u00f3dami
sa m\u00e1 pracova\u0165. Statick\u00e9 met\u00f3dy m\u00f4\u017eu vola\u0165 v\u00a0len in\u00e9 statick\u00e9 met\u00f3dy
a\u00a0m\u00f4\u017eu pracova\u0165 len so statick\u00fdmi \u00fadajmi. Ak chcete pracova\u0165
s\u00a0dynamick\u00fdm obsahom, mus\u00edte pou\u017ei\u0165 referenciu cez objekt (in\u0161tanciu).

cannot find symbol*
Nedok\u00e1\u017eem n\u00e1js\u0165 symbol \u00ab\u2026\u00bb.
 
Na tomto mieste ste pou\u017eili symbol (n\u00e1zov premennej, met\u00f3dy alebo triedy),
ktor\u00fd nebol definovan\u00fd v\u00a0r\u00e1mci aktu\u00e1lneho zorn\u00e9ho po\u013ea. Overte, \u010di je n\u00e1zov
spr\u00e1vne zap\u00edsan\u00fd (preklepy, ve\u013ekos\u0165 p\u00edsmen). Overte, \u010di je symbol spr\u00e1vne
definovan\u00fd a\u00a0\u010di sa jeho defin\u00edcia nach\u00e1dza v\u00a0r\u00e1mci aktu\u00e1lneho zorn\u00e9ho po\u013ea
(bloku, triedy\u2026).

cannot resolve symbol*
Nedok\u00e1\u017eem rozl\u00fa\u0161ti\u0165 symbol \u00ab\u2026\u00bb.
 
Na tomto mieste ste pou\u017eili symbol (n\u00e1zov premennej, met\u00f3dy alebo triedy),
ktor\u00fd nebol definovan\u00fd v\u00a0r\u00e1mci aktu\u00e1lneho zorn\u00e9ho po\u013ea. Overte, \u010di je n\u00e1zov
spr\u00e1vne zap\u00edsan\u00fd (preklepy, ve\u013ekos\u0165 p\u00edsmen). Overte, kde je symbol definovan\u00fd
a\u00a0\u010di nie je mo\u017en\u00e9 jeho defin\u00edciu presun\u00fa\u0165.

{0}; {1} and {2} are static
\u00ab\u2026\u00bb; \u00ab\u2026\u00bb a\u00a0\u00ab\u2026\u00bb s\u00fa statick\u00e9.
 
Podrobnej\u0161\u00ed pomocn\u00edk nie je k\u00a0dispoz\u00edcii.

{0}; overridden method is {1}
\u00ab\u2026\u00bb; prekryt\u00e1 met\u00f3da je \u00ab\u2026\u00bb.
 
Podrobnej\u0161\u00ed pomocn\u00edk nie je k\u00a0dispoz\u00edcii.

* attempting to assign weaker access privileges; was *
\u00ab\u2026\u00bb sa pok\u00fasilo priradi\u0165 ni\u017e\u0161ie pr\u00edstupov\u00e9 pr\u00e1va; boli \u00ab\u2026\u00bb.
 
Na tomto mieste ste sa pok\u00fasili prekry\u0165 jestvuj\u00facu met\u00f3du
a\u00a0zmeni\u0165 jej pr\u00edstupov\u00e9 pr\u00e1va (\u201eprivate\u201c, \u201eprotected\u201c, \u201epublic\u201c).
Zmena pr\u00edstupov\u00fdch pr\u00e1v je povolen\u00e1 len smerom nahor, to
znamen\u00e1, \u017ee je mo\u017en\u00e9 len roz\u0161\u00edri\u0165 pr\u00edstup (napr\u00edklad z\u00a0\u201eprivate\u201c
na \u201epublic\u201c), nie naopak (teda z\u00a0\u201epublic\u201c na \u201eprivate\u201c).
Samozrejme, \u017ee je mo\u017en\u00e9 ponecha\u0165 rovnak\u00fa \u00farove\u0148 pr\u00e1vomoc\u00ed.

* overridden method does not throw *
\u00ab\u2026\u00bb prekryt\u00e1 met\u00f3da negeneruje v\u00fdnimku \u00ab\u2026\u00bb.
 
Pok\u00fa\u0161ate sa prekry\u0165 met\u00f3du tak\u00fdm sp\u00f4sobom, \u017ee v\u00a0jej tele
m\u00f4\u017ee vznikn\u00fa\u0165 tak\u00fd typ v\u00fdnimky, ktor\u00fd v\u00a0p\u00f4vodnej met\u00f3de
(odvodenej z\u00a0nadradenej triedy) nevznik\u00e1. Prekryt\u00e1 met\u00f3da
smie generova\u0165 len tak\u00e9 typy v\u00fdnimiek, ktor\u00e9 generuje
p\u00f4vodn\u00e1 met\u00f3da. Nemus\u00ed generova\u0165 v\u0161etky p\u00f4vodn\u00e9 typy
v\u00fdnimiek, nesmie v\u0161ak prid\u00e1va\u0165 \u010fal\u0161ie.

* attempting to use incompatible return type
\u00ab\u2026\u00bb sa pok\u00fa\u0161a vyu\u017ei\u0165 n\u00e1vratov\u00fd k\u00f3d, ktor\u00fd s\u00a0\u0148ou nie je zlu\u010dite\u013en\u00fd.
 
Podrobnej\u0161\u00ed pomocn\u00edk nie je k\u00a0dispoz\u00edcii.

* is already defined in this compilation unit
\u00ab\u2026\u00bb u\u017e bolo definovan\u00e9 v\u00a0tejto kompila\u010dnej jednotke.
 
Pou\u017eili ste dvakr\u00e1t ten ist\u00fd n\u00e1zov. Zvo\u013ete in\u00fd n\u00e1zov (identifik\u00e1tor)!

{0} is already defined in a single-type import
\u00ab\u2026\u00bb u\u017e bolo definovan\u00e9 pri importe jednoduch\u00e9ho typu.
 
Podrobnej\u0161\u00ed pomocn\u00edk nie je k\u00a0dispoz\u00edcii.

* conflicts with a compiler-synthesized symbol in *
\u00ab\u2026\u00bb je v\u00a0konflikte so symbolom vytvoren\u00fdm kompil\u00e1torom v\u00a0\u00ab\u2026\u00bb.
 
Podrobnej\u0161\u00ed pomocn\u00edk nie je k\u00a0dispoz\u00edcii.

reached end of file while parsing
Po\u010das prekladu bol pred\u010dasne dosiahnut\u00fd koniec s\u00faboru.
 
To znamen\u00e1, \u017ee ste otvorili blok pou\u017eit\u00edm \u201e{\u201c a\u00a0zabudli ste ho zavrie\u0165 \u201e}\u201c.
Bu\u010f m\u00e1te niekde navy\u0161e \u201e{\u201c, alebo ste niekde zabudli uvies\u0165 \u201e}\u201c.
Podrobnej\u0161\u00ed pomocn\u00edk nie je k dispoz\u00edcii.

* is already defined in this compilation unit
\u00ab\u2026\u00bb u\u017e bolo definovan\u00e9 v tejto kompila\u010dnej jednotke.
 
Pou\u017eili ste dvakr\u00e1t ten ist\u00fd n\u00e1zov. Zvo\u013ete in\u00fd n\u00e1zov
(identifik\u00e1tor)\u2026!

{0} is already defined in a single-type import
\u00ab\u2026\u00bb u\u017e bolo definovan\u00e9 pri importe jednoduch\u00e9ho typu.
 
Podrobnej\u0161\u00ed pomocn\u00edk nie je k dispoz\u00edcii.

* conflicts with a compiler-synthesized symbol in *
\u00ab\u2026\u00bb je v konflikte so symbolom vytvoren\u00fdm kompil\u00e1torom v \u00ab\u2026\u00bb.
 
Podrobnej\u0161\u00ed pomocn\u00edk nie je k dispoz\u00edcii.

reached end of file while parsing
Po\u010das prekladu bol pred\u010dasne dosiahnut\u00fd koniec s\u00faboru.
 
To znamen\u00e1, \u017ee ste otvorili blok pou\u017eit\u00edm \u201e{\u201c a zabudli
ste ho zavrie\u0165 \u201e}\u201c. Bu\u010f m\u00e1te niekde navy\u0161e \u201e{\u201c, alebo
ste niekde zabudli uvies\u0165 \u201e}\u201c.
