as of release 1.4, 'assert' is a keyword, and may not be used as an identifier
A palavra 'assert' agora faz parte da linguagem Java
e, portanto, possui um significado especial (palavra chave).
Voc\u00ea n\u00e3o poder\u00e1 us\u00e1-la para nomear vari\u00e1veis ou m\u00e9todos.
Por favor, esclha um outro nome.

qualified new of static class
Nenhuma ajuda dispon\u00edvel.

* is abstract; cannot be instantiated
A classe \u00e9 "abstract". Isto significa que
ela cont\u00e9m alguns m\u00e9todos para os quais n\u00e3o fornece
implementa\u00e7\u00e3o (m\u00e9todos abstratos). Voc\u00ea n\u00e3o pode
criar objetos de classes abstratas. Ou voc\u00ea usa uma
subsclasse ou escreve uma subclasse desta classe
abstrata que implemente todos os m\u00e9todos abstratos.
Assim, voc\u00ea poder\u00e1 criar objetos desta subclasse.

abstract methods cannot have a body
Voc\u00ea declarou um m\u00e9todo "abstract" e escreveu
um corpo para este m\u00e9todo. Isto \u00e9 uma contradi\u00e7\u00e3o.
Declara\u00e7\u00f5es de m\u00e9todos abstratos possuem apenas um
cabe\u00e7alho de m\u00e9todo seguido por ponto-e-v\u00edrgula.
Remova a palavra "abstract" ou remova o corpo do 
m\u00e9todo.

* is already defined in *
J\u00e1 existe uma vari\u00e1vel (ou talvez um par\u00e2metro)
neste m\u00e9todo que possui o mesmo nome. Use
um nome diferente para este. (Se sua inten\u00e7\u00e3o
\u00e9 utilizar a vari\u00e1vel neste ponto do c\u00f3digo,
ent\u00e3o deve remover o tipo para que isto n\u00e3o
pare\u00e7a uma nova declara\u00e7\u00e3o de vari\u00e1vel).

anonymous class implements interface; cannot have arguments
Nenhuma ajuda dispon\u00edvel.

anonymous class implements interface; cannot have qualifier for new
Nenhuma ajuda dispon\u00edvel.

array required, but *
Parece que voc\u00ea est\u00e1 querendo acessar um elemento de
um arranjo. Entretanto, a vari\u00e1vel que voc\u00ea est\u00e1
usando n\u00e3o \u00e9 um arranjo.

break outside switch or loop
O comando "break" interrompe um bloco, tal
como um comando "switch" ou um la\u00e7o ("for",
"while" ou "do"). Ele n\u00e3o pode ser utilizado fora
de tais blocos.

* must be first statement in constructor
A primeira coisa a ser executada numa classe que possui
superclasse \u00e9 chamar o construtor da superclasse.
Voc\u00ea faz isso adicionando
    super(...);
na primeira linha do seu construtor (substituindo os
pontos pelos par\u00e2metros apropriados). Tentar usar
membros de uma superclasse antes de chamar seu
construtor pode levar a s\u00e9rios problemas!

cannot access *
Nenhuma ajuda dispon\u00edvel.

cannot assign a value to final variable *
A vari\u00e1vel a que voc\u00ea est\u00e1 tentando atribuir um valor
foi declarada "final". Isto significa que n\u00e3o \u00e9 permitido
mudar seu valor. Se voc\u00ea realmente precisa mudar o valor,
remova a palavra "final" da declara\u00e7\u00e3o da vari\u00e1vel.

type variables cannot be dereferenced
Voc\u00ea n\u00e3o pode usar o ponto para acessar
campos ou m\u00e9todos de vari\u00e1veis primitivas.

* cannot be dereferenced
Voc\u00ea est\u00e1 usando o ponto para acessar um campo ou um 
m\u00e9todo de outro objeto. Entretanto, a vari\u00e1vel que voc\u00ea
est\u00e1 usando n\u00e3o \u00e9 refer\u00eancia para um objeto - ela n\u00e3o 
possui campos ou m\u00e9todos.

cannot inherit from final *
A superclasse (a classe que aparece ap\u00f3s a
palavra "extends") \u00e9 declarada final. Isto 
significa que ela n\u00e3o permite subclasses.
Desculpe - voc\u00ea n\u00e3o pode criar subclasses
dela se ela n\u00e3o deseja que voc\u00ea o fa\u00e7a...

* before supertype constructor has been called
A primeira coisa a ser executada numa classe que possui
superclasse \u00e9 chamar o construtor da superclasse.
Voc\u00ea faz isso adicionando
    super(...);
na primeira linha do seu construtor (substituindo os
pontos pelos par\u00e2metros apropriados). Tentar usar
membros de uma superclasse antes de chamar seu
construtor pode levar a s\u00e9rios problemas!

cannot return a value from method whose result type is void
Um tipo void como retorno de um m\u00e9todo indica que
este m\u00e9todo n\u00e3o retorna valores. O corpo do m\u00e9todo n\u00e3o deve
ter um comando return dentro dele.

cannot select a static class from a parameterized type
Nenhuma ajuda dispon\u00edvel.

* cannot be inherited with different arguments:*
Nenhuma ajuda dispon\u00edvel.

'catch' without 'try'
"catch" \u00e9 uma palavra Java que s\u00f3 pode aparecer ap\u00f3s
um bloco "try". O padr\u00e3o correto \u00e9
   try {
      comandos;
   }
   catch(Exception e) {
     comandos;
   }

* clashes with package of same name
Certifique-se que a classe e o pacote
t\u00eam nomes diferentes. Em geral, classes
devem come\u00e7ar com letras mai\u00fasculas, enquanto
nomes de pacotes devem come\u00e7ar com letras min\u00fasculas.

code too large for try statement
Voc\u00ea p\u00f4s muito c\u00f3digo dentro deste comando try.
Ponha o c\u00f3digo em um m\u00e9todo separado e insira
uma chamada de m\u00e9todo aqui.

constant expression required
Voc\u00ea usou uma vari\u00e1vel ou uma express\u00e3o aqui, mas isto 
\u00e9 ilegal. Apenas constantes podem ser usadas aqui.
Constantes s\u00e3o n\u00fameros literais (como 42) ou 
identificadores declarados com "final".

continue outside of loop
O comando "continue" \u00e9 usado para 
iniciar a pr\u00f3xima itera\u00e7\u00e3o do la\u00e7o
imediatamente. Ele n\u00e3o possui significado
fora de um la\u00e7o. Ele s\u00f3 pode ser usado dentro
de um "for", "while" ou "do".

cyclic inheritance involving *
Voc\u00ea est\u00e1 tentando estender uma classe,
mas aquela classe j\u00e1 declara que extende
a sua classe. Bem, isto n\u00e3o funciona!
Voc\u00ea deve decidir qual delas \u00e9 a superclasse
e qual \u00e9 a subclasse.

* does not exist
O nome que voc\u00ea usou aqui (que pode ser uma vari\u00e1vel, 
uma classe ou um pacote) n\u00e3o existe. N\u00e3o h\u00e1 uma vari\u00e1vel,
classe ou pacote com este nome.

duplicate class:*
J\u00e1 h\u00e1 uma classe com este nome.

duplicate case label
Voc\u00ea usou o mesmo r\u00f3tulo duas vezes no mesmo
comando "switch".

duplicate default label
Voc\u00ea escreveu "default" duas vezes no mesmo
comando switch. Voc\u00ea n\u00e3o pode fazer isso - uma vez
\u00e9 suficiente.

'else' without 'if'
Um 'else' s\u00f3 pode apareder como parte de um comando
'if' na seguinte forma
   if (condi\u00e7\u00e3o)
     comando;
   else
     comando;
Voc\u00ea n\u00e3o esqueceu de por as chaves envolvendo os comandos?
Se voc\u00ea tiver mais de um comando ap\u00f3s o if, voc\u00ea ter\u00e1
que adicionar chaves, desta forma:
   if (condi\u00e7\u00e3o) 
   {
      comando1;
      comando2;
   }
   else
   {
      comando3;
   }

empty character literal
Voc\u00ea escreveu um caractere literal vazio ilegal.
Voc\u00ea n\u00e3o pode escrever ''. Uma constante caractere \u00e9
formada por um \u00fanico caractere envolto em ap\u00f3strofos, 
como por exemplo 'a'. Na maioria das vezes s\u00f3 pode haver
um \u00fanico caractere entre ap\u00f3strofos. A \u00fanica exce\u00e7\u00e3o \u00e9 se
o primeiro caractere for uma contra-barra ("\", chamada
de caractere de escape) para defini\u00e7\u00e3o de caracteres
especiais, e.g. '\n' ou '\t'.

* has already been caught
Este comando catch \u00e9 in\u00fatil. Ele 
nunca ser\u00e1 executado, porque todas as
exce\u00e7\u00f5es que ele diz tratar j\u00e1 foram
tratadas pelos catchs acima dele.

* is never thrown in body of corresponding try statement
Voc\u00ea declarou que deseja tratar uma exce\u00e7\u00e3o aqui.
Mas eu devo inform\u00e1-lo que esta exce\u00e7\u00e3o nunca ser\u00e1
lan\u00e7ada neste ponto! N\u00e3o h\u00e1 nenhum comando no
bloco "try" que lance esta exce\u00e7\u00e3o.

'finally' without 'try'
"finally" \u00e9 uma palavra reservada Java que s\u00f3 pode aparecer
ap\u00f3s um bloco "try". O padr\u00e3o correto \u00e9
   try {
      comandos;
   }
   catch(Exception e) {
     comandos;
   }
   finally {
      comandos;
   }

floating point number too large
O sistema n\u00e3o consegue lidar com n\u00fameros de
ponto flutuante t\u00e3o grandes.

floating point number too small
O sistema n\u00e3o consegue lidar com n\u00fameros de
ponto flutuante t\u00e3o pequenos.

inner classes cannot have static declarations
Voc\u00ea n\u00e3o pode declarar vari\u00e1veis static
em classes aninhadas. Se precisar de tipos
static aqui declare-os na classe externa.

illegal character:*
H\u00e1 um caractere ilegal no c\u00f3digo fonte. Este caractere pode
estar invis\u00edvel. Se voc\u00ea n\u00e3o conseguir encontr\u00e1-lo para
apag\u00e1-lo, apague a linha inteira e digite-a novamente.

illegal combination of modifiers: *
Voc\u00ea tentou combinar dois modificadores Java que
s\u00e3o considerados pares ilegais. \u00c9 prov\u00e1vel que o
significado de um seja contradit\u00f3rio para o outro.
Um exemplo disto seria definir um m\u00e9todo como
abstract e native, final, private ou synchronized.

illegal escape character
Um caractere de escape \u00e9 escrito com uma contra-barra
e um segundo caractere, por exemplo '\n'. Isto \u00e9 utilizado
para definir caracteres especiais. S\u00f3 h\u00e1 apenas
um conjunto fixo de caracteres que podem aparecer
ap\u00f3s uma contra-barra. S\u00e3o eles \n, \t, \b, \r, \f, \\,
\', \" e n\u00fameros. Se voc\u00ea deseja escreve o pr\u00f3prio
contra-barra, use "\\" - isto ser\u00e1 substitu\u00eddo 
por um \u00fanico caractere contra-barra no seu string.

illegal forward reference
Nenhuma ajuda dispon\u00edvel.

illegal initializer for *
Nenhuma ajuda dispon\u00edvel.

illegal line end in character literal
H\u00e1 uma quebra de linha onde um literal de caractere
deveria ser especificado. Voc\u00ea n\u00e3o pode fazer isso.
Se voc\u00ea quiser colocar um caractere de quebra de linha
use o '\n'.

illegal qualifier; {0} is not an inner class
Nenhuma ajuda dispon\u00edvel.

illegal start of expression
Nenhuma ajuda dispon\u00edvel.

illegal start of type
Na posi\u00e7\u00e3o do c\u00f3digo fonte onde era esperado um
nome de tipo h\u00e1 uma outra coisa (provavelmente
uma palavra reservada Java). Procure poss\u00edveis
defini\u00e7\u00f5es incorretas nesta linha.

illegal unicode escape
Nenhuma ajuda dispon\u00edvel.

improperly formed type, some parameters are missing
Nenhuma ajuda dispon\u00edvel.

incomparable types: *
Nenhuma ajuda dispon\u00edvel.

integer number too large: *
Voc\u00ea escreveu um n\u00famero que \u00e9 muito grande para
o tipo de dado de se espera receber aqui. Voc\u00ea
deve usar um tipo de dado maior (por exemplo,
"long" ao inv\u00e9s de "int").

internal error; cannot instantiate *
Nenhuma ajuda dispon\u00edvel.

* but with different return type
Voc\u00ea deve estar tentando combinar dois m\u00e9todos que
t\u00eam a mesma assinatura, exceto pelo tipo de retorno. Isto
n\u00e3o \u00e9 permitido. Isto est\u00e1 acontecendo muito provavelmente
porque sua classe est\u00e1 tentando implementar duas interfaces.
Cada interface tem um m\u00e9todo com o mesmo nome e par\u00e2metros, mas
diferentes tipos de retorno. Voc\u00ea n\u00e3o pode implementar ambas
as interfaces, a menos que mude uma delas. Ou voc\u00ea renomeia um
dos m\u00e9todos ou muda o tipo de retorno para ser o mesmo em ambos.

interface expected here
Uma interface s\u00f3 pode extender outra interface. O nome
que voc\u00ea especificou ap\u00f3s a palavra "extends" n\u00e3o \u00e9 de uma
interface.

interface methods cannot have body
M\u00e9todos de interfaces possuem apenas a declara\u00e7\u00e3o.
Isto significa que eles devem ter um cabe\u00e7alho seguido
por um ponto-e-v\u00edgula. N\u00e3o pode haver nenhum corpo de
m\u00e9todo.

hexadecimal numbers must contain at least one hexadecimal digit
Voc\u00ea especificou um n\u00famero em hexadecimal. (Isto \u00e9
feito colocando-se um "0x" no in\u00edcio do n\u00famero). N\u00fameros
hexadecimais devem possuir pelo menos um d\u00edgito ap\u00f3s o "X".

invalid method declaration; return type required
Uma declara\u00e7\u00e3o de m\u00e9todo deve ter um tipo de retorno.
Por exemplo, se seu m\u00e9todo retorna um String, escreva
    public String myMethod();
Se voc\u00ea n\u00e3o quiser que o m\u00e9todo retorne nenhum valor,
use a palavra especial "void".
Por exemplo:
    public void myMethod();

* already in use
J\u00e1 existe uma vari\u00e1vel (ou talvez um 
par\u00e2metro) neste m\u00e9todo que possui
o mesmo nome. Use um nome diferente.
(Voc\u00ea pretende usar a mesma
vari\u00e1vel aqui? Neste caso, remova
o nome do tipo para que isso n\u00e3o se
pare\u00e7a com uma nova delcara\u00e7\u00e3o de vari\u00e1vel).

* is accessed from within inner class; needs to be declared final
Vari\u00e1veis locais n\u00e3o s\u00e3o acess\u00edveis por classes internas.
Mas isto \u00e9 exatamente o que voc\u00ea est\u00e1 tentando fazer
aqui. Voc\u00ea tem duas op\u00e7\u00f5es: ou desiste de acessar
esta vari\u00e1vel ou declara a vari\u00e1vel como "final"
- e assim pode acess\u00e1-la.

malformed floating point literal
Voc\u00ea cometeu erros ao escrever um n\u00famero de ponto
flutuante. (Um n\u00famero de ponto flutuante \u00e9 um
que possui um ponto decimal). Exemplos de
n\u00fameros de ponto flutuante corretos:
18.0      18.     1.8e1     .18E2

missing method body, or declare abstract
M\u00e9todos devem ter um corpo ou serem abstratos.
Um corpo de m\u00e9todo \u00e9 um bloco formado por
chaves { }, que v\u00eam logo ap\u00f3s o cabe\u00e7alho do m\u00e9todo,
e possuem comandos. Se um m\u00e9todo n\u00e3o possui um corpo,
ent\u00e3o ele deve ter a palavra "abstract" em seu
cabe\u00e7alho. Por exemplo:
    public abstract int getAnswer();

missing return statement
Voc\u00ea tem um m\u00e9todo que retorna um valor. N\u00e3o h\u00e1,
entretanto, nenhum comando "return" no corpo do m\u00e9todo.
Ambas as situa\u00e7\u00f5es n\u00e3o podem acontecer. Voc\u00ea deve:
   - declarar o tipo de retorno do m\u00e9todo como "void",
     caso n\u00e3o queira retornar nenhum valor, ou
   - escrever um comando "return" com um valor
     de retorno correto, por exemplo
         return 42;
O tipo do valor de retorno deve ser igual ao declarado
no cabe\u00e7alho do m\u00e9todo.

missing return value
Aqui voc\u00ea escreveu um comando "return" que n\u00e3o retorna
nenhum valor. O cabe\u00e7alho do m\u00e9todo, no entanto, declara
que este m\u00e9todo retorna um valor. Ou voc\u00ea declara
que este m\u00e9todo n\u00e3o retorna um valor (usando "void"
como tipo de retorno no cabe\u00e7alho), ou retorna um valor
do tipo correto, por exemplo
    return 42;
ou
    return "Marvin";

name clash: *
Voc\u00ea definiu dois m\u00e9todos com o mesmo nome. Isto s\u00f3
\u00e9 permitido se um sobrescrever o outro (o que n\u00e3o \u00e9 o 
caso aqui). Um dos nomes deve ser mudado.

* is reserved for internal use
O termo exibido \u00e9 reservado para uso interno, se voc\u00ea
o estiver usando como nome de uma vari\u00e1vel ter\u00e1 que mud\u00e1-lo

native methods cannot have a body
Voc\u00ea declarou um m\u00e9todo "native" e, no entanto, escreveu
um corpo para ele. Declara\u00e7\u00f5es de m\u00e9todos nativos t\u00eam
apenas um cabe\u00e7alho seguido por ponto-e-v\u00edgula. Ou voc\u00ea
remove a palavra "native" ou remove o corpo do m\u00e9todo.

no enclosing instance of type {0} is in scope
Nenhuma ajuda dispon\u00edvel.

no interface expected here
Voc\u00ea est\u00e1 referenciando uma interface (possivelmente
na declara\u00e7\u00e3o "extends" da classe). Uma classe s\u00f3 pode
extender outra classe (nunca interfaces). Se voc\u00ea deseja
implementar esta interface, use a palavra "implements"
em lugar de "extends".

{0} has no match in entry in {1}; required {2}
Nenhuma ajuda dispon\u00edvel.

* is not defined in a public class or interface; cannot be accessed from outside package
Nenhuma ajuda dispon\u00edvel.

* cannot be accessed from outside package
A classe que voc\u00ea est\u00e1 tentando usar aqui n\u00e3o \u00e9 p\u00fablica.
Isto \u00e9: sua defini\u00e7\u00e3o n\u00e3o come\u00e7a com
   public class ...
Se uma classe n\u00e3o for p\u00fablica, ela n\u00e3o pode ser usada
fora do seu pacote. Se voc\u00ea precisar realmente usar
esta classe, deve mudar a sua defini\u00e7\u00e3o de modo 
a torn\u00e1-la p\u00fablica.

not a loop label: *
Os r\u00f3tulos que voc\u00ea usa em la\u00e7os tais como
   continue <label>;
devem ser definidos para marcar um la\u00e7o (isto \u00e9:
eles devem ser definidos imediatamente antes
do in\u00edcio do la\u00e7o). O r\u00f3tulo (label) que voc\u00ea
definiu aqui n\u00e3o est\u00e1 no local correto - ele
n\u00e3o est\u00e1 rotulando um la\u00e7o.

not a statement
Voc\u00ea escreveu uma linha de c\u00f3digo que n\u00e3o \u00e9
um comando completo. Por favor, verifique novamente
o que voc\u00ea pretendia fazer e como deve faz\u00ea-lo.

not an enclosing class:*
Voc\u00ea tentou acessar o ponteiro de objeto corrente ('this')
de uma outra classe externa a sua. Isto s\u00f3 \u00e9 permitido se
aquela outra classe for uma classe que cont\u00e9m a sua.
(em outras palavras: numa classe interna voc\u00ea pode acessar
a classe externa e mais nenhuma outra).

* cannot be applied to *
O operador que voc\u00ea usou aqui \u00e9 incompat\u00edvel com
o tipo do valor em um dos operandos. Ou voc\u00ea est\u00e1
utilizando o tipo incorreto ou o operador incorreto.

* clashes with class of same name
Certifique-se de que a classe e o pacote
possuem nomes diferentes. Em geral, classes
devem come\u00e7ar com letras mai\u00fasculas, enquanto
que pacotes devem ter seu nome escrito com letras
min\u00fasculas.

possible fall-through into case
Nenhuma ajuda dispon\u00edvel.

error reading *
Nenhuma ajuda dispon\u00edvel.

recursive constructor invocation
Voc\u00ea escreveu um c\u00f3digo que faz o construtor
chamar a si pr\u00f3prio. Isto n\u00e3o \u00e9 permitido (e
pode causar loops infinitos).

* is ambiguous, both *
O identificador desta mensagem n\u00e3o p\u00f4de ser adequadamente
resolvido porque h\u00e1 mais de uma classe ou interface
com este nome definidos nos pacotes que voc\u00ea importou.
Ou voc\u00ea se refere \u00e0 classe utilizando seu nome
qualificado (e.g. java.util.List) ou a importa com seu
nome qualificado (e.g. import java.util.List).

repeated interface
Voc\u00ea listou duas vezes a mesma
interface na declara\u00e7\u00e3o "implements".
Uma \u00e9 o suficiente. Minha mem\u00f3ria n\u00e3o
\u00e9 t\u00e3o ruim!

repeated modifier
Nesta declara\u00e7\u00e3o voc\u00ea escreveu o mesmo modificador
duas vezes. Um modificador \u00e9 uma palavra reservada,
tal como final, static, public, private, volatile,...

{0} has {1} access in {2}
Nenhuma ajuda dispon\u00edvel.

return outside method
Voc\u00ea s\u00f3 pode usar um comando 'return' em m\u00e9todos
(nunca em blocos de inicializa\u00e7\u00e3o ou outros segmentos
de c\u00f3digo que n\u00e3o sejam m\u00e9todos).

signature does not match {0}; incompatible interfaces
Nenhuma ajuda dispon\u00edvel.

signature does not match {0}; incompatible supertype
Nenhuma ajuda dispon\u00edvel.

* should be declared abstract; it does not define *
A classe corrente herda de uma classe abstrata ou 
de uma interface. Classes abstratas e interfaces
definem m\u00e9todos sem fornecer uma implementa\u00e7\u00e3o.
Esta classe n\u00e3o define implementa\u00e7\u00f5es para todos
os m\u00e9todos que precisam de uma implementa\u00e7\u00e3o,
fazendo com que a classe tamb\u00e9m seja abstrata (ela
ainda tem m\u00e9todos sem implementa\u00e7\u00e3o). Ou voc\u00ea
declara esta classe abstrata
   public abstract class ...
ao inv\u00e9s de apenas
   public class ...
ou voc\u00ea fornece uma implementa\u00e7\u00e3o para
o m\u00e9todo indicado na mensagem de erro

* is not abstract and does not override abstract method *
A presente classe herda de uma classe abstrata ou
implementa uma interface. Classes abstratas e interfaces
definem m\u00e9todos sem implementa\u00e7\u00e3o. Esta classe n\u00e3o
implementou todos os m\u00e9todos que precisam de uma
implementa\u00e7\u00e3o, portanto ela tamb\u00e9m deve ser abstrata (
uma vez que tem m\u00e9todos sem implementa\u00e7\u00e3o). Voc\u00ea
deve ou declarar esta classe como abstrata
    public abstract class ...
ao inv\u00e9s de
    public class ...
ou ent\u00e3o deve fornecer uma implementa\u00e7\u00e3o para o 
m\u00e9todo indicado na mensagem de erro.

error writing source; cannot overwrite input file *
Nenhuma ajuda dispon\u00edvel.

'try' without 'catch' or 'finally'
Se voc\u00ea usa um bloco "try", deve suced\u00ea-lo ou com
um bloco "catch" ou com um bloco "finally" (ou 
ambos). O padr\u00e3o correto \u00e9
   try {
      comandos;
   }
   catch(Exception e) {
     comandos;
   }
   finally {
      comandos;
   }

* does not take parameters
O tipo utilizado n\u00e3o \u00e9 parametrizado.
Voc\u00ea n\u00e3o pode fornecer um par\u00e2metro aqui.

wrong number of type arguments; required *
Nenhuma ajuda dispon\u00edvel.

type variable {0} occurs more than once in result type of {1}; cannot be left uninstantiated
Nenhuma ajuda dispon\u00edvel.

type variable {0} occurs more than once in type of {1}; cannot be left uninstantiated
Nenhuma ajuda dispon\u00edvel.

unclosed character literal
\u00c9 prov\u00e1vel que voc\u00ea tenha declarado um caractere literal e
n\u00e3o tenha fechado o ap\u00f3strofo: '.

unclosed comment
\u00c9 prov\u00e1vel que voc\u00ea tenha aberto um coment\u00e1rio e
n\u00e3o o tenha fechado: */

unclosed string literal
\u00c9 prov\u00e1vel que voc\u00ea tenha declarado um literal String
(limitado por aspas) e tenha se esquecido de fech\u00e1-lo
com ". Um string deve ser fechado na mesma linha em que
inicia.

undefined label: *
A vari\u00e1vel que voc\u00ea est\u00e1 tentando usar aqui n\u00e3o 
foi encontrada. Ou ela n\u00e3o foi declarada ou foi
declarada em algum lugar fora do contexto.
A primeira possibilidade pode ter sido resultado de
algum erro de digita\u00e7\u00e3o no nome da vari\u00e1vel.
Verifique se a vari\u00e1vel est\u00e1 escrita corretamente,
incluindo as letras mai\u00fasculas ("umNumero" n\u00e3o \u00e9
o mesmo que "umnumero"!).
A segunda possibilidade acontece quando uma vari\u00e1vel
\u00e9 declarada dentro de um bloco. (Um bloco \u00e9 um par de
chaves, como este { }). Se voc\u00ea declara uma vari\u00e1vel
dentro de um la\u00e7o, por exemplo, ela s\u00f3 ser\u00e1 vis\u00edvel
l\u00e1 dentro. Como regra geral: uma vari\u00e1vel torna-se
invis\u00edvel ap\u00f3s um fecha-chaves (}) que encerra
o bloco no qual ela est\u00e1 declarada.

unreachable statement
Este comando nunca ser\u00e1 executado. Se voc\u00ea
examinar o c\u00f3digo com cuidado notar\u00e1 que o 
fluxo de controle \u00e9 tal que ele nunca 
atingir\u00e1 este comando. Apague-o, caso 
n\u00e3o queira que ele seja executado, ou ent\u00e3o
corrija seu c\u00f3digo.

initializer must be able to complete normally
Voc\u00ea n\u00e3o pode lan\u00e7ar exce\u00e7\u00f5es ou terminar
blocos de inicializa\u00e7\u00e3o est\u00e1ticos. Voc\u00ea deve
deix\u00e1-los terminar a execu\u00e7\u00e3o naturalmente.

* must be caught or declared to be thrown
Seu c\u00f3digo fez uma chamada a um m\u00e9todo que pode
lan\u00e7ar uma exce\u00e7\u00e3o. Voc\u00ea tem duas escolhas: ou 
captura esta exce\u00e7\u00e3o ou declara que seu m\u00e9todo
repassa a exce\u00e7\u00e3o. Se voc\u00ea quiser capturar a exce\u00e7\u00e3o,
deve usar um bloco
   try 
   {
      ...
   }
   catch(...)
   {
      ...
   }
Se voc\u00ea quiser pass\u00e1-la adiante, deve escrever
a seguinte declara\u00e7\u00e3o
   throws <NomeExce\u00e7\u00e3o>
na assinatura do m\u00e9todo.

'void' type not allowed here
O tipo void n\u00e3o pode ser utilizado neste contexto.
Ele \u00e9 um tipo especial utilizado para indicar
aus\u00eancia de tipo de retorno em m\u00e9todos. Ele n\u00e3o
pode ser usado para declarar vari\u00e1veis.

* not allowed here
Voc\u00ea utilizou um modificador de acesso (tal como "private",
"protected", etc.). Este modificador n\u00e3o \u00e9 permitido
neste ponto.

* might already have been assigned to
Uma vari\u00e1vel "final" s\u00f3 pode receber atribui\u00e7\u00e3o uma vez.
(A sua vari\u00e1vel em quest\u00e3o aqui \u00e9 final). Seu c\u00f3digo
possui duas atribui\u00e7\u00f5es para esta vari\u00e1vel, o compilador
est\u00e1 achando que eles podem ser executados.

* might not have been initialized
Voc\u00ea est\u00e1 utilizando uma vari\u00e1vel local que pode n\u00e3o
ter sido inicializada antes do primeiro uso. Na d\u00favida,
inicialize-a na declara\u00e7\u00e3o.

variable {0} might be assigned in loop
Nenhuma ajuda dispon\u00edvel.

error while writing *
Nenhuma ajuda dispon\u00edvel.

* is public, should be declared in a file named *
Classes p\u00fablicas devem ficar em arquivos cujo nome
seja o mesmo da classe, com uma extens\u00e3o ".java".
Por exemplo, a classe p\u00fablica Foo tem que estar
num arquivo cujo nome seja "Foo.java".

cannot read: *
Nenhuma ajuda dispon\u00edvel.

* uses or overrides a deprecated API.
Voc\u00ea est\u00e1 utilizando um m\u00e9todo n\u00e3o mais recomendado.
\u00c9 prov\u00e1vel que exista exista um outro m\u00e9todo que 
ofere\u00e7a esta funcionalidade. Consulte a documenta\u00e7\u00e3o
da API para mais detalhes.

* has been deprecated
Voc\u00ea est\u00e1 utilizando um m\u00e9todo que n\u00e3o \u00e9 mais recomendado.
\u00c9 prov\u00e1vel que exista um outro m\u00e9todo que 
ofere\u00e7a esta funcionalidade. Consulte a documenta\u00e7\u00e3o
da API para mais detalhes.

';' expected
Est\u00e1 faltando um ponto-e-v\u00edrgula no final da linha.
Pode ser a linha marcada no editor ou a acima dela.

'case', 'default' or '}' expected
Nenhuma ajuda dispon\u00edvel.

'class' or 'interface' expected
A palavra "class" ou "interface" \u00e9 esperada
no in\u00edcio do arquivo fonte. Ela est\u00e1 faltando
(ou h\u00e1 algum lixo antes dela atrapalhando)

'.class' expected
Nenhuma ajuda dispon\u00edvel.

'(' or '[' expected
Parece que h\u00e1 algum par\u00eantesis ou colchete descasado
no seu c\u00f3digo, o que est\u00e1 confundindo o compilador.
Cuidadosamente, verifique seu c\u00f3digo em busca de
delimitadores descasados.

* expected
O s\u00edmbolo na mensagem de erro era esperado
neste ponto do c\u00f3digo. Ele n\u00e3o foi encontrado,
em seu lugar havia um outro s\u00edmbolo qualquer.
Tente pensar porque este s\u00edmbolo era esperado aqui.

orphaned *
Nenhuma ajuda dispon\u00edvel.

cannot access *
Nenhuma ajuda dispon\u00edvel.

type parameter {0} is not within its bound *
Nenhuma ajuda dispon\u00edvel.

type parameters of {0} cannot be determined
Nenhuma ajuda dispon\u00edvel.

incompatible types*
Uma express\u00e3o de um certo tipo era requerida aqui.
Voc\u00ea forneceu uma express\u00e3o de um tipo diferente
e n\u00e3o compat\u00edvel. (E.g. colocar String quando um
int era esperado).

inconvertible types*
O tipo utilizado aqui n\u00e3o p\u00f4de ser convertido
automaticamente para o tipo requerido.

possible loss of precision
Nenhuma ajuda dispon\u00edvel.

unexpected type
Uma express\u00e3o de um certo tipo era requerida aqui.
Voc\u00ea forneceu uma express\u00e3o de um tipo diferente
e n\u00e3o compat\u00edvel. (E.g. colocar String quando um
int era esperado).

abstract {0} {1} cannot be accessed directly
Nenhuma ajuda dispon\u00edvel.

*An explicit 'this' qualifier must be used to select the desired instance.
Nenhuma ajuda dispon\u00edvel.

* cannot be referenced from a static context
Voc\u00ea est\u00e1 tentando acessar um campo ou m\u00e9todo de
inst\u00e2ncia a partir de um m\u00e9todo de classe. Isto n\u00e3o
\u00e9 permitido. Vari\u00e1veis e m\u00e9todos de inst\u00e2ncia pertencem
a um objeto. M\u00e9todos de classe (static) s\u00f3 podem
chamar outros m\u00e9todos de classe da sua classe. 

cannot resolve symbol*
Voc\u00ea est\u00e1 utilizando um s\u00edmbolo aqui (um nome de uma
vari\u00e1vel, um m\u00e9todo ou uma classe) que n\u00e3o foi declarada
em nenhum escopo vis\u00edvel. Verifique o nome - voc\u00ea
cometeu algum erro de digita\u00e7\u00e3o? Ou apenas esque\u00e7eu
de declar\u00e1-lo? Ou talvez voc\u00ea tenha declarado num
escopo que n\u00e3o \u00e9 vis\u00edvel daqui.

{0}; {1} and {2} are static
Nenhuma ajuda dispon\u00edvel.

{0}; overridden method is {1}
Nenhuma ajuda dispon\u00edvel.

* attempting to assign weaker access privileges; was *
Voc\u00ea est\u00e1 sobrepondo um m\u00e9todo e est\u00e1 mudando o modificador
de acesso (private, protected, public). Voc\u00ea s\u00f3 pode mudar o 
modificador de acesso para permitir um acesso mais amplo (e.g.
de private para public), nunca para estreit\u00e1-lo (e.g. de public
para private). Claro, voc\u00ea tamb\u00e9m pode deix\u00e1-lo inalterado.

* overridden method does not throw *
Voc\u00ea est\u00e1 sobrepondo um m\u00e9todo e o est\u00e1 fazendo lan\u00e7ar
uma exce\u00e7\u00e3o. M\u00e9todos sobrepostos n\u00e3o podem lan\u00e7ar exce\u00e7\u00f5es
que o m\u00e9todo sobreposto (superclasse) tamb\u00e9m n\u00e3o lance.
O m\u00e9todo na subclasse pode lan\u00e7ar menos exce\u00e7\u00f5es, nunca mais.

* attempting to use incompatible return type
Nenhuma ajuda dispon\u00edvel.

* is already defined in this compilation unit
Voc\u00ea est\u00e1 usando este nome duas vezes aqui. Escolha um
outro nome para seu identificador.

{0} is already defined in a single-type import
Nenhuma ajuda dispon\u00edvel.

* conflicts with a compiler-synthesized symbol in *
Nenhuma ajuda dispon\u00edvel.
