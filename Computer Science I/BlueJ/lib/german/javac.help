as of release 1.4, 'assert' is a keyword, and may not be used as an identifier
Das Wort 'assert' ist nun Teil der Sprache Java
und hat eine spezielle Bedeutung (es ist ein 
Schl\u00fcsselwort). Es kann nicht verwendet werden,
um Variablen oder Methoden zu benennen. Bitte
w\u00e4hlen Sie einen anderen Namen.

qualified new of static class
Leider kein Hilfetext verf\u00fcgbar.

* is abstract; cannot be instantiated
Die Klasse ist als 'abstract' deklariert. Das
bedeutet, dass sie Methoden enth\u00e4lt, die sie 
aber nicht implementiert (abstrakte Methoden).
Sie k\u00f6nnen keine Objekte von abstrakten Klassen
erzeugen. Sie m\u00fcssen eine von der abstrakten
Klasse abgeleitete Klasse finden oder schreiben,
die alle abstrakten Methoden implementiert. Von
dieser Klasse k\u00f6nnen Sie dann Objekte erzeugen.

abstract methods cannot have a body
Sie haben eine Methode als 'abstract' deklariert
und haben einen Methodenrumpf geschrieben. Das 
ist ein Widerspruch. Abstrakte Methodendeklarationen
besitzen nur einen Methodenkopf, gefolgt von einem
Strichpunkt. Entfernen Sie entweder das Wort 
"abstract" oder den Methodenrumpf.

* is already defined in *
In dieser Methode gibt es bereits eine Variable
(oder vielleich einen Parameter) mit demselben
Namen. Verwenden Sie einen anderen Namen. (Oder
haben Sie vielleicht dieselbe Variable gemeint?
Dann entfernen Sie die Typangabe, sodass es nicht
wie eine neue Variablendeklaration aussieht.)

anonymous class implements interface; cannot have arguments
Leider kein Hilfetext verf\u00fcgbar.

anonymous class implements interface; cannot have qualifier for new
Leider kein Hilfetext verf\u00fcgbar.

array required, but *
Sie verwenden hier eine Syntax, die so aussieht, als 
wolltebn Sie auf ein Arrayelement zugreifen. Die 
Variable, die Sie meinen, ist allerdings kein Array.

break outside switch or loop
Die "break"-Anweisung verl\u00e4sst einen Block wie etwa
eine "switch"-Anweisung oder eine Schleife ("for"-,
"while"- oder "do"-Schleife). Ausserhalb eines solchen
Blocks kann "break" nicht angewendet werden.

* must be first statement in constructor
In jeder Klasse, die eine Superklasse (\u00fcbergeordnete
Klasse) besitzt, sollten Sie als Allererstes den 
Konstruktor der Superklasse aufrufen. Dazu f\u00fcgen Sie
    super(...);
als erste ausf\u00fchrbare Zeile Ihres Konstruktors ein
(und ersetzen die Punkte durch die entsprechenden
Parameter). Der Versuch, die Variablen der Superklasse
zu verwenden, bevor deren Konstruktor aufgerufen wurde,
f\u00fchrt zu \u00c4rger!

cannot access *
Leider kein Hilfetext verf\u00fcgbar.

cannot assign a value to final variable *
Die Variable, der Sie hier etwas zuweisen wollen,
wurde als "final" deklariert. Das bedeutet, dass
Sie ihren Wert sp\u00e4ter nicht mehr \u00e4ndern d\u00fcrfen.
Wenn Sie den Wert wirklich \u00e4ndern m\u00fcssen, entfernen
Sie "final" aus der Variablendeklaration.

type variables cannot be dereferenced
Sie k\u00f6nnen keine Punktnotation verwenden, um auf Attribute
oder Methoden von Typvariablen zuzugreifen.

* cannot be dereferenced
Sie verwenden die Punktnotation, um eine Variable oder
eine Methode eines anderen Objekts anzusprechen. Die 
Variable, die Sie verwenden, ist allerdings nicht vom
Typ eines Objekts -- sie besitzt keine Variablen oder
Methoden.

cannot inherit from final *
Die Superklasse (die Klasse, die nach dem Schl\u00fcsselwort
"extends" aufscheint) ist als "final" deklariert. Das
bedeutet, dass sie abgeleitete Klassen ausdr\u00fccklich
verhindert. Tut uns Leid -- Sie k\u00f6nnen nicht ableiten,
wenn die Superklasse das nicht will ...

* before supertype constructor has been called
In jeder Klasse, die eine Superklasse (\u00fcbergeordnete
Klasse) besitzt, sollten Sie als Allererstes den 
Konstruktor der Superklasse aufrufen. Dazu f\u00fcgen Sie
    super(...);
als erste ausf\u00fchrbare Zeile Ihres Konstruktors ein
(und ersetzen die Punkte durch die entsprechenden
Parameter). Der Versuch, die Variablen der Superklasse
zu verwenden, bevor deren Konstruktor aufgerufen wurde,
f\u00fchrt zu \u00c4rger!

cannot return a value from method whose result type is void
Der R\u00fcckgabetyp "void" in einer Methodensignatur bedeutet,
dass die Methode kein Ergebnis zur\u00fcckliefert. Der Methoden-
rumpf sollte keine "return"-Anweisung beinhalten.

cannot select a static class from a parameterized type
Leider kein Hilfetext verf\u00fcgbar.

* cannot be inherited with different arguments:*
Leider kein Hilfetext verf\u00fcgbar.

'catch' without 'try'
"catch" ist ein Schl\u00fcsselwort, das nur nach einem "try"-Block
auftreten darf. Die korrekte Anordnung ist:
   try {
      Anweisungen;
   }
   catch(Exception e) {
      Anweisungen;
   }

* clashes with package of same name
Vergewissern Sie sich, dass die Klasse und das Paket
unterschiedliche Namen haben. F\u00fcr gew\u00f6hnlich sollten
Klassennamen mit einem Grossbuchstaben beginnen, w\u00e4hrend
Packagenamen mit einem Kleinbuchstaben beginnen.

code too large for try statement
Innerhalb dieses "try"-Blocks befinden sich zuviele
Anweisungen. Verschieben Sie den Code in eine getrennte
Methode und f\u00fcgen Sie hier einen Methodenaufruf ein.

constant expression required
Sie haben hier eine Variable oder einen Ausdruck 
angegeben, aber das ist nicht zul\u00e4ssig. Sie d\u00fcrfen
hier nur Konstante verwenden. Konstante sind Zahlen
(wie etwa 42) oder Symbole, die als "final" deklariert
sind.

continue outside of loop
Die "continue"-Anweisung wird benutzt, um sofort den
n\u00e4chsten Schleifendurchlauf zu beginnen. Sie hat 
ausserhalb einer Schleife keine Bedeutung und kann
nur innerhalb einer "for"-, "while"- oder "do"-Schleife
verwendet werden.

cyclic inheritance involving *
Sie versuchen hier, eine Klasse abzuleiten, aber diese
Klasse ist bereits als von Ihrer Klasse abgeleitet
deklariert! Nun, das kann nicht funktionieren! Sie
m\u00fcssen entscheiden, welche Klasse die Superklasse ist
und welche die abgeleitete.

* does not exist
Sie haben hier einen Namen benutzt (m\u00f6glicherweise, um
sich auf eine Variable, eine Klasse oder ein Paket 
zu beziehen), den es nicht gibt. Es gibt weder eine
Variable, noch eine Klasse noch ein Paket mit diesem
Namen.

duplicate class:*
Es scheint bereits eine Klasse mit diesem Namen zu geben.

duplicate case label
Sie haben innerhalb ein- und derselben "switch"-Anweisung
denselben Label zweimal vergeben.

duplicate default label
Sie haben innerhalb ein- und derselben "switch"-Anweisung
zweimal "default" geschrieben. Das k\u00f6nnen Sie nicht tun --
einmal ist genug.

'else' without 'if'
Das Schl\u00fcsselwort "else" kann nur als Teil einer 
"if"-Anweisung auftauchen, in der Form
   if (Bedingung)
     Anweisung;
   else
     Anweisung;
Haben Sie vielleicht bloss die Klammern rund um die 
Anweisungen vergessen? Wenn Sie nach dem "if" mehr als
eine Anweisung haben, m\u00fcssen Sie Klammern verwenden wie 
hier:
   if (Bedingung)
   {
     Anweisung1;
     Anweisung2;
   }
   else
   {
     Anweisung3;
   }

empty character literal
Sie haben ein leeres Zeichen geschrieben. Sie k\u00f6nnen '' 
nicht schreiben. Eine Zeichenkonstante besteht aus einem
einzelnen Zeichen, das unter einfachen Anf\u00fchrungszeichen
steht, z.B. 'a'. Zumeist kann nur ein einziges Zeichen 
zwischen den Anf\u00fchrungszeichen stehen. Die einzige Ausnahme
bildet der Backslash (Escape-Zeichen) als erstes Zeichen, 
der f\u00fcr die Angabe von Sonderzeichen wie '\n' oder '\t' 
verwendet wird.

* has already been caught
Diese "catch"-Anweisung ist nutzlos. Sie kann niemals 
ausgef\u00fchrt werden, weil alle Exceptions, die sie
auffangen soll, bereits von einer anderen "catch"-Anweisung
weiter oben aufgefangen werden.

* is never thrown in body of corresponding try statement
Sie haben angegeben, hier eine Exception auffangen 
zu wollen. Aber ich kann Ihnen sagen, dass diese Exception
hier niemals auftreten wird! Im "try"-Block gibt es keine
Anweisung, die diese Exception hervorrufen kann.

'finally' without 'try'
"catch" ist ein Schl\u00fcsselwort, das nur nach einem "try"-Block
auftreten darf. Die korrekte Anordnung ist:
   try {
      Anweisungen;
   }
   catch(Exception e) {
      Anweisungen;
   }
   finally {
      Anweisungen;
   }

floating point number too large
Das System kann mit Gleitkommazahlen dieser Gr\u00f6\u00dfe nicht umgehen.

floating point number too small
Das System kann mit Gleitkommazahlen dieser Kleinheit nicht umgehen.

inner classes cannot have static declarations
Sie k\u00f6nnen keine statischen Typen in verschachtelten Klassen 
deklarieren. Wenn Sie hier einen statischen Typ ben\u00f6tigen, 
deklariern Sie ihn in der \u00e4usseren Klasse.

illegal character:*
In der Sourcedatei befindet sich hier ein unzul\u00e4ssiges Zeichen,
das m\u00f6glicherweise unsichtbar ist. Wenn Sie es nicht finden und
l\u00f6schen k\u00f6nnen, l\u00f6schen Sie die ganze Zeile und geben Sie sie 
neu ein.

illegal combination of modifiers: *
Sie haben versucht, zwei Typ-Modifizierer in nicht zul\u00e4ssiger Weise 
miteinander zu kombinieren. Wahrscheinlich widersprechen einander
die Bedeutungen der beiden Modifizierer, beispielsweise wie wenn eine 
Methode als sowohl als "abstract" als auch als "native", "final",
"private" oder "synchronized" deklariert w\u00fcrde.

illegal escape character
Ein Sonderzeichen wird durch einen Backslash und ein zweites
Zeichen dargestellt, z.B. '\n'. Es gibt nur eine begrenzte 
Menge von Zeichen, die nach dem Backslash zul\u00e4ssig sind. Es
sind dies \n, \t, \b, \r, \f, \\, \', \" und Ziffern. Wenn Sie
den Backslash selbst darstellen wollen, scheiben Sie "\\" --
dies wird in Ihrem String mit einen einzelnen Backslash 
ersetzt.

illegal forward reference
Leider kein Hilfetext verf\u00fcgbar.

illegal initializer for *
Leider kein Hilfetext verf\u00fcgbar.

illegal line end in character literal
Sie haben einen Zeilenvorschub, wo ein Zeichen angegeben sein sollte.
Das k\u00f6nnen Sie nicht tun. Wenn Sie das Zeichen f\u00fcr einen Zeilen-
vorschub angeben wollen, schreiben Sie es als '\n'.

* is not an inner class
Leider kein Hilfetext verf\u00fcgbar.

illegal start of expression
Leider kein Hilfetext verf\u00fcgbar.

illegal start of type
An einer Stelle im Sourcetext, wo der Name eines Typs erwartet wurde,
wurde etwas Anderes gefunden (h\u00f6chstwahrscheinlich ein Java-Schl\u00fcssel-
wort). \u00dcberpr\u00fcfen Sie diese Zeile nach fehlerhaften Typdefinitionen.

illegal unicode escape
Leider kein Hilfetext verf\u00fcgbar.

improperly formed type, some parameters are missing
Leider kein Hilfetext verf\u00fcgbar.

incomparable types: *
Leider kein Hilfetext verf\u00fcgbar.

integer number too large: *
Sie haben eine Zahl angegeben, die f\u00fcr den hier erwarteten Datentyp zu
gross ist. Sie m\u00fcssen einen gr\u00f6sseren Datentyp verwenden (z.B. "long"
anstelle von "int").

internal error; cannot instantiate *
Leider kein Hilfetext verf\u00fcgbar.

* but with different return type
Sie versuchen vielleicht, zwei Methoden zu schreiben, die bis auf
den R\u00fcckgabetyp dieselbe Signatur haben. Das ist nicht zul\u00e4ssig.
Die wahrscheinlichste Ursache ist, dass Ihre Klasse zwei Schnittstellen
implementiert. Jede Schnittstelle hat eine Methode mit denselben Namen
und Parametern, aber mit unterschiedlichem R\u00fcckgabetyp. Sie k\u00f6nnen nicht
beide diese Schnittstellen implementieren, solange Sie nicht eine davon
\u00e4ndern, um dies zu vermeiden. Entweder benennen Sie die Methode um oder
gleichen die R\u00fcckgabetypen an.

interface expected here
Ein Interface kann nur von einem anderen Interface abgeleitet werden.
Der Name, den Sie nach "extends" angegeben haben, ist kein Interface.

interface methods cannot have body
Methoden in Interfaces d\u00fcrfen nur Deklarationen sein. Das bedeutet, dass
sie nur einen Methodenkopf enthalten sollten, gefolgt von einen Strichpunkt.
Es sollte kein Methodenrumpf vorhanden sein.

hexadecimal numbers must contain at least one hexadecimal digit
Sie haben eine Hexadezimalzahl angegeben. (Das macht man, indem man die
Zahl mit "0X" beginnt). In Hexadezimalzahlen muss nach dem "X"
mindestens eine Ziffer folgen.

invalid method declaration; return type required
Eine Methodendeklaration muss auch einen R\u00fcckgabetyp deklarieren.
Wenn Ihre Methode z.B. einen String zur\u00fcckgibt, schreiben Sie:
    public String meineMethode();
Wenn Sie keinen R\u00fcckgabewert von dieser Methode wollen, m\u00fcssen Sie
das Schl\u00fcsselwort "void" angeben, um anzuzeigen, dass es keinen
R\u00fcckgabetyp gibt. Zum Beispiel:
    public void meineMethode();

* already in use
In dieser Methode gibt es bereits eine Variable
(oder vielleich einen Parameter) mit demselben
Namen. Verwenden Sie einen anderen Namen. (Oder
haben Sie vielleicht dieselbe Variable gemeint?
Dann entfernen Sie die Typangabe, sodass es nicht
wie eine neue Variablendeklaration aussieht.)

* is accessed from within inner class; needs to be declared final
Auf lokale Variable kann von inneren Klassen \u00fcblicherweise nicht 
zugegriffen werden. Das ist aber genau das, was Sie hier versuchen. 
Sie haben zwei M\u00f6glichkeiten: Sie k\u00f6nnen den Zugriff auf die lokale
Variable unterlassen, oder Sie k\u00f6nnen die Variable "final" machen --
dann k\u00f6nnen Sie auf sie zugreifen.

malformed floating point literal
Sie haben in einer Gleitkommazahl einen Schreibfehler gemacht.
(Eine Gleitkommazahl ist eine Zahl, die einen Kommapunkt enth\u00e4lt).
Beispiele richtig geschriebener Gleitkommazahlen sind:
18.0      18.     1.8e1     .18E2

missing method body, or declare abstract
Methoden m\u00fcssen entweder einen Methodenrumpf besitzen oder abstrakt 
sein. Ein Methodenrumpf ist der Block in geschwungenen Klammern { }, 
der dem Methodenkopf folgt und Anweisungen enth\u00e4lt.
Wenn eine Methode keinen Methodenrumpf besitzt, muss sie das 
Schl\u00fcsselwort "abstract" in ihrem Methodenkopf enthalten, z.B.
    public abstract int getAnswer();

missing return statement
Sie haben hier eine Methode, die laut Deklaration einen R\u00fcckgabewert
liefert. Allerdings gibt es im Methodenrumpf keine "return"-Anweisung.
Das passt nicht zusammen. Sie m\u00fcssen entweder:
   - den R\u00fcckgabetyp der Methode als "void" deklarieren, wenn sie 
     keinen Wert zur\u00fcckliefern soll, oder
   - an das Ende der Methode eine "return"-Anweisung mit dem richtigen
     R\u00fcckgabetyp schreiben, z.B.
         return 42;
Der Typ des R\u00fcckgabewerts muss mit dem im Methodenkopf deklarierten Typ
\u00fcbereinstimmen.

missing return value
Sie haben hier eine "return"-Anweisung geschrieben, die keinen Wert
zur\u00fcckliefert. Der Methodenkopf allerdings deklariert, dass diese
Methode einen R\u00fcckgabewert besitzt. Sie m\u00fcssen entweder:
   - deklarieren, dass diese Methode keinen R\u00fcckgabewert liefert
     (indem Sie "void" als R\u00fcckgabetyp im Methodenkopf angeben), oder
   - Sie m\u00fcssen einen Wert des richtigen Typs zur\u00fcckliefern, z.B.
         return 42;
     oder
         return "Martin";

name clash: *
Sie haben zwei Methoden mit demselben Namen definiert. Dies ist nur
erlaubt, wenn die eine die andere \u00fcberschreibt (was hier nicht der Fall 
ist). Einer der beiden Namen muss ge\u00e4ndert werden.

* is reserved for internal use
Der angezeigte Ausdruck ist f\u00fcr die interne Verwendung reserviert,
wenn es der Name einer Variablen oder Klasse ist, m\u00fcssen Sie ihn
\u00e4ndern.

native methods cannot have a body
Sie haben eine Methode als "native" deklariert, und Sie haben einen
Methodenrumpf geschrieben. Deklarationen von "native"-Methoden 
haben nur einen Methodenkopf, gefolgt von einem Strichpunkt.
Entfernen Sie entweder das Schl\u00fcsselwort "native" oder den 
Methodenrumpf.

no enclosing instance of type {0} is in scope
Leider kein Hilfetext verf\u00fcgbar.

no interface expected here
Sie beziehen sich hier auf ein Interface (m\u00f6glicherweise im 
"extends"-Teil einer Klassendeklaration). Eine Klasse kann nur
von anderen Klassen abgeleitet werden, nicht von Interfaces.
Wenn Sie dieses Interface implementieren wollen, verwenden Sie
stattdessen das Schl\u00fcsselwort "implements".

{0} has no match in entry in {1}; required {2}
Leider kein Hilfetext verf\u00fcgbar.

* is not defined in a public class or interface; cannot be accessed from outside package
Leider kein Hilfetext verf\u00fcgbar.

* cannot be accessed from outside package
Die Klasse, die Sie hier zu verwenden versuchen, ist nicht \u00f6ffentlich,
d.h. ihre Definition beginnt nicht mit
   public class ...
Wenn eine Klasse nicht \u00f6ffentlich ist, kann sie nicht au\u00dferhalb ihres
eigenen Pakets benutzt werden. Falls Sie die Klasse wirklich benutzen
m\u00fcssen, m\u00fcssen Sie ihre Definition \u00e4ndern und sie \u00f6ffentlich machen.

not a loop label: *
Die Marke, die Sie f\u00fcr Schleifenoperationen verwenden, wie z.B.
   continue <label>;
muss so definiert werden, dass sie die Schleife markiert, d.h.
sie muss unmittelbar vor dem Beginn der Schleife gesetzt sein.
Die Marke, die Sie angegeben haben, ist nicht an der richtigen
Stelle - sie markiert keine Schleife.

not a statement
Sie haben hier eine Codezeile geschrieben, die keine vollst\u00e4ndige
Anweisung ist. Bitte \u00fcberpr\u00fcfen Sie nochmals, was Sie bezwecken und
wie Sie dies tun sollten.

not an enclosing class:*
You have tried to access the current object ('this') pointer
of another class outside your own. This is only allowed
if that other class is an enclosing class of the current one
(in other words: in an inner class you can access the outer
class, but no others).

* cannot be applied to *
Der Operator, den Sie hier einsetzen, kann f\u00fcr den Wertetyp, f\u00fcr
den Sie ihn einsetzen, nicht benutzt werden. Entweder verwenden
Sie hier den falschen Typ oder den falschen Operator.

* clashes with class of same name
Vergewissern Sie sich, dass die Klasse und das Paket
unterschiedliche Namen haben. F\u00fcr gew\u00f6hnlich sollten
Klassennamen mit einem Grossbuchstaben beginnen, w\u00e4hrend
Packagenamen mit einem Kleinbuchstaben beginnen.

possible fall-through into case
Leider kein Hilfetext verf\u00fcgbar.

error reading *
Leider kein Hilfetext verf\u00fcgbar.

recursive constructor invocation
Sie haben Code geschrieben, der seinen Konstruktor sich selbst aufrufen 
l\u00e4sst. Das ist nicht zul\u00e4ssig (und w\u00fcrde h\u00f6chstwahrscheinlich zu einer
Endlosschleife f\u00fchren).

* is ambiguous, both *
Der Name, der in dieser Meldung aufscheint, kann nicht richtig aufgel\u00f6st
werden, weil in den Pakete, die Sie importiert haben, mehr als eine 
Klasse oder Interface mit diesem Namen definiert sind.
Sie k\u00f6nnen entweder hier auf die Klasse mit ihrem vollst\u00e4ndigen Namen 
zugreifen (z.B. java.util.List) oder die Klasse mit ihrem vollst\u00e4ndigen
Namen importieren (z.B. import java.util.List).

repeated interface
Sie haben dasselbe Interface zweimal in derselben "implements"-Deklaration
angef\u00fchrt. Einmal ist genug. Mein Ged\u00e4chtnis ist nicht so schlecht!

repeated modifier
In dieser Deklaration haben Sie denselben Modifizierer zweimal angef\u00fchrt. Ein
Modifizierer ist ein Schl\u00fcsselwort wie etwa "final", "static", "public", 
"private", "volatile", ...

{0} has {1} access in {2}
Leider kein Hilfetext verf\u00fcgbar.

return outside method
'return'-Anweisungen k\u00f6nnen nur innerhalb von Methoden verwendet werden
(nicht in Initialisierungsbl\u00f6cken oder anderen nicht-Methoden 
Code-Abschnitten).

signature does not match {0}; incompatible interfaces
Leider kein Hilfetext verf\u00fcgbar.

signature does not match {0}; incompatible supertype
Leider kein Hilfetext verf\u00fcgbar.

* should be declared abstract; it does not define *
Die aktuelle Klasse ist von einer abstrakten Klasse oder einem Interface
abgeleitet. Abstrakte Klassen und Interfaces definieren Methoden, ohne deren
Implementation anzugeben. Diese Klasse definiert Implementationen nicht f\u00fcr 
alle Methoden, die noch welche ben\u00f6tigen. Daher ist diese Klasse selbst noch
abstrakt (was bedeutet, dass sie noch Methoden ohne Implementation enth\u00e4lt).
Sie m\u00fcssen diese Klasse entweder als abstrakt deklarieren, indem Sie sie mit
   public abstract class ...
anstatt von bloss 
   public class ...
beginnen lassen, oder Sie m\u00fcssen f\u00fcr die in der Fehlermeldung genannte Methode
eine Implementation zur Verf\u00fcgung stellen.

* is not abstract and does not override abstract method *
Die aktuelle Klasse erbt von einer abstrakten Klasse
oder einem Interface. Abstrakte Klassen und Interfaces
definieren Methoden ohne eine Implementierung anzugeben.
Diese Klasse definiert nicht f\u00fcr alle Methoden eine
Implementierung, denen diese noch fehlt, wodurch diese
Klasse selbst noch abstrakt ist (d.h. sie hat immer noch
Methoden ohne Implementierung).
Sie m\u00fcssen diese Klasse entweder als abstrakt deklarieren,
indem Sie sie so anfangen lassen
   public abstract class ...
anstatt nur mit
   public class ...
oder Sie m\u00fcssen f\u00fcr die in der Fehlermeldung genannte
Methode eine Implementierung einf\u00fcgen.

error writing source; cannot overwrite input file *
Leider kein Hilfetext verf\u00fcgbar.

'try' without 'catch' or 'finally'
Wenn Sie einen "try"-Block verwenden, muss nach ihm ein "catch"-Block oder 
ein "finally"-Block oder beide folgen. Die korrekte Anordnung ist:
   try {
      Anweisungen;
   }
   catch(Exception e) {
      Anweisungen;
   }
   finally {
      Anweisungen;
   }

* does not take parameters
Der Typ, den Sie benutzen, ist kein parameterisierter Typ.
Sie k\u00f6nnen hier keinen Parameter angeben.

wrong number of type arguments; required *
Leider kein Hilfetext verf\u00fcgbar.

type variable {0} occurs more than once in result type of {1}; cannot be left uninstantiated
Leider kein Hilfetext verf\u00fcgbar.

type variable {0} occurs more than once in type of {1}; cannot be left uninstantiated
Leider kein Hilfetext verf\u00fcgbar.

unclosed character literal
Sie haben wahrscheinlich eine Zeichenkonstante deklariert, ohne das 
abschliessende einfache Anf\u00fchrungszeichen anzugeben: '.

unclosed comment
Sie haben wahrscheinlich einen Kommentar geschrieben, ohne ihn 
mit */ abzuschliessen.

unclosed string literal
Sie haben wahrscheinlich eine Stringkonstante deklariert, ohne das 
abschliessende doppelte Anf\u00fchrungszeichen anzugeben: ".

undefined label: *
Die Variable, die Sie hier verwenden wollen, kann nicht gefunden 
werden. Sie wurde entweder nie deklariert, oder sie wurde an einer
Stelle deklariert, die von hier nicht sichtbar ist.
Der erste Fall tritt h\u00e4ufig bei Tippfehlern in einer Variablen auf.
\u00dcberpr\u00fcfen Sie, dass die Variable richtig geschrieben ist, inklusive
Gross-/Kleinschreibung ("eineZahl" ist nicht dasselbe wie "einezahl"!).
Der zweite Fall kommt vor, wenn die Variable innerhalb eines Blocks
deklariert ist. (Ein Block ist ein Paar geschwungener Klammern { }.)
Wenn Sie eine Variablendeklaration innerhalb einer Schleife haben, 
dann ist die Variable nur innerhalb dieser Schleife sichtbar. Als
Daumenregel: eine Variable wird unsichtbar nach der geschwungenen 
Klammer (}), die den Block abschliesst, in dem die Variable 
deklariert wurde.

unreachable statement
Diese Anweisung wird nie ausgef\u00fchrt werden. Wenn Sie den Code 
sorgf\u00e4ltig untersuchen, werden Sie feststellen, dass der
Programmfluss diese Anweisung nie erreichen kann. Wenn Sie 
wirklich nicht wollen, dass diese Anweisung ausgef\u00fchrt wird,
l\u00f6schen Sie sie, oder berichtigen Sie den Code.

initializer must be able to complete normally
Sie k\u00f6nnen in statischen Initialisierungsbl\u00f6cken keine 
Exceptions ausl\u00f6sen oder solche Bl\u00f6che vorzeitig
beende. Sie m\u00fcssen die Ausf\u00fchrung solcher Bl\u00f6cke bis zum Ende
zulassen.

* must be caught or declared to be thrown
Ihr Code ruft eine Methode auf, die eine Exception ausl\u00f6sen
kann. Sie haben zwei M\u00f6glichkeiten: Sie k\u00f6nnen entweder diese
Exception abfangen, oder Sie k\u00f6nnen deklarieren, dass 
Ihre Methode diese weitergibt. Wenn Sie die Exception 
abfangen wollen, m\u00fcssen sie einen Block der Form
   try 
   {
      ...
   }
   catch(...)
   {
      ...
   }
verwenden.
Wenn Sie die Exception weitergeben wollen, m\u00fcssen Sie die
Deklaration 
   throws <ExceptionName>
in die Signatur Ihrer Methode aufnehmen.

'void' type not allowed here
Der Typ "void" kann in diesem Zusammenhang nicht verwendet werden.
Er ist ein spezieller Typ, der verwendet wird, um anzuzeigen, dass
eine Methode keinen R\u00fcckgabetyp besitzt. Er kann nicht als Typ 
einer Variablen verwendet werden.

* not allowed here
Sie haben einen Zugriffs-Modifizierer verwendet (wie etwa "private", 
"protected", etc.). Dieser Modifizierer ist an dieser Stelle nicht
zul\u00e4ssig.

wrong number of type arguments; required *
Leider kein Hilfetext verf\u00fcgbar.

* might already have been assigned to
Einer "final"-Variablen kann nur einmal etwas zugewiesen werden.
(Ihre hier in Frage stehende Variable ist "final".) In Ihrem 
Code befinden sich zwei Zuweisungen an diese Variable, und der
Compiler h\u00e4lt es f\u00fcr m\u00f6glich, dass beide Zuweisungen ausgef\u00fchrt
werden.

* might not have been initialized
Sie verwenden eine lokale Variable, die nicht mit Sicherheit 
initialisiert wurde, bevor sie hier angesprochen wird. Im
Zweifelsfall initialisieren Sie sie bei der Deklaration.

variable {0} might be assigned in loop
Leider kein Hilfetext verf\u00fcgbar.

error while writing *
Leider kein Hilfetext verf\u00fcgbar.

* is public, should be declared in a file named *
"public"-Klassen m\u00fcssen sich in einer Datei befinden, die denselben
Namen hat wie die "public"-Klasse, mit der Erweiterung ".java". Die
"public"-Klasse Dingsda zum Beispiel muss sich in einer Datei mit
dem Namen "Dingsda.java" befinden.

cannot read: *
Leider kein Hilfetext verf\u00fcgbar.

* uses or overrides a deprecated API.
Sie verwenden eine Methode, die nicht l\u00e4nger empfohlen wird. Es ist recht 
wahrscheinlich, dass es eine andere Methode oder Klasse gibt, die diese
Funktionalit\u00e4t aufweist. Sehen Sie in der API-Dokumentation nach weiteren
Details.

* has been deprecated
Sie verwenden eine Methode, die nicht l\u00e4nger empfohlen wird. Es ist recht 
wahrscheinlich, dass es eine andere Methode oder Klasse gibt, die diese
Funktionalit\u00e4t aufweist. Sehen Sie in der API-Dokumentation nach weiteren
Details.

';' expected
Am Ende einer Zeile fehlt ein Strichpunkt. Es k\u00f6nnte die im Editor
markierte Zeile sein, oder die Zeile dar\u00fcber.

'case', 'default' or '}' expected
Leider kein Hilfetext verf\u00fcgbar.

'class' or 'interface' expected
Ziemlich am Beginn jeder Sourcedatei wird das Wort "class" oder 
"interface" erwartet. Es fehlt hier, oder es stehen Dinge davor,
die dort nicht hingeh\u00f6ren.

'.class' expected
Leider kein Hilfetext verf\u00fcgbar.

'(' or '[' expected
Es sieht so aus, als w\u00e4re eine ungerade Anzahl von Klammern in Ihrem
Code, die den Compiler verwirrt. \u00dcberpr\u00fcfen Sie den Code sorgf\u00e4ltig 
auf zusammengeh\u00f6rige \u00f6ffnende und schliessende Klammern.

* expected
Das in der Fehlermeldung genannte Symbol wurde an dieser Stelle
im Code erwartet; stattdessen fand sich ein anderes Symbol. Versuchen
Sie, dar\u00fcber nachzudenken, warum dieses Symbol hier erwartet wird.

orphaned *
Leider kein Hilfetext verf\u00fcgbar.

cannot access *
Leider kein Hilfetext verf\u00fcgbar.

type parameter {0} is not within its bound *
Leider kein Hilfetext verf\u00fcgbar.

type parameters of {0} cannot be determined
Leider kein Hilfetext verf\u00fcgbar.

incompatible types*
Hier ist Ausdruck eines bestimmten Typs erforderlich. Sie schrieben einen
Ausdruck eines anderen, unvereinbaren Typs (z.B. Sie schrieben einen 
String, wo ein int erwartet wurde.)

inconvertible types*
The type you have used here cannot be automatically
converted to the type required.

possible loss of precision
Leider kein Hilfetext verf\u00fcgbar.

unexpected type
Hier wird ein Ausdruck eines bestimmten Typs erwartet.
Sie haben einen Ausdruck mit einem anderen Typ angegeben,
der nicht kompatibel ist (z.B. haben Sie einen String 
verwendet, wo ein int erwartet wurde).

abstract {0} {1} cannot be accessed directly
Leider kein Hilfetext verf\u00fcgbar.

*An explicit 'this' qualifier must be used to select the desired instance.
Leider kein Hilfetext verf\u00fcgbar.

non-static {0} {1} cannot be referenced from a static context
Leider kein Hilfetext verf\u00fcgbar.

*cannot be referenced from a static context
Sie versuchen, auf ein Objektattribut oder eine Objektmethode von
einer Klassenmethode aus zuzugreifen. Das ist nicht erlaubt. Die
Objektattribute und Objektmethoden geh\u00f6ren zu einem Objekt, w\u00e4hrend
Sie kein aktuelles Objekt in einer Klassenmethode haben.
Klassenmethoden k\u00f6nnen nur andere Klassenmethoden ihrer Klasse aufrufen
(oder sie ben\u00f6tigen ein bestimmtes Objekt f\u00fcr den Aufruf).

cannot find symbol*
Sie benutzen hier ein Symbol (einen Namen einer Variablen, Methode 
oder Klasse), das nicht im aktuellen Sichtbarkeitsbereich deklariert
wurde. \u00dcberpr\u00fcfen Sie die Schreibung dieses Bezeichners -
haben Sie sich vertippt? Oder habe Sie vergessen, ihn zu deklarieren?
Oder Sie haben ihn deklariert, aber er ist nicht sichtbar von hier.

cannot resolve symbol*
Sie benutzen hier ein Symbol (einen Namen einer Variablen, Methode 
oder Klasse), das nicht im aktuellen Sichtbarkeitsbereich deklariert
wurde. \u00dcberpr\u00fcfen Sie die Schreibung dieses Bezeichners -
haben Sie sich vertippt? Oder habe Sie vergessen, ihn zu deklarieren?
Oder Sie haben ihn deklariert, aber er ist nicht sichtbar von hier.

{0}; {1} and {2} are static
Leider kein Hilfetext verf\u00fcgbar.

{0}; overridden method is {1}
Leider kein Hilfetext verf\u00fcgbar.

* attempting to assign weaker access privileges; was *
Sie \u00fcberschreien hier eine Methode und ver\u00e4ndern ihren 
Zugriffs-Modifizierer (private, protected, public). Sie k\u00f6nnen
den Zugriffs-Modifizierer nur \u00e4ndern, um einen breiteren Zugriff
zu gew\u00e4hren (z.B. von private auf public), aber es ist nicht erlaubt,
den Zugriff einzuengen (z.B. von public auf private). 
Auf jeden Fall kann er auch so bleiben, wie er war.

* overridden method does not throw *
Sie \u00fcberschreien hier eine Methode und erzeugen eine Ausnahme.
\u00dcberschreibende Methoden d\u00fcrfen keine Ausnahmen erzeugen, die die
\u00fcberschriebene (Oberklassen-) Methode nicht auch erzeugt. Die Methode
in der Unterklasse kann weniger Ausnahmen erzeugen, aber nicht mehr.

* attempting to use incompatible return type
Leider kein Hilfetext verf\u00fcgbar.

* is already defined in this compilation unit
Sie haben den Namen hier doppelt verwendet. W\u00e4hlen Sie
einen anderen Namen f\u00fcr diesen Bezeichner.

{0} is already defined in a single-type import
Leider kein Hilfetext verf\u00fcgbar.

* conflicts with a compiler-synthesized symbol in *
Leider kein Hilfetext verf\u00fcgbar.

reached end of file while parsing
Das bedeutet, dass ein Block mit '{' ge\u00f6ffnet aber nicht mit '}' geschlossen
wurde. Es gibt also entweder ein '{', wo es nicht ben\u00f6tigt wird, oder es
fehlt ein '}', wo es gebraucht wird.
