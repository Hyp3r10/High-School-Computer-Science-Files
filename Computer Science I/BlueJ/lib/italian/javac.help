#BlueJ/Greenfoot dialogues.
#Mon Nov 10 12:25:22 GMT 2008
as of release 1.4, 'assert' is a keyword, and may not be used as an identifier
La parola 'assert' \u00e8 diventata parte del linguaggio
Java, e quindi ha un significato speciale: \u00e8 una
parola chiave. Non \u00e8 quindi pi\u00f9 utilizzabile come
nome di variabile o di metodo. Scegli un altro nome.

qualified new of static class
Non \u00e8 disponibile nessun aiuto

* is abstract; cannot be instantiated
La classe \u00e8 stata dichiarata "abstract", per cui
contiene alcuni metodi per i quali non \u00e8 fornita
l'implementazione (i "metodi astratti").
Non \u00e8 possibile creare oggetti da classi astratte:
devi trovare o scrivere una sottoclasse della
classe astratta che implementa tutti i metodi
astratti. Da questa classe \u00e8 poi possibile
creare oggetti.

abstract methods cannot have a body
Hai dichiarato "abstract" il metodo, ma hai
anche aggiunto il corpo del metodo. Ci\u00f2 \u00e8 una
contraddizione: le dichiarazioni di metodo astratto
sono costituite dal solo header del metodo, seguito
da un punto e virgola. Elimina la parola chiave
"abstract", oppure il corpo del metodo.

* is already defined in *
In questo metodo c'\u00e8 gi\u00e0 una variabile
(o un parametro) che ha lo stesso nome.
Usa un nome differente per questa variabile.
Se invece vuoi usare proprio la stessa
variabile, allora elimina la dichiarazione
di tipo, in modo tale che questa non appaia
come una nuova dichiarazione.

anonymous class implements interface; cannot have arguments
Non \u00e8 disponibile nessun aiuto

anonymous class implements interface; cannot have qualifier for new
Non \u00e8 disponibile nessun aiuto

array required, but *
La sintassi che stai utilizzando suggerisce che
vorresti accedere ad un elemento di array. Per\u00f2
la varibile a cui fai riferimento non \u00e8 un array.

break outside switch or loop
L'istruzione "break" spezza un blocco, quale
una istruzione "switch", o un ciclo ("for",
"while" o "do"). Non pu\u00f2 essere usata al
di fuori di tali blocchi.

* must be first statement in constructor
Quando usi una classe che ha una superclasse, per
prima cosa dovresti richiamare il costruttore
della superclasse. Per fare ci\u00f2 aggiungi
    super(...);
come prima linea del tuo costruttore (sostituisci i
punti di sospensione con i parametri appropriati).
Usare un membro della superclasse prima di
richiamare il costruttore pu\u00f2 portare a problemi.

cannot access *
Non \u00e8 disponibile nessun aiuto

cannot assign a value to final variable *
La variabile a cui stai tentando di assegnare un
valore \u00e8 stata dichiarata "final"; ci\u00f2 implica che
non puoi cambiarne il valore. Se hai davvero
bisogno di cambiarne il valore, elimina la parola
chiave "final" dalla dichiarazione della variabile.

type variables cannot be dereferenced
La notazione col punto non pu\u00f2 essere usata per
accedere a campi o metodi membri di un tipo di variabile.

* cannot be dereferenced
Stai usando la notazione con il punto per accedere ad
un campo o ad un metodo di un altro oggetto.
Per\u00f2 la variabile che stai usando non \u00e8 un oggetto:
non ha metodi n\u00e9 campi.

cannot inherit from final *
La superclasse (la classe specificata dopo
la parola chiave "extends") \u00e8 dichiarata
final. Ci\u00f2 significa che sono esplicitamente
proibite sottoclassi. Purtroppo non puoi
derivarne sottoclassi se non vuole...

* before supertype constructor has been called
Quando usi una classe che ha una superclasse,
per prima cosa dovresti richiamare il costruttore
della superclasse. Per fare ci\u00f2 aggiungi
    super(...);
come prima linea del tuo costruttore (sostituisci i
punti di sospensione con i parametri appropriati).
Usare un membro della superclasse prima di
richiamare il costruttore pu\u00f2 portare a problemi.

cannot return a value from method whose result type is void
Se un metodo dichiara di restituire un valore di tipo void,
allora significa che il metodo non ritorna nulla; quindi il
corpo del metodo non dovrebbe avere istruzioni di return.

cannot select a static class from a parameterized type
Non \u00e8 disponibile nessun aiuto

* cannot be inherited with different arguments:*
Non \u00e8 disponibile nessun aiuto

'catch' without 'try'
"catch" \u00e8 una parola chiave Java che pu\u00f2 comparire
solo dopo un blocco "try". Lo schema corretto \u00e8:
   try {
      istruzioni;
   }
   catch(Exception e) {
     istruzioni;
   }

* clashes with package of same name
Assicurati che la classe ed il package
abbiano nomi differenti. Per convenzione le
classi dovrebbero iniziare con una lettera
maiuscola, i package con una minuscola.

code too large for try statement
In questa istruzione try c'\u00e8 troppo codice.
Metti il codice in un metodo separato e qui
metti un metodo che lo richiama.

constant expression required
Qui non \u00e8 consentito usare una variabile o
una  espressione: puoi solo usare costanti.
Le costanti sono numeri letterali (come 42),
oppure identificatori dichiarati "final".

continue outside of loop
L'istruzione "continue" \u00e8 usata per
iniziare immediatamente la prossima
iterazione di un ciclo. Non ha alcun senso
al di fuori di un ciclo: pu\u00f2 essere usata
solo nei cicli "for", "while", "do".

cyclic inheritance involving *
Stai tentando di estendere una classe, la
quale per\u00f2 dichiara gi\u00e0 di estendere la tua!
Bene, ci\u00f2 non funziona. Devi decidere qual \u00e8
la superclasse e quale la sottoclasse.

* does not exist
Il nome che hai usato (che potrebbe volersi
riferire ad una variabile, ad una classe o
ad un package) non esiste. Non c'\u00e8 n\u00e9 una
variabile, n\u00e9 una classe, n\u00e9 un package con
questo nome.

duplicate class:*
Pare che una classe con questo nome ci sia gi\u00e0.

duplicate case label
Hai usato la stessa etichetta due volte
in una istruzione "switch".

duplicate default label
Hai usato due volte "default" nella stessa istruzione
switch. Non puoi farlo: una volta \u00e8 sufficiente.

'else' without 'if'
La parola chiave "else" pu\u00f2 comparire solo come
parte di una istruzione "if", nella forma
   if (condizione)
     istruzione;
   else
     istruzione;
Forse hai semplicemente dimenticato le parentesi graffe
intorno alle istruzioni? Se hai pi\u00f9 di una istruzione
dopo un if, devi aggiungere delle parentesi graffe:
   if (condizione) 
   {
      istruzione1;
      istruzione2;
   }
   else
   {
      istruzione3;
   }

empty character literal
Hai scritto un carattere vuoto: non puoi scrivere ''.
Una costante carattere \u00e8 un solo carattere fra singoli
apici, ad esempio 'a'. Molto spesso c'\u00e8 un solo carattere
fra gli apici, a meno di caratteri speciali (detti di 
escape) specificati con una sequenza di due caratteri
il primo dei quali \u00e8 '\' (ad esempio '\n' o '\t').

* has already been caught
Questa istruzione catch \u00e8 inutile. Non pu\u00f2 mai
essere eseguita, in quanto tutte le eccezioni 
che dichiara di catturare sono comunque
catturate da altre catch precedenti.

* is never thrown in body of corresponding try statement
Hai dichiarato di voler catturare una eccezione,
che per\u00f2 certamente non si verificher\u00e0 mai.
Non c'\u00e8 nessuna istruzione nel blocco "try"
che pu\u00f2 dar luogo a questa eccezione.

'finally' without 'try'
"finally" \u00e8 una parola chiave Java che pu\u00f2 essere
usata solo dopo un blocco "try". Lo schema corretto \u00e8
   try {
      istruzioni;
   }
   catch(Exception e) {
     istruzioni;
   }
   finally {
      istruzioni;
   }

floating point number too large
Il sistema non \u00e8 in grado di trattare numeri in
virgola mobile cos\u00ec grandi.

floating point number too small
Il sistema non \u00e8 in grado di trattare numeri in
virgola mobile cos\u00ec piccoli.

inner classes cannot have static declarations
Non puoi dichiarare tipi statici in classi
annidate. Se hai bisogno di tipi statici,
dichiarali nella classe esterna.

illegal character:*
Nel file sorgente c'\u00e8 un carattere non consentito.
Il carattere potrebbe essere invisibile. Se non lo
riesci trovare per cancellarlo, elimina l'intera
linea e riscrivila.

illegal combination of modifiers: *
Hai tentato di combinare due modificatori Java
la cui associazione non \u00e8 consentita. Forse 
hanno significato in contrasto. Ad esempio la
definizione di un metodo come astratto e 
nativo, finale, privato o sincronizzato.

illegal escape character
E' stato specificato un carattere di escape non
consentito. Un carattere di escape \u00e8 costituito da
un carattere '\' seguito da un secondo carattere,
ad esempio '\n', e indica caratteri speciali.
I caratteri di escape sono un insieme fisso:
\n, \t, \b, \r, \f, \\, \', \" e \ seguito da un
numero. Per far comparire il carattere '\' in una
stringa, usa il carattere di escape '\\'.

illegal forward reference
Non \u00e8 disponibile nessun aiuto

illegal initializer for *
Non \u00e8 disponibile nessun aiuto

illegal line end in character literal
Hai dichiarato la fine di una linea ma dovrebbe esserci
ancora un carattere letterale. Se vuoi specificare il
carattere di fine linea, usa il carattere di escape '\n'.

illegal qualifier; {0} is not an inner class
Non \u00e8 disponibile nessun aiuto

illegal start of expression
Non \u00e8 disponibile nessun aiuto

illegal start of type
Nel codice sorgente, nel punto in cui dovrebbe
esserci un nome di tipo, c'\u00e8 qualcos'altro
(probabilmente una parola chiave Java). Verifica
questa linea e correggi la definizione di tipo.

illegal unicode escape
Non \u00e8 disponibile nessun aiuto

improperly formed type, some parameters are missing
Non \u00e8 disponibile nessun aiuto

incomparable types: *
Non \u00e8 disponibile nessun aiuto

integer number too large: *
Hai scritto un numero che \u00e8 troppo grande per
il tipo di dato che ci si aspetterebbe qui.
Devi usare un tipo di dato pi\u00f9 grande
(ad esempio, "long" invece di "int").

internal error; cannot instantiate *
Non \u00e8 disponibile nessun aiuto

* but with different return type
Probabilmente hai tentato di scrivere due metodi le
cui firme si differenziano solo per il tipo ritornato.
Ci\u00f2 non \u00e8 consentito. Probabilmente la tua classe
implementa due interfacce, entrambe con un metodo con
lo stesso nome e parametri, ma differente tipo ritornato.
Non \u00e8 possibile implementare le due interfacce in questa
situazione: rinomina il metodo, oppure rendi il tipo
ritornato uguale nelle due interfacce.

interface expected here
Una interfaccia pu\u00f2 estendere solo un'altra interfaccia.
Il nome specificato dopo la parola chiave "extends" non
\u00e8 una interfaccia.

interface methods cannot have body
I metodi in una interfaccia possono essere
solo dichiarati, per cui pu\u00f2 esserci solo
l'header seguito da un punto e virgola.
Non deve esserci il corpo del metodo.

hexadecimal numbers must contain at least one hexadecimal digit
Hai specificato un numero esadecimale (ci\u00f2 si ottiene
facendo iniziare il numero con "0X"). Nei numeri
esadecimali devi avere almeno una cifra dopo la 'X'.

invalid method declaration; return type required
Una dichiarazione di metodo deve comprendere la
dichiarazione del tipo ritornato. Ad esempio, se
il metodo ritorna uno String, bisogna scrivere:
    public String mioMetodo();
Se il tuo metodo non deve ritornare alcun valore,
usa la parola speciale "void" per indicare che non
c'\u00e8 nessun tipo ritornato. Ad esempio:
    public void mioMetodo();

* already in use
In questo metodo c'\u00e8 gi\u00e0 una variabile
(o un parametro) che ha lo stesso nome.
Usa un nome differente per questa variabile.
Se invece vuoi usare proprio la stessa
variabile, allora elimina la dichiarazione
di tipo, in modo tale che questa non appaia
come una nuova dichiarazione.

* is accessed from within inner class; needs to be declared final
Le variabili locali in genere non sono accessibili da
classi interne, ma ci\u00f2 \u00e8 proprio quello che qui stai
cercando di fare. Hai due scelte: puoi eliminare questo
accesso alla variabile locale, oppure puoi dichiararla
"final", e quindi potrai accedervi.

malformed floating point literal
C'\u00e8 qualche errore nella scrittura di numeri in
virgola mobile (un numero in virgola mobile \u00e8
contraddistinto da un punto decimale). Esempi di
numeri in virgola mobile scritti correttamente:
18.0      18.     1.8e1     .18E2

missing method body, or declare abstract
I metodi devono avere un corpo, oppure essere
astratti. Il corpo di un metodo \u00e8 il blocco fra
parentesi graffe { } che segue l'header del metodo
e contiene istruzioni. Se un metodo non ha un
corpo, deve avere la parola chiave "abstract" nel
suo header, come ad esempio in:
    public abstract int getAnswer();

missing return statement
Qui hai un metodo che dichiara di restituire un valore.
Per\u00f2 non c'\u00e8 alcuna istruzione "return" nel corpo del
metodo. Ci\u00f2 non \u00e8 corretto; hai due possibilit\u00e0:
   - dichiarare "void "il tipo restituito dal metodo
     se non vuoi che sia restituito alcun valore
   - scrivere una istruzione "return" con il tipo
     corretto alla fine del metodo, ad esempio:
         return 42;
Il tipo restituito dal metodo deve essere lo stesso
che \u00e8 stato dichiarato nell'header.

missing return value
C'\u00e8 una istruzione "return" che non restituisce un valore.
Per\u00f2 nell'header si dichiara che questo metodo
restituisce un valore. Puoi dichiarare nell'header che
non viene restituito alcun valore (specificando "void"
come tipo restituito), oppure devi restituire un valore
di tipo corretto, ad esempio:
    return 42;
oppure:
    return "Marvin";

name clash: *
Hai definito due metodi con lo stesso nome. Ci\u00f2 \u00e8
consentito solo se uno dei due ridefinisce l'altro, e non
\u00e8 questo il caso. Uno dei due nomi deve essere cambiato.

* is reserved for internal use
Il termine mostrato \u00e8 riservato per usi interni. Se \u00e8
il nome di una classe o una variabile, devi cambiarlo.

native methods cannot have a body
Hai dichiarato un metodo "native" e hai scritto il
corpo del metodo. Ma le dichiarazioni di metodi nativi
sono costituite dal solo header, seguite da un punto e
virgola. Devi eliminare la parola chiave "native",
oppure il corpo del metodo.

no enclosing instance of type {0} is in scope
Non \u00e8 disponibile nessun aiuto

no interface expected here
Stai facendo riferimento ad una interfaccia (in una
dichiarazione di classe "extends", probabilmente).
Una classe pu\u00f2 solo estendere altre classi, non
interfacce. Se vuoi implementare questa interfaccia,
devi usare la parola chiave "implements".

{0} has no match in entry in {1}; required {2}
Non \u00e8 disponibile nessun aiuto

* is not defined in a public class or interface; cannot be accessed from outside package
Non \u00e8 disponibile nessun aiuto

* cannot be accessed from outside package
Stai cercando di usare una classe che non \u00e8 pubblica.
Cio\u00e8, la sua definizione non inizia con:
   public class ... 
Se una classe non \u00e8 pubblica, non pu\u00f2 essere usata al
di fuori del suo package. Se devi effettivamente usare
la classe, devi rendere la sua definizione pubblica.

not a loop label: *
L'etichetta che usi per il ciclo:
   continue <etichetta>;
deve essere definita per contrassegnare un ciclo,
quindi deve essere messa immediatamente prima
dell'inizio del ciclo. L'etichetta in questione non
\u00e8 al posto giusto, e non contrassegna un ciclo.

not a statement
Hai scritto una linea di codice che non \u00e8 una
istruzione completa. Verifica ci\u00f2 che volevi
fare e come l'hai fatto.

not an enclosing class:*
Stai cercando di accedere al puntatore dell'oggetto ('this')
di una classe al di fuori della tua. Ci\u00f2 \u00e8 permesso solo se
l'altra classe incorpora la tua. In altre parole, da una
classe pi\u00f9 interna puoi accedere a quella esterna, ma
non ad altre.

* cannot be applied to *
L'operatore non pu\u00f2 essere usato con questo tipo.
Stai sbagliando il tipo, oppure stai sbagliando
l'operatore.

* clashes with class of same name
Assicurati che la classe ed il package
abbiano nomi differenti. Per convenzione le
classi dovrebbero iniziare con una lettera
maiuscola, i package con una minuscola.

possible fall-through into case
Non \u00e8 disponibile nessun aiuto

error reading *
Non \u00e8 disponibile nessun aiuto

recursive constructor invocation
Nel codice che hai scritto questo
costruttore richiama s\u00e9 stesso.
Ci\u00f2 \u00e8 scorretto (e probabilmente
causa un ciclo infinito).

* is ambiguous, both *
L'identificatore indicato non pu\u00f2 essere correttamente
risolto, perch\u00e9 nei package che hai importato ci sono
pi\u00f9 classi o interfacce con questo nome. Devi fare
riferimento alla classe con il nome esteso completo
(come java.util.List), oppure importare la classe con il
nome esteso completo (ad esempio import java.util.List).

repeated interface
Hai elencato una interfaccia per
due volte nella stessa dichiarazione
"implements". Una \u00e8 sufficiente:
non ho una memoria cos\u00ec cattiva.

repeated modifier
Hai scritto lo stesso modificatore per due volte
nella stessa dichiarazione. Un modificatore \u00e8
una parola chiave quale final, static, public,
private, volatile, ...

{0} has {1} access in {2}
Non \u00e8 disponibile nessun aiuto

return outside method
Puoi usare l'istruzione 'return' solo in un
metodo, non in un blocco di inizializzazione
o in altri segmenti di codice.

signature does not match {0}; incompatible interfaces
Non \u00e8 disponibile nessun aiuto

signature does not match {0}; incompatible supertype
Non \u00e8 disponibile nessun aiuto

* should be declared abstract; it does not define *
La classe corrente eredita da una classe astratta
o da una interfaccia. Le classi astratte e le
interfacce definiscono alcuni metodi senza darne
l'implementazione. Questa classe non fornisce
l'implementazione a tutti i metodi che ne sono
privi, per cui la classe stessa \u00e8 astratta (cio\u00e8
ha anch'essa metodi privi di implementazione).
Devi dichiarare questa classe astratta:
    public abstract class ...
e non solo
    public class ...
oppure devi fornire una implementazione per il
metodo specificato nel messaggio d'errore.

error writing source; cannot overwrite input file *
Non \u00e8 disponibile nessun aiuto

'try' without 'catch' or 'finally'
Un blocco "try" deve necessariamente essere
seguito o da un blocco "catch" o da un blocco
"finally", o da entrambi. Lo schema corretto \u00e8:
   try {
     istruzioni;
   } 
   catch(Exception e) { 
     istruzioni; 
   }
   finally {
      istruzioni;
   }

* does not take parameters
Il tipo che hai usato non \u00e8 parametrizzato:
non puoi usare un parametro.

type variable {0} occurs more than once in result type of {1}; cannot be left uninstantiated
Non \u00e8 disponibile nessun aiuto

type variable {0} occurs more than once in type of {1}; cannot be left uninstantiated
Non \u00e8 disponibile nessun aiuto

unclosed character literal
Probabilmente hai dichiarato un carattere letterale
ma non hai messo l'apice singolo di chiusura: '.

unclosed comment
Probabilmente hai scritto un commento ma non l'hai
delimitato con i corretti caratteri di chiusura: */

unclosed string literal
Probabilmente hai dichiarato una String letterale
ma non hai messo il doppio apice di chiusura: ".
La stringa deve iniziare e terminare con doppio
apice ", e sulla stessa riga.

undefined label: *
Non riesco a trovare la variabile che stai
cercando di usare. Non \u00e8 stata dichiarata, oppure
\u00e8 dichiarata in qualche punto non raggiungibile.
Nel primo caso probabilmente hai sbagliato a
scriverne il nome, quindi verifica che sia scritto
correttamente incluse le maiuscole e le minuscole
("aNumber" \u00e8 diverso da "anumber"). Nel secondo
caso la variabile \u00e8 stata dichiarata in un blocco
(un blocco \u00e8 delimitato da parentesi graffe { });
ad esempio, se hai la dichiarazione di variabile
in un ciclo, allora la variabile \u00e8 visibile solo
all'interno del ciclo. Una regola facile: una
variabile diventa invisibile dopo la parentesi
graffa chiusa (}) che chiude il blocco in cui \u00e8
stata dichiarata.

unreachable statement
Questa istruzione non pu\u00f2 mai essere eseguita.
Se esamini il codice attentamente noterai
che il flusso di controllo non pu\u00f2 mai
raggiungere l'istruzione. Se effettivamente
non vuoi che sia eseguita cancellala,
altrimenti correggi il codice.

initializer must be able to complete normally
Non puoi generare una eccezione o fermare in
altro modo i blocchi dell'inizializzatore
statico. Devi attendere la fine dell'esecuzione.

* must be caught or declared to be thrown
Il codice esegue una chiamata a metodo che pu\u00f2
generare una eccezione. Devi catturare l'eccezione,
oppure devi dichiarare che il tuo metodo la
inoltra. Se vuoi catturare l'eccezione devi
usare uno schema tipo:
   try
   {
      ...
   }
   catch(...)
   {
      ...
   }
Se vuoi inoltrarla devi invece scrivere la
dichiarazione:
   throws <NomeEccezione>
nella dichiarazione del metodo.

'void' type not allowed here
Il tipo void non pu\u00f2 essere usato in questo contesto.
E' un tipo speciale che \u00e8 usato per indicare che da
un metodo non viene ritornato nessun valore. Non pu\u00f2
essere usato come tipo di una variabile.

* not allowed here
Hai usato un modificatore d'accesso (quale "private",
"protected", etc.) che non pu\u00f2 essere usato in questa
posizione.

* might already have been assigned to
Si tratta di una variabile dichiarata final. E' possibile
assegnare il valore ad una variabile final solo una volta,
ma nel codice ci sono due assegnamenti ed il compilatore
ritiene che entrambi potrebbero essere eseguiti.

* might not have been initialized
Questa variabile locale potrebbe non essere
stata ancora inizializzata. Nel dubbio puoi
inizializzarla nella dichiarazione.

* might be assigned in loop
Non \u00e8 disponibile nessun aiuto

error while writing *
Non \u00e8 disponibile nessun aiuto

* is public, should be declared in a file named *
Una classe pubblica deve essere in un file il cui
nome \u00e8 lo stesso della classe, ma con in pi\u00f9
l'estensione ".java". Ad esempio la classe pubblica
Foo deve essere in un file di nome "Foo.java".

cannot read: *
Non \u00e8 disponibile nessun aiuto

* uses or overrides a deprecated API.
Stai usando un metodo che \u00e8 ormai sconsigliato.
Molto probabilmente esiste un altro metodo o classe
che fornisce la funzionalit\u00e0 di cui hai bisogno:
consulta la documentazione delle API.

* has been deprecated
Stai usando un metodo che \u00e8 ormai sconsigliato.
Molto probabilmente esiste un altro metodo o classe
che fornisce la funzionalit\u00e0 di cui hai bisogno:
consulta la documentazione delle API.

';' expected
Alla fine della riga manca un punto e virgola.
Controlla la linea indicata dall'editor, oppure
la linea precedente.

'case', 'default' or '}' expected
Non \u00e8 disponibile nessun aiuto

'class' or 'interface' expected
Nei pressi dell'inizio del file dovrebbe comparire
la parola "class" oppure "interface". In questo
caso non c'\u00e8 (oppure \u00e8 preceduta da qualcosa che
non dovrebbe esserci).

'.class' expected
Non \u00e8 disponibile nessun aiuto

'(' or '[' expected
A quanto pare nel codice c'\u00e8 un numero dispari di
parentesi, e ci\u00f2 confonde il compilatore. Verifica
attentamente che nel codice ad ogni parentesi aperta
corrisponda una successiva parentesi chiusa.

* expected
In questo punto del codice dovrebbe comparire
il simbolo in questione. Non c'\u00e8, ed al suo
posto compare qualcos'altro. Cerca di
capire perch\u00e9 dovrebbe esserci il simbolo.

orphaned *
Non \u00e8 disponibile nessun aiuto

type parameter {0} is not within its bound *
Non \u00e8 disponibile nessun aiuto

type parameters of {0} cannot be determined
Non \u00e8 disponibile nessun aiuto

incompatible types*
Qui \u00e8 richiesta una espressione di un certo tipo,
invece c'\u00e8 una espressione di un tipo diverso e
non compatibile (ad esempio hai messo una String
dove dovrebbe esserci un int).

inconvertible types*
Il tipo che hai usato non pu\u00f2 essere convertito
automaticamente al tipo richiesto.

possible loss of precision
Non \u00e8 disponibile nessun aiuto

unexpected type
Qui \u00e8 richiesta una espressione di un certo tipo,
ma hai messo una espressione di un altro tipo non
compatibile (ad esempio c'\u00e8 una String dove
invece \u00e8 richiesto un int)

abstract {0} {1} cannot be accessed directly
Non \u00e8 disponibile nessun aiuto

*An explicit 'this' qualifier must be used to select the desired instance.
Non \u00e8 disponibile nessun aiuto

* cannot be referenced from a static context
Stai cercando di accedere ad un campo o metodo di una
istanza da un metodo statico, e ci\u00f2 non \u00e8 consentito.
I campi e i metodi di istanza appartengono ad un oggetto,
mentre invece nel caso di metodi statici non hai nessun
oggetto attivo. I metodi statici possono richiamare solo
altri metodi statici nella loro classe, oppure devono
usare esplicitamente un oggetto per la chiamata.

cannot resolve symbol*
Qui stai usando un simbolo (un nome di variabile, di
metodo o di classe) che sembra non sia stato dichiarato.
Verifica se hai scritto correttamente il nome. O forse
hai dimenticato di dichiararlo? Oppure l'hai dichiarato
ma non ha visibilit\u00e0 qui?

{0}; {1} and {2} are static
Non \u00e8 disponibile nessun aiuto

{0}; overridden method is {1}
Non \u00e8 disponibile nessun aiuto

* attempting to assign weaker access privileges; was *
Hai ridefinito un metodo e cambiato il modificatore di
accesso (private, protected, public), ma puoi cambiare il
modificatore di accesso solo in modo da permettere accesso
pi\u00f9 ampio (ad esempio da private a public), ma non pi\u00f9
ristretto (ad esempio da public a private). Ovviamente puoi
anche mantenere lo stesso modificatore.

* overridden method does not throw *
Hai ridefinito un metodo e generato una eccezione, ma ci\u00f2
\u00e8 possibile solo se l'eccezione \u00e8 generata anche dalla
classe ridefinita (la superclasse). Il metodo nella
sottoclasse pu\u00f2 generare un numero minore di eccezioni,
ma non maggiore.

* attempting to use incompatible return type
Non \u00e8 disponibile nessun aiuto

* is already defined in this compilation unit
Hai gi\u00e0 usato questo nome. Scegline un altro per
questo identificatore.

{0} is already defined in a single-type import
Non \u00e8 disponibile nessun aiuto

* conflicts with a compiler-synthesized symbol in *
Non \u00e8 disponibile nessun aiuto

