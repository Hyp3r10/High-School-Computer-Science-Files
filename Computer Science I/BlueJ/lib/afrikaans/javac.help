as of release 1.4, 'assert' is a keyword, and may not be used as an identifier
Die woord 'assert' is nou (sedert 1.4) deel van die Java taal
en het 'n spesiale betekenis (dit is 'n sleutelwoord).
U kan dit nie gebruik as naam vir 'n veranderlike of metode nie.
Kies asb. 'n ander naam.

qualified new of static class
Geen verdere hulp beskikbaar.

* is abstract; cannot be instantiated
Die klas is gedefinieer as "abstract". Dit beteken
dat dit metode(s) bevat waarvoor dit nie self
'n implementering verskaf nie ("abstract methods").
U kan nie objekte van abstrakte klasse skep nie.
Gebruik 'n subklas (of skryf een) van die abstrakte
klas wat al die abstrakte metodes implementeer.
Objekte kan dan van hierdie subklas geskep word.


abstract methods cannot have a body
U het 'n metode as abstrak gedeklareer en toe
nogtans 'n metodelyf geskryf. Dit is teenstrydig.
Abstrakte metodes het slegs 'n metodekopstuk 
gevolg deur 'n kommapunt.  U moet \u00f2f die woord 
"abstract" \u00f2f die metodelyf verwyder.

* is already defined in *
Daar is reeds 'n veranderlike (of dalk 
'n parameter) met dieselfde naam in 
hierdie metode. Gebruik 'n ander naam vir
hierdie een. (Of het u dalk bedoel om dieselfde 
veranderlike hier te gebruik? Dan moet u die 
naam van die tipe hier verwyder sodat dit nie
soos 'n nuwe deklarasie lyk nie.)

anonymous class implements interface; cannot have arguments
Geen verdere hulp beskikbaar.

anonymous class implements interface; cannot have qualifier for new
Geen verdere hulp beskikbaar.

array required, but *
U gebruik hier sintaks wat dit laat lyk of u
probeer om 'n skikkingelement te gebruik, 
maar die veranderlike waarna verwys word 
is egter nie 'n skikking nie.

break outside switch or loop
Die "break" stelling neem die beheer uit 'n blok
uit, byvoorbeeld uit 'n "switch"-blok of 'n lus 
("for"-, "while"- of "do"-lus). Dit kan nie
buitekan so 'n blok gebruik word nie.

* must be first statement in constructorDie heel eerste wat moet gebeur in elke klas
wat 'n superklas het, is dat die superklas se
konstruktor geroep moet word. Dit kan eksplisiet
gedoen word deur 'n re\u00ebltjie 
    super(...);
as die eerste instruksie van die konstruktor
te skryf (vervang die kolletjies met die nodige
parameters).  As mens probeer om lede van die
superklas te gebruik voordat die konstruktor
geloop het, soek mens net moeilikheid!

cannot access *
Geen verdere hulp beskikbaar.

cannot assign a value to final variable *
Die veranderlike waaraan u iets hier wil toeken
is gedeklareer as "final". Dit beteken dat sy 
waarde nie later verander kan word nie. As dit
regtig nodig is om die waarde te kan verander,
dan moet u die sleutelwoord "final" uitvee voor
die deklarasie van die veranderlike.

type variables cannot be dereferenced
U kan nie die dot-notasie gebruik om te verwys na 
velde of metodes (attribute) van tipe-veranderlikes nie.

* cannot be dereferenced
U gebruik dot-notasie om toegang te kry tot 
'n veld of metode van van 'n ander objek,
maar die veranderlike wat u gebruik is nie
'n tipe objek nie - dit het nie velde of 
metodes nie.

cannot inherit from final *
Die superklas (die klasnaam wat kom net na die
"extends" sleutelwoord) is as "final" gedeklareer.
Dit beteken dat hierdie klas geen subklasse
mag h\u00ea nie.  Jammer - u kan nie daarvan af
oorerf as die klas dit nie toelaat nie ...

* before supertype constructor has been called
Die heel eerste wat moet gebeur in elke klas
wat 'n superklas het, is dat die superklas se
konstruktor geroep moet word. Dit kan eksplisiet
gedoen word deur 'n re\u00ebltjie
    super(...);
as die eerste instruksie van die konstruktor
te skryf (vervang die kolletjies met die nodige
parameters).  As mens probeer om lede van die
superklas te gebruik voordat die konstruktor
geloop het, soek mens net moeilikheid!

cannot return a value from method whose result type is void
'n metode met 'n resultaattipe void kan nie 'n waarde
terugstuur nie.  Die metode mag dus nie 'n 
return-stelling bevat nie.

cannot select a static class from a parameterized type
Geen verdere hulp beskikbaar.

* cannot be inherited with different arguments:*
Geen verdere hulp beskikbaar.

'catch' without 'try'
"catch" is 'n Java sleutelwoord wat slegs na 'n 
"try"-blok kan voorkom. Die korrekte patroon is
   try {
      stellings;
   }
   catch(Exception e) {
      stellings;
   }

* clashes with package of same name
Maak seker dat die klas en die pakket
verskillende name het.  Klasname begin
normaalweg met 'n hoofletter, terwyl
pakketname met 'n kleinletter begin.

code too large for try statement
Daar is te veel kode in hierdie "try"-blok.
Plaas die kode in 'n aparte metode en skryf
dan net 'n metoderoep hier in die "try"-blok

constant expression required
U het 'n veranderlike of uitdrukking hier gebruik,
maar dit is onwettig.  Slegs konstantes mag hier
gebruik word.  Konstantes is vasgekodeerde getalle (soos 42)
of indentifiseerders wat as "final" gedeklareer is.

continue outside of loop
Die "continue"-stelling word gebruik om 
dadelik met die volgende herhaling van die lus
te begin.  Dit het geen betekenis buite 'n lus 
nie en kan dus net binne "for", "while" of "do"
lusse gebruik word.

cyclic inheritance involving *
Sikliese oorerwing.  U probeer hier om 'n
klas deur oorerwing uit te brei, maar daardie
klas is reeds deur oorerwing 'n uitbreiding
van hierdie klas.  Dit kan nie werk nie.
U moet besluit watter een is die superklas en
watter een is die subklas

* does not exist
Die naam wat u hier gebruik bestaan nie.
(Dit kan 'n poging wees om 'n veranderlike of
'n klas of 'n pakket te benoem.)
Daar was geen veranderlike of klas of pakket 
met hierdie naam nie.

duplicate class:*
Dit lyk of daar reeds 'n klas met hierdie naam is.

duplicate case label
U het dieselfde etiket tweemaal gebruik in 
dieselfde "switch"-stelling

duplicate default label
U het tweemaal "default" geskryf in dieselfde
"switch"-stelling.  Slegs een is toelaatbaar.

'else' without 'if'
'n 'else'-sleutelwoord kan slegs voorkom as deel van
'n 'if'-stelling in die vorm
   if (voorwaarde)
      stelling; 
   else
      stelling; 
Miskien het u net vergeet om krulhakies rondom die 
groepe stellings te plaas, soos volg:
   if (voorwaarde)
   { 
      stelling1; 
      stelling2;
   }
   else
   { 
      stelling3; 
   }

empty character literal
U het 'n karakterkonstante geskryf wat leeg is.
U mag nie '' skryf nie.  'n Karakterkonstante is
'n enkele karakter tussen enkelaanhalingstekens,
byvoorbeeld 'a'.  Normaalweg is daar presies net een
karakter tussen die aanhalingstekens - die enigste
uitsondering is waar die agteroor skuinsstreep
(bekend and die "ontsnapkarakter") wat gebruik word
om spesiale karakters aan te dui soos '\n' of '\t'.  

* has already been caught
Hierdie catch-stelling is nutteloos. Dit
sal nooit uitgevoer word nie, want alle
uitsonderings wat gedeklareer is, word reeds
gevang deur 'n ander catch-stelling daarbo.

* is never thrown in body of corresponding try statement
U het gedeklareer dat 'n uitsondering 
hier gevang moet word, maar dit blyk dat 
hierdie uitsondering nooit hier aangemeld sal
word nie, want daar is geen stelling in die
"try"-blok wat direk of indirek sal veroorsaak
dat sodanige uitsondering aangemeld word nie.

'finally' without 'try'
"finally" is 'n Java sleutelwoord wat slegs 
n\u00e1 'n "try"-blok kan voorkom. Die korrekte patroon is
   try {
      stellings;
   }
   catch(Exception e) {
     stellings;
   }
   finally {
      stellings;
   }

floating point number too large
Die stelsel kan nie wisselpuntgetalle wat so groot is hanteer nie.

floating point number too small
Die stelsel kan nie wisselpuntgetalle wat so klein is hanteer nie.


inner classes cannot have static declarations
U kan nie statiese tipes deklareer binne
geneste klasse nie. As u 'n statiese tipe hier
benodig, moet dit in die buitenste klas gedeklareer word.

illegal character:*
Daar kom 'n ontoelaatbare karakter op hierdie
plek indie bronkodel\u00eaer voor. 
Die karakter is moontlik onsigbaar. As u dit nie
kan opspoor om uit te vee nie, vee dan die hele
lyntjie uit en tik dit oor.

illegal combination of modifiers: *
U het probeer om twee modifiseerders te kombineer,
maar dit word beskou as 'n onwettige kombinasie.
Die betekenis van die een is waarskynlik teenstrydig
met die ander een.  'n Voorbeeld sou wees om te probeer
om abstract te kombineer met native, final, private of 
synchronized.

illegal escape character
'n Ontsnapkarakter word geskryf met 'n agteroor-
skuisstreep gevolg deur 'n tweede karakter,
byvoorbeeld '\n'. Dit word gebruik om spesiale
karakters mee te spesifiseer. Daar is 'n beperkte
aantal karakters wat op 'n agteroorskuisstreep kan
volg, naamlik: \n, \t, \b, \r, \f, \\, \', \" 
en getalle. As u die agteroorskuinsstreep self wil laat
skryf, gebruik dan "\\" - dit sal vervang word met 'n
enkele agteroorskuinsstreep in die string.

illegal forward reference
Geen verdere hulp beskikbaar.

illegal initializer for *
Geen verdere hulp beskikbaar.

illegal line end in character literal
Ongeldige reeleinde in karakterkonstante.
Daar is 'n reelbreuk waar daar 'n karakterkonstante
moes wees.  Dit is nie toelaatbaar nie.
As u 'n reelbreuk (nuwe lyn) wil spesifiseer, moet us
dit skryf as 'n spesiale karakter, naamlik '\n'.

illegal qualifier; {0} is not an inner class
Geen verdere hulp beskikbaar.

illegal start of expression
Geen verdere hulp beskikbaar.

illegal start of type
By 'n posisie in die bronkode waar die naam van 
'n tipe verwag is, is daar iets anders gevind  
(waarskynlik 'n Java gereserveerde sleutelwoord). 
Deursoek hierdie lyntjie vir ongeldige tipe-definisies.

illegal unicode escape
Geen verdere hulp beskikbaar.

improperly formed type, some parameters are missing
Geen verdere hulp beskikbaar.

incomparable types: *
Geen verdere hulp beskikbaar.

integer number too large: *
Hier is 'n getal gegee wat te groot is om in te pas 
in die datatipe wat hier verwag word.  Die oplossing 
is moontlik om 'n groter datatipe te gebruik byvoorbeeld 
"long" in plaas van "int".

internal error; cannot instantiate *
Geen verdere hulp beskikbaar.

* but with different return type
Hier is moontlik 'n kombinasie van twee metodes met 
dieselfde naam en parameters, maar met verskillende 
antwoord-tipes.  Dit word nie toegelaat nie.
Dit gebeur waarskynlik omdat die klas twee koppelvlakke
implementeer.  Albei koppelvlakke het 'n metode met
dieselfde naam en parameters, maar verskillende antwoord-tipes.
As dit die geval is kan hierdie koppelvlakke nie albei 
ge\u00efmplementeer word nie, tensy een van hulle verander word.
Een opsie is om een van die metodes 'n ander naam te gee,
en 'n ander opsie is om hulle antwoord-tipes dieselfde te maak.

interface expected here
'n Koppelvlak kan slegs van 'n ander koppelvlak erf. 
Die naam wat na die "extends" sleutelwoord staan, verwys nie 
na 'n koppelvlak ("interface")nie.

interface methods cannot have body
Die metodes binne koppelvlakdefinisies mag slegs deklarasies wees. 
Dit beteken dat dit moet bestaan uit 'n metode-opskrif gevolg deur 
'n kommapunt.  Hier mag dus geen kode binne die metode wees nie.

hexadecimal numbers must contain at least one hexadecimal digit 
Heksadesimale getalle moet ten minste een heksadesimale syfer bevat. 
Hier is 'n heksadesimale getal (een wat begin met "0X"). Daar moet 
ten minste een syfer na die X volg.

invalid method declaration; return type required
'n Metodedefinisie moet die antwoord-tipe (teruggee-tipe) voorskryf. 
As die metode byvoorbeeld 'n String as antwoord moet gee, dan 
kan die definisie soos volg lyk: 
    public String myMethod(); 
Indien daar geen antwoord teruggegee moet word aan die roepende 
metode nie, dan moet die spesiale sleutelword "void" gebruik word 
om aan te toon dat daar niks teruggegee word nie, byvoorbeeld: 
    public void myMethod();

* already in use
Daar is reeds 'n veranderlike (of dalk parameter)
met dieselfde naam in hierdie metode.  Gebruik 'n ander 
naam. Of as die bedoeling is om dieselfde veranderlike te 
gebruik, dan moet die tipe nie weer voor die veranderlike 
naam verskyn nie, anders lyk dit soos 'n nuwe deklarasie.

* is accessed from within inner class; needs to be declared final
Lokale veranderlikes kan nie normaalweg deur binne-klasse 
gebruik word nie - dit is wat hier probeer word. 
Daar is twee opsies:  moenie die lokale veranderlike hier 
gebruik nie, of gaan deklareer die lokale veranderlike as 
"final" sodat dit hier ook gebruik kan word.

malformed floating point literal
Hier is een of ander fout met die skryfwyse van 'n 
wisselpuntgetal (dit is 'n getal met 'n desimale punt in.)
Voorbeelde van korrekte skryfwyses is soos volg:
18.0      18.     1.8e1     .18E2

missing method body, or declare abstract
Metodes moet \u00f2f geskryf word met 'n metodelyf,
\u00f2f hulle moet as abstrak gedeklareer word.
'n Metodelyf is die blok kode tussen krulhakies { }
wat direk na die metode-opskrif gegee word.
As 'n metode nie 'n lyf het nie, moet die deklarasie
die sleutelwoord "abstract" bevat, byvoorbeeld:
    public abstract int getAnswer();

missing return statement
Hier is 'n metode wat gedeklareer is om 'n waarde as antwoord
terug te gee aan die roepende metode.  Daar is egter geen
"return"-stelling in die lyf van die metode nie.
Los die probleem op deur een van die volgende te doen:
   - deklareer die teruggee-tipe van die metode as "void"
     as die metode nie 'n antwoord moet gee nie, of
   - skryf 'n "return"-stelling met die nodige waarde
     aan die einde van die metode, byvoorbeeld:
         return 42;
     of
         return "Marvin";
Die tipe van die terugee-waarde moet pas by die gedeklareerde 
tipe in die opskrif van die metode.

missing return value
Hier is 'n "return"-stelling wat nie 'n waarde teruggee nie.
Los die probleem op deur een van die volgende te doen:
   - deklareer die teruggee-tipe van die metode as "void"
     as die metode nie 'n antwoord moet gee nie, of
   - skryf 'n "return"-stelling met die nodige waarde
     aan die einde van die metode, byvoorbeeld:
         return 42;
     of
         return "Marvin";
Die tipe van die terugee-waarde moet pas by die gedeklareerde 
tipe in die opskrif van die metode.

name clash: *
U het twee metodes met dieselfde naam gedefinieer.  Dit word 
slegs toegelaat indien die een die ander een oorheers/herdefinieer,
maar dit is nie die geval hier nie.  Een van die name sal moet verander.

* is reserved for internal use
Die term wat aangedui word is gereserveerde vir interne gebruik.
As dit bedoel is om 'n naam van 'n veranderlike of 'n klas te wees,
dan sal dit verander moet word.

native methods cannot have a body
Hier is 'n metode wat as "native" gedeklareer is, maar
nogtans 'n metodelyf het.  As dit "native"moet wees,
dan mag daar slegs 'n metode-opskrif gegee word.
Verwyder die metodelyf (die blok tussen krulhakies { } ),
of verwyder die sleutelwoord "native".

no enclosing instance of type {0} is in scope
Geen verdere hulp beskikbaar.

no interface expected here
Hier word verwys na 'n koppelvlak (moontlik in die "extends"
deklarasie van 'n klas).  'n Klas kan slegs 'n uitbreiding wees
van 'n ander klas, nie van'n koppelvlak nie.  Indien u wel vanaf 
die koppelvlak wil "erf" moet u die koppelvlak implementeer deur
die sleutelwoord "implements" te gebruik in plaas van "extends".

{0} has no match in entry in {1}; required {2}
Geen verdere hulp beskikbaar.

* is not defined in a public class or interface; cannot be accessed from outside package
Geen verdere hulp beskikbaar.

* cannot be accessed from outside package
Die klas wat u hier probeer gebruik is nie 'pubic' nie.
Dit beteken: die definisie daarvan begin nie met die volgende nie:
   public class ...
As 'n klas nie 'public' is nie, kan dit nie buitekant
sy eie pakket beguik word nie. As u regtig hierdie klas moet gebruik,
dan moet u sy definisie aanpas sodat dit 'public' is.

not a loop label: *
Die etikette wat u gebruik vir lusbewerkings, soos
   continue <etiket>;
moet gedefinieer word om 'n lus aan te dui (dit beteken: 
hulle moet geplaas word direk voor die begin van
'n lus). Die etiket wat u hier noem is nie op die regte
plek nie - dit dui nie die begin van 'n lus aan nie.

not a statement
Hier is 'n lyntjie kode wat nie 'n volledige Java uitdrukking 
of stelling is nie.  Kyk asb. weer mooi wat hier moet gebeur
en hoe die sintaks moet lyk.

not an enclosing class:*
You have tried to access the current object ('this') pointer
of another class outside your own. This is only allowed
if that other class is an enclosing class of the current one
(in other words: in an inner class you can access the outer
class, but no others).

* cannot be applied to *
Die operator of bewerkingsteken wat hier gebruik word, kan nie
gebruik word vir hierdie datatipes nie.  Die fout is dalk
'n verkeerde operator, verkeerde veranderlike of dalk 'n verkeerde datatipe.

* clashes with class of same name
Sorg dat die klas en die pakket verskillende name het.
Gewoonlik begin die naam van 'n klas met 'n hoofletter en die
naam van 'n pakkette met 'n kleinletter.

possible fall-through into case
Geen verdere hulp beskikbaar.

error reading *
Geen verdere hulp beskikbaar.

recursive constructor invocation
Volgens hierdie kode moet die konstruktor
homself roep.  Dit word nie toegelaat nie, want
dit sal waarskynlik in oneindige rekursie ontaard.

* is ambiguous, both *
Die identifiseerder se naam in hierdie boodskap kan
nie behoorlik onderskei word nie, want daar is meer as een 
klas of koppelvlak in die lys wat ingetrek word deur "import"
stellings wat hierdie naam het.  Die oplossing is om na die
klas te verwys met die volle kwalifikasie (bv. java.util.List) 
of om slegs die nodige klas in te trek deur die "import"-stelling
te kwalifiseer (byvoorbeeld: import java.util.List).

repeated interface
Hier is 'n herhaling van dieselfde koppelvlaknaam
in die "implements"-deklarasie.  Eenmaal is genoeg,
my geheue is nie so sleg nie :-)

repeated modifier
In hierdie deklarasie is dieselfde aanpasser tweemaal gebruik.
'n Aanpasser is 'n sleutelwoord soos:
  final, static, public, private, volatile, ...

{0} has {1} access in {2}
Geen verdere hulp beskikbaar.

return outside method
You can use a 'return' statement only in methods
(not in initializer blocks or other non-method
code segments).

signature does not match {0}; incompatible interfaces
Geen verdere hulp beskikbaar.

signature does not match {0}; incompatible supertype
Geen verdere hulp beskikbaar.

* should be declared abstract; it does not define *
Hierdie klas erf vanaf 'n abstrakte klas of koppelvlak.
Abtrakte klasse of koppelvlakke definieer metodes sonder om
'n implementering voor te skryf.  Hierdie konkrete klas moet
dus die implementering verskaf vir al die metodes wat nog nie
elkeen 'n lyf het nie.
As al die oorge\u00ebrfde metodes nie ge\u00efmplementeer word nie,
dan moet hierdie klas ook nog as abstrak gedefinieer word.

error writing source; cannot overwrite input file *
Geen verdere hulp beskikbaar.

'try' without 'catch' or 'finally'
As daar 'n "try"-blok in die kode is, dan moet dit
opgevolg word deur \u00f2f 'n "catch"-blok, \u00f2f 'n
"finally"-blok, of albei. Die regte patroon is soos volg:
   try {
      statements;
   }
   catch(Exception e) {
     statements;
   }
   finally {
      statements;
   }

* does not take parameters
Die tipe wat hier gebruik word kan nie parameters neem nie.
U kan nie hier 'n parameter gee nie.

wrong number of type arguments; required *
Geen verdere hulp beskikbaar.

type variable {0} occurs more than once in result type of {1}; cannot be left uninstantiated
Geen verdere hulp beskikbaar.

type variable {0} occurs more than once in type of {1}; cannot be left uninstantiated
Geen verdere hulp beskikbaar.

unclosed character literal
Hier is moontlik 'n karakterkonstante wat nie afgesluit is deur
'n elkel-aanhalingsteken aan die einde nie: '.

unclosed comment
Hier is moontlik kommentaar wat nie be\u00ebindig word met
die nodige */ karakters nie.

unclosed string literal
Hier is moontlik 'n Stringkonstante wat nie afgesluit is deur
'n dubbel-aanhalingsteken aan die einde nie: ".

undefined label: *
Die veranderlike waarna hier verwys word kan nie gevind word nie.
Dalk is dit nog nie gedeklareer nie, of dit is gedeklareer
buite die reikwydte ("scope") van hierdie instruksie.
Eersgenoemde moontlikheid kan maklik gebeur deur 'n spelfout
in die veranderlike se naam - let byvoorbeeld op die gebruik
van hoofletters ("aNumber" is nie dieselfde as "anumber" nie!)
Die tweede moontlikheid gebeur wanneer 'n veranderlike binne
'n bepaalde kodeblok { } gedeklareer word en daardie blok is 
op hierdie stadium afgesuit.  As daar byvoorbeeld 'n veranderlike
binne 'n "while"-lus gedeklareer is, is dit slegs sigbaar binne 
daardie lus.

unreachable statement
Hierdie stelling of instruksie sal nooit uitgevoer word nie.
Kyk weer goed na die kode en let op die vloeikontrole.
As dit werklik nie nodig is nie, moet dit uitgevee word,
anders moet die beheerstruktuur aangepas word.

initializer must be able to complete normally
Statiese inisialiseringsblokke kan nie onderbreek
word deur die aanmeld van uitsonderings of een of 
ander terminering nie, dit moet toegelaat word om
volledig uit te voer.

* must be caught or declared to be thrown
Hierdie kode roep 'n metode wat dalk 'n uitsondering kan aanmeld.
Daar is nou twee opsies: die uitsondering moet gevang en hanteer 
word, of dit moet aangestuur word om elders hanteer te kan word.
As u dit self wil hanteer, gebruik dan die struktuur:
   try 
   {
      ...
   }
   catch(...)
   {
      ...
   }
As u dit wil aanstuur, moet die metode se opskrif/kopstuk aantoon
dat dit hierdie uitsondering kan heraanmeld ("throws <ExceptionName>").

'void' type not allowed here
Die "void" tipe kan nie in hierdie konteks gebruik word nie.
Dit is 'n spesiale tipe wat by metodes gebruik word wat geen
teruggee-tipe het nie.

* not allowed here
Hier is 'n toegang aanpasser gebruik (iets soos 
"private", "protected", etc.). Hierdie aanpasser is nie
toelaatbaar op hierdie plek nie.

* might already have been assigned to
'n Veranderlike wat "final" is kan slegs eenmaal 'n waarde kry.
Hier is meer as een toekenning vir die betrokke "final"
veranderlike en volgens die kompileerder is dit moontlik dat
albei uitgevoer kan word.

* might not have been initialized
Hier word 'n lokale veranderlike gebruik sonder dat
dit gewaarborg is om eers ge\u00efnisialiseer te wees.
Dit het dus dalk op hierdie stadium nog nie 'n waarde nie.
As u twyfel, dan is dit beter om dit 'n waarde te gee
tesame met die deklarasie.

variable {0} might be assigned in loop
Geen verdere hulp beskikbaar.

error while writing *
Geen verdere hulp beskikbaar.

* is public, should be declared in a file named *
'n Klas wat as "public" gedeklareer is, moet gestoor 
word in 'n l\u00eaer met dieselfde naam as die klas 
(let ook op die gebruik van hoof- en kleinletters).
Verder moet die l\u00eaernaam die uitgang ".java" h\u00ea.
Byvoorbeerd: "public class Foo" moet gestoor word
'n 'n l\u00eaer genaamd "Foo.java".

cannot read: *
Geen verdere hulp beskikbaar.

* uses or overrides a deprecated API.
Hier word 'n metode gebruik wat nie meer aanbeveel word nie.
Daar is waarskynlik in die nuwe Java spesifikasie 'n ander
metode of klas wat nou hierdie funksionaliteit verskaf.
Kyk asb. in die dokumentasie van die Java klasbiblioteke
vir meer besonderhede.

* has been deprecated
Hier word 'n metode gebruik wat nie meer aanbeveel word nie.
Daar is waarskynlik in die nuwe Java spesifikasie 'n ander
metode of klas wat nou hierdie funksionaliteit verskaf.
Kyk asb. in die dokumentasie van die Java klasbiblioteke
vir meer besonderhede.

';' expected
Hier kort 'n kommapunt aan die einde van 'n lyntjie.
Dit is moontlik die lyntjie wat aangedui word, of
net die lyntjie daarbo.

'case', 'default' or '}' expected
Geen verdere hulp beskikbaar.

'class' or 'interface' expected
Die sleutelwoord "class" of "interface" word verwag
naby die begin van die bronkodel\u00eaer.
Dit is moontlik hier uitgelaat, of daar is ander teks
voor dit wat nie daar hoort nie.

'.class' expected
Geen verdere hulp beskikbaar.

'(' or '[' expected
Dit lys asof daar 'n onewe aantal hakies in die kode is
en dit maak die kompileerder deurmekaar.
Bestudeer die kode noukeurig om te sorg dat al die
beginhakies en eindhakies by mekaar pas.

* expected
Die simbool in die foutboodskap is op hierdie
punt in die kode verwag, maar dit was nie daar nie.
Probeer vasstel waarom hierdie simbool hier verwag is.

orphaned *
Geen verdere hulp beskikbaar.

cannot access *
Geen verdere hulp beskikbaar.

type parameter {0} is not within its bound *
Geen verdere hulp beskikbaar.

type parameters of {0} cannot be determined
Geen verdere hulp beskikbaar.

incompatible types*
'n Uitdrukking van 'n sekere tipe is hier benodig.
Daar was egter 'n uitdrukking van 'n ander tipe wat nie
versoenbaar is nie, byvoorbeeld 'n "String" is gevind
waar 'n "int" verwag was.

inconvertible types*
Die tipe wat hier gegee is kan nie outomaties
omgeskakel word na die verlangde tipe nie.

possible loss of precision
Geen verdere hulp beskikbaar.

unexpected type
'n Uitdrukking van 'n sekere tipe is hier benodig.
Daar was egter 'n uitdrukking van 'n ander tipe wat nie
versoenbaar is nie, byvoorbeeld 'n "String" is gevind
waar 'n "int" verwag was.

abstract {0} {1} cannot be accessed directly
Geen verdere hulp beskikbaar.

*An explicit 'this' qualifier must be used to select the desired instance.
Geen verdere hulp beskikbaar.

* cannot be referenced from a static context
You are trying to access an instance field or instance
method from a static method. That is not allowed. The
instance fields and methods belong to an object, while
you have no active object in static methods.
Static methods can only call other static methods in 
their class (or they need to use an explicit object
for the call).

cannot resolve symbol*
U gebruik hier 'n simbool ('n naam vir 'n veranderlike,
metode of klas) wat nog nie tot dusver gedefinieer is
binne die sigbare reikwydte nie.  Maak seker van die
spelling van die naam, en of u nie vergeet het om dit te
deklareer nie.  As dit wel gedeklareer is, is dit dalk
nie toeganklik van hier af nie (buite die reikwydte).


{0}; {1} and {2} are static
Geen verdere hulp beskikbaar.

{0}; overridden method is {1}
Geen verdere hulp beskikbaar.

* attempting to assign weaker access privileges; was *
U herdefinieer hier 'n metode en verander tergelykertyd die 
toegangsregte (private, protected, public). Dit is slegs moontlik 
om wyer toegangsregte toe te ken (bv. van private na public)
en nie om toegang in te perk nie (bv. van public na private). 
Natuurlik is dit ook toelaatbaar om dit te onveranderd weer te gee.

* overridden method does not throw *
U herdefinieer hier 'n metode en meld 'n uitsondering aan. 
Herdefini\u00ebrende metodes mag nie uitsonderings aanmeld 
as die superklas se metode dit nie ook aanmeld nie.
Die metode in die subklas mag dus minder uitsonderings aanmeld,
maar nie meer nie.

* attempting to use incompatible return type
Geen verdere hulp beskikbaar.

* is already defined in this compilation unit
U het hierdie naam vir die tweede maal gedefinieer. 
Kies 'n ander naam vir hierdie identifiseerder.

{0} is already defined in a single-type import
Geen verdere hulp beskikbaar.

* conflicts with a compiler-synthesized symbol in *
Geen verdere hulp beskikbaar.
