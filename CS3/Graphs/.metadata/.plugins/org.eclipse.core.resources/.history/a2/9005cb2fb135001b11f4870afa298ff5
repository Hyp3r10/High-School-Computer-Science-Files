import java.util.LinkedList;
import java.util.Queue;
import java.util.Scanner;
import java.util.Stack;
import java.util.TreeMap;
import java.util.TreeSet;

public class TrailOfPrimes {
	public static TreeSet<Node> primes; 				// A Set of all four digit prime numbers
	public static TreeMap<Node, TreeSet<Node>> graph;	// Keeps track of the current graph of prime numbers and their edges
	public static void main(String[] args) {
		// Get the list of 4 digit prime numbers
		generateFourDigitPrimeNumbers();
		// Generate the graph
		generateGraph();
		// Get input
		Scanner scan = new Scanner(System.in);
		while(scan.hasNextLine()) {
			System.out.println("Input\t: ");
			Node start = new Node(scan.nextInt());
			Node end = new Node(scan.nextInt());
			// Solve the graph
			System.out.println("Output\t: " + bfs(start, end).size() + "\n");
		}
	}
	public static Stack<Node> bfs(Node start, Node end) {
		Queue<Stack<Node>> toSearch = new LinkedList<Stack<Node>>();
		Stack<Node> tempStack = new Stack<Node>();
		TreeSet<Node> visited = new TreeSet<Node>();
		tempStack.add(start);
		toSearch.add(tempStack);
		while(!toSearch.isEmpty()) {
			Stack<Node> currStack = toSearch.poll();
			Node curr = currStack.peek();
			if(curr.equals(end)) {
				return currStack;
			}
			if(!visited.contains(curr)) {
				visited.add(curr);
				for(Node search : graph.get(curr)) {
					Stack<Node> newStack = clone(currStack);
					newStack.add(search);
					toSearch.add(newStack);
				}
			}
 		}
		return new Stack<Node>();
	}
	/**
	 * Clones the passed stack and returns a copy of it
	 * @param stack	The original stack
	 * @return		The copied stack
	 */
	private static Stack<Node> clone(Stack<Node> stack) {
		Stack<Node> backwards = new Stack<Node>();
		while(!stack.isEmpty()) {
			backwards.push(stack.pop());
		}
		Stack<Node> newStack = new Stack<Node>();
		while(!backwards.isEmpty()) {
			Node curr = backwards.pop();
			stack.push(curr);
			newStack.push(curr);
		}
		return newStack;
	}
	/**
	 * Generates the graph of 4 digit prime numbers
	 */
	public static void generateGraph() {
		Queue<Node> toSearch = new LinkedList<Node>();
		toSearch.addAll(primes);
		while(!toSearch.isEmpty()) {
			Node curr = toSearch.poll();
			TreeSet<Node> neighbors = getOneDiff(curr);
			graph.put(curr, neighbors);
		}
	}
	/**
	 * Generates a Set of Nodes that are one off of the current node
	 * and is contained within the list of 4 digit prime numbers
	 * @param curr	The Node in question
	 * @return		The set of Nodes that are one off of the current node
	 */
	private static TreeSet<Node> getOneDiff(Node curr) {
		TreeSet<Node> neighbors = new TreeSet<Node>();
		for(int i = 1111; i <= 9999; i++) {
			Node temp = new Node(i);
			if(primes.contains(temp) && curr.getNumDifference(temp) == 1) {
				neighbors.add(temp);
			}
		}
		return neighbors;
	}
	/**
	 * Generates a Set of 4-digit Prime numbers
	 */
	public static void generateFourDigitPrimeNumbers() {
		// Generate prime numbers from 2 ... 9999
		Queue<Integer> original = new LinkedList<Integer>();
		for(int i = 2; i <= 9999; i++) {
			original.add(i);
		}
		Queue<Integer> primesQueue = new LinkedList<Integer>();
		while(!original.isEmpty()) {
			// Add the first value in the queue (P, the next prime) to the queue of primes
			int P = original.remove();
			primesQueue.add(P);
			// Iterate through the queue, eliminating numbers divisible by the P that 
			// can't be primes while leaving numbers not divisible by P
			Queue<Integer> temp = new LinkedList<Integer>();
			while(!original.isEmpty()) {
				Integer curr = original.poll();
				boolean trash = curr%P == 0 ? false : temp.add(curr);
			}
			original = temp;
		}
		// Only add all 4 digit numbers
		primes = new TreeSet<Node>();
		while(true) {
			int curr = primesQueue.poll();
			if(("" + curr).length() == 4) {
				primes.add(new Node(curr));
			}
		}
	}
}
class Node implements Comparable<Node> {
	public int[] num;	// Handles this node's number
	/**
	 * Constructs a Node object with the passed number num
	 * @param num	The number that this node represents
	 */
	public Node(int num) {
		this.num = new int[4];
		String[] temp = ("" + num).split("");
		int i = 0;
		for(String curr : temp) {
			this.num[i++] = Integer.parseInt(curr);
		}
	}
	/**
	 * Tests to see if two nodes are identical
	 * @param other	The other Node object in question
	 * @return		Whether or not the two nodes are the same
	 */
	public boolean equals(Node other) {
		for(int i = 0; i < 4; i++) {
			if(other.num[i] != this.num[i]) {
				return false;
			}
		}
		return true;
	}
	@Override
	public int compareTo(Node other) {
		return this.getNumDifference(other);
	}
	public int getNumDifference(Node other) {
		int diff = 0;
		for(int i = 0; i < 4; i++) {
			if(other.num[i] != this.num[i]) {
				diff++;
			}
		}
		return diff;
	}
	@Override
	public String toString() {
		return "" + this.num[0] + this.num[1] + this.num[2] + this.num[3];
	}
}